---
name: 形式密码学导论
goal: 对密码学的科学与实践进行深入介绍。
objectives:
  - 探索贝尔密码和现代加密方法，以理解密码学的基本和历史概念。
  - 深入研究数论、群和域，掌握密码学背后的关键数学概念。
  - 学习RC4流密码和128位密钥的AES，了解对称加密算法。
  - 调查RSA密码系统、密钥分发和哈希函数，探索非对称加密。

---
# 深入探讨密码学

在密码学教育中，很难找到一个好的中间立场的材料。

一方面，有冗长的、正式的论述，真正只适合那些在数学、逻辑或其他某些正式学科有强大背景的人。另一方面，有非常高层次的介绍，实在是对于至少有一点好奇心的人隐藏了太多细节。

这本关于密码学的介绍旨在捕捉中间立场。虽然对于密码学新手来说应该是相对具有挑战性和详细的，但它不是典型的基础论述的兔子洞。

+++

# 导论
<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## 简短描述
<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

本书提供了对密码学的科学与实践的深入介绍。在可能的情况下，它侧重于概念性而非形式性的材料阐述。

> 本课程基于[JWBurgers的仓库](https://github.com/JWBurgers/An_Introduction_to_Cryptography)。所有权利归他所有。内容尚未完成，仅用于展示如果JWburger同意，我们如何能够整合它。

### 动机和目标

在密码学教育中，很难找到一个好的中间立场的材料。

一方面，有冗长的、正式的论述，真正只适合那些在数学、逻辑或其他某些正式学科有强大背景的人。另一方面，有非常高层次的介绍，实在是对于至少有一点好奇心的人隐藏了太多细节。

这本关于密码学的介绍旨在捕捉中间立场。虽然对于密码学新手来说应该是相对具有挑战性和详细的，但它不是典型的基础论述的兔子洞。

### 目标受众

从开发者到求知欲强的人，这本书对任何想要对密码学有超过肤浅理解的人都有用。如果你的目标是掌握密码学领域，那么这本书也是一个很好的起点。

### 阅读指南

目前书中包含七章：“什么是密码学？”（第1章）、“密码学的数学基础I”（第2章）、“密码学的数学基础II”（第3章）、“对称密码学”（第4章）、“RC4和AES”（第5章）、“非对称密码学”（第6章）和“RSA密码系统”（第7章）。最后一章，“密码学实践”，将会添加。它聚焦于各种密码学应用，包括传输层安全、洋葱路由和比特币的价值交换系统。
除非你在数学方面有很强的背景，否则数论可能是本书中最难的主题。我在第3章提供了一个概述，并且在第5章介绍AES以及第7章介绍RSA密码系统时也提到了数论。
如果你真的在这些部分的正式细节上遇到了困难，我建议你第一次阅读时选择对它们进行高层次的阅读。

### 致谢

在塑造这本书方面最有影响力的书籍是Jonathan Katz和Yehuda Lindell的《现代密码学导论》，CRC出版社（佛罗里达州博卡拉顿），2015年。Coursera上有一门伴随课程叫做“密码学”。

在创建本书概述时，其他一些有帮助的主要资源包括Simon Singh的《密码书》，Fourth Estate（伦敦，1999年）；Christof Paar和Jan Pelzl的《理解密码学》，Springer（海德堡，2010年）以及[基于Paar的书的课程叫做“密码学导论”](https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg)；以及Bruce Schneier的《应用密码学》，第二版，2015年（印第安纳波利斯，IN：John Wiley & Sons）。

我只会引用我从这些资源中获取的非常具体的信息和结果，但在这里想要承认我对它们的普遍感激。

对于那些在本书介绍之后希望寻求更高级密码学知识的读者，我强烈推荐Katz和Lindell的书。Katz在Coursera上的课程比书本更容易接近。

### 贡献

请查看[仓库中的贡献文件](https://github.com/JWBurgers/An_Introduction_to_Cryptography/blob/master/Contributions.md)，了解如何支持该项目的一些指南。

### 符号说明

**关键术语：**

引言中的关键术语通过加粗来介绍。例如，作为关键术语引入的Rijndael密码将如下所示：**Rijndael密码**。

除非它们是专有名词或者从讨论中明显可以看出其含义，否则关键术语会被明确定义。

通常在引入关键术语时给出定义，尽管有时直到稍后才给出定义更为方便。

**强调的单词和短语：**

通过斜体来强调单词和短语。例如，“记住你的密码”将如下所示：*记住你的密码*。

**正式符号：**

正式符号主要涉及变量、随机变量和集合。

* 变量：这些通常仅由小写字母表示（例如，“x”或“y”）。有时为了清晰起见，它们会被大写（例如，“M”或“K”）。
* 随机变量：这些总是由大写字母表示（例如，“X”或“Y”）
* 集合：这些总是由粗体、大写字母表示（例如，**S**）

# 什么是密码学？
<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

## 贝尔密码
<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>
让我们从密码学领域的历史中一个更加迷人和娱乐性的章节开始我们的探索：贝尔密码（Beale ciphers）。[1]
在我看来，贝尔密码的故事更像是虚构而非现实。但据说事情是这样发生的。

在1820年和1822年的冬季，一个名叫托马斯·J·贝尔（Thomas J. Beale）的人在弗吉尼亚州林奇堡（Lynchburg）的罗伯特·莫里斯（Robert Morriss）拥有的旅馆里住过两次。在贝尔第二次住宿结束时，他交给莫里斯一个装有珍贵文件的铁盒以供保管。

几个月后，莫里斯收到了贝尔在1822年5月9日写的一封信。信中强调了铁盒内容的巨大价值，并向莫里斯提供了一些指示：如果贝尔或他的任何伙伴都没有来领取盒子，他应该在信件日期的十年后（即1832年5月9日）准确地打开它。盒子里的一些文件将以普通文本书写。然而，其他一些文件则“在没有钥匙的帮助下无法理解”。这个“钥匙”将在1832年6月由贝尔的一位未命名的朋友交给莫里斯。

尽管有明确的指示，莫里斯在1832年5月并没有打开盒子，而贝尔的神秘朋友也没有在那年的6月出现。直到1845年，旅馆老板最终决定打开盒子。他在里面发现了一张便条，解释了贝尔和他的伙伴如何在西部发现了金银，并将其连同一些珠宝埋藏起来以供保管。此外，盒子还包含三个**密文**：即用代码书写的文本，需要一个**密码钥匥**或一个秘密以及一个相应的算法来解锁。这个解锁密文的过程被称为**解密**，而加锁过程被称为**加密**。（如第3章所解释，cipher这个词可以有不同的含义。在“贝尔密码”这个名字中，它是密文的简称。）

莫里斯在铁盒中发现的三个密文，每个都由逗号分隔的一系列数字组成。根据贝尔的便条，这些密文分别提供了宝藏的位置、宝藏的内容以及宝藏的合法继承人及其份额的名单（后者信息在贝尔和他的伙伴永远没有来领取盒子的情况下相关）。

莫里斯试图解密这三个密文达二十年之久。如果有钥匙，这本来是很容易的。但莫里斯没有钥匙，并且未能成功恢复原始文本，或者在密码学中通常称为的**明文**。

在临近生命终点时，莫里斯在1862年将盒子传给了一个朋友。这位朋友随后在1885年以化名J.B. Ward出版了一本小册子。它包括了（据称的）盒子历史的描述、三个密文以及他为第二个密文找到的解决方案。（显然，每个密文都有一个钥匙，而不是贝尔在给莫里斯的信中最初似乎提议的一个钥匙可以解开所有三个密文。）

你可以在下面的*图2*中看到第二个密文。[2] 这个密文的钥匙是《美国独立宣言》。解密程序归结为应用以下两条规则：
* 对于密文中的任何数字n，找到《美国独立宣言》中的第n个单词* 将数字n替换为你找到的单词的第一个字母

*图1：贝尔密码第2号*

![图1：贝尔密码第2号](assets/Figure1-1.webp "图1：贝尔密码第2号")

例如，第二个密文的第一个数字是115。《独立宣言》的第115个单词是“instituted”，所以明文的第一个字母是“i”。密文并没有直接指示单词间的空格和大小写。但是，在解密了前几个单词后，你可以逻辑推断出明文的第一个单词就是“I”。（明文以短语“I have deposited in the county of Bedford.”开始。）

解密后，第二条信息提供了宝藏（黄金、白银和珠宝）的详细内容，并暗示它被埋在弗吉尼亚州贝德福德县的铁罐中并用石头覆盖。人们喜欢一个好的谜团，因此在解密其他两个贝尔密码上投入了巨大的努力，特别是描述宝藏位置的那一个。即便是各种著名的密码学家也尝试过它们。然而，到目前为止，还没有人能够解密其他两个密文。

**注释：**

[1] 关于这个故事的一个好的总结，参见Simon Singh的*The Code Book*，Fourth Estate（伦敦，1999年），第82-99页。Andrew Allen在2010年制作了一个关于这个故事的短片。你可以在其网站上找到这部电影，“The Thomas Beale Cipher”（http://www.thomasbealecipher.com/）。

[2] 这张图片可以在维基百科的贝尔密码页面上找到。

## 现代密码学
<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

像贝尔密码这样的多彩故事是我们大多数人与密码学联系在一起的。然而，现代密码学至少在四个重要方面不同于这些历史例子。

首先，历史上密码学只关注**保密性**（或机密性）。[3] 会创建密文以确保只有特定的方可知晓明文中的信息，就像贝尔密码的情况一样。为了使加密方案能够很好地服务于这一目的，只有拥有密钥的情况下才能解密密文。

现代密码学关注的主题范围比仅仅是保密性要广。这些主题主要包括（1）**消息完整性**——即确保消息未被更改；（2）**消息真实性**——即确保消息确实来自特定发送者；以及（3）**不可否认性**——即确保发送者无法事后虚假否认她发送了消息。[4]

因此，需要记住的一个重要区别是，**加密方案**和**密码学方案**之间的区别。加密方案只关注保密性。虽然加密方案是密码学方案，但反之则不成立。密码学方案还可以服务于密码学的其他主要主题，包括完整性、真实性和不可否认性。
完整性和真实性的主题与保密性一样重要。如果没有关于通信的完整性和真实性的保证，我们的现代通信系统将无法正常运作。不可否认性也是一个重要的考虑因素，例如对于数字合同，但在密码学应用中，与保密性、完整性和真实性相比，不可否认性的需求不那么普遍。

其次，经典的加密方案，如贝尔密码，总是涉及一个在所有相关方之间共享的密钥。然而，许多现代的密码学方案不仅涉及一个密钥，而且涉及两个密钥：一个**私钥**和一个**公钥**。前者在任何应用中都应保持私密，而后者通常是公开知识（因此，它们各自的名称）。在加密领域内，公钥可以用来加密消息，而私钥可以用来解密。

处理所有方共享一个密钥的方案的密码学分支被称为**对称密码学**。这样的方案中的单一密钥通常被称为**私钥**（或秘密密钥）。处理需要私钥-公钥对的方案的密码学分支被称为**非对称密码学**。这些分支有时也被分别称为**私钥密码学**和**公钥密码学**（尽管这可能引起混淆，因为公钥密码学方案也有私钥）。

非对称密码学在20世纪70年代末的出现是密码学历史上最重要的事件之一。没有它，我们的大多数现代通信系统，包括比特币，要么不可能存在，要么至少非常不实用。

重要的是，现代密码学不仅仅是对称和非对称密钥密码学方案的研究（尽管这涵盖了该领域的大部分）。例如，密码学还涉及哈希函数和伪随机数生成器，你可以在这些原语上构建与对称或非对称密钥密码学无关的应用。

第三，像贝尔密码这样的经典加密方案更多的是艺术而非科学。它们的安全性主要基于对其复杂性的直觉。当学习到对它们的新攻击时，它们通常会被修补，或者如果攻击特别严重，则完全放弃。然而，现代密码学是一门严谨的科学，采用正式的、数学的方法来开发和分析密码学方案。[5]

具体来说，现代密码学侧重于正式的**安全性证明**。任何密码学方案的安全性证明都包括三个步骤：

1.	陈述一个**密码学定义的安全性**，即一组安全目标和攻击者构成的威胁。
2.	陈述关于方案的计算复杂性的任何数学假设。例如，一个密码学方案可能包含一个伪随机数生成器。尽管我们不能证明这些存在，但我们可以假设它们确实存在。
3.	基于正式的安全性概念和任何数学假设，展示方案的数学**安全性证明**。

第四，历史上密码学主要用于军事设置，但在数字时代，它已经渗透到我们日常活动中。无论你是在线银行操作、在社交媒体上发布、用信用卡从亚马逊购买产品，还是给朋友小费比特币，密码学都是我们数字时代不可或缺的。

鉴于现代密码学的这四个方面，我们可能将现代**密码学**描述为一门关注于正式开发和分析密码学方案以抵御对抗性攻击并保护数字信息安全的科学。[6] 这里的安全应广泛理解为防止破坏通信中的保密性、完整性、认证和/或不可否认性的攻击。
密码学最好被视为**网络安全**的一个子学科，它关注的是防止计算机系统被盗、损坏和误用。注意，许多网络安全问题与密码学只有很小或部分联系。

例如，如果一家公司在本地拥有昂贵的服务器，他们可能会担心保护这些硬件免受盗窃和损坏。虽然这是一个网络安全问题，但它与密码学关系不大。

再举一个例子，**网络钓鱼攻击**是我们现代社会的一个常见问题。这些攻击尝试通过电子邮件或其他消息媒介欺骗人们放弃敏感信息，如密码或信用卡号。虽然密码学在一定程度上可以帮助解决网络钓鱼攻击，但全面的方法需要的不仅仅是使用一些密码学技术。

**注释：**

[3] 准确地说，密码学方案的重要应用一直与保密有关。例如，孩子们经常使用简单的密码学方案来“玩乐”。在这些情况下，保密并不是真正的关注点。

[4] 布鲁斯·施奈尔，《应用密码学》，第二版，2015年（印第安纳波利斯，IN：约翰威利与儿子公司），第2页。

[5] 参见乔纳森·卡茨和耶胡达·林德尔，《现代密码学导论》，CRC出版社（佛罗里达州博卡拉顿：2015年），特别是第16-23页，对此有很好的描述。

[6] 参考卡茨和林德尔，同上，第3页。我认为他们的表述有些问题，所以在这里提出一个略有不同的版本。

## 开放通信
<chapterId>cb23d0a6-ba9a-5dc6-a55a-258405ae4117</chapterId>

现代密码学旨在提供**开放通信**环境中的安全保障。如果我们的通信渠道受到如此良好的保护，以至于窃听者没有机会操纵甚至仅仅是观察我们的消息，那么密码学就变得多余了。然而，我们的大多数通信渠道远非如此安全。

现代世界通信的支柱是一个庞大的光纤网络。在现代家庭中打电话、看电视和浏览网页通常依赖于这个光纤网络（一小部分可能完全依赖于卫星）。确实，你的家中可能有不同的数据连接，如同轴电缆、（非对称）数字用户线和光纤电缆。但至少在发达世界，这些不同的数据介质很快在你家外面汇聚到一个节点，在这个节点上连接着连接全球的庞大光纤网络。例外是发达世界的一些偏远地区，如美国和澳大利亚，那里的数据流量可能仍然会在传统的铜质电话线上行驶很长一段距离。

要阻止潜在攻击者物理接触这些网络和其支持基础设施是不可能的。事实上，我们已经知道，我们的大部分数据在互联网的关键交叉点被各国情报机构截获。[7] 这包括从Facebook消息到你访问的网站地址的一切。

虽然在大规模监视数据需要一个强大的对手，如一个国家情报机构，但只有少数资源的攻击者可以很容易地尝试在更局部的规模上进行窥探。尽管这可能发生在接线水平上，但拦截无线通信要容易得多。
我们的本地网络数据——无论是在我们的家中、办公室还是咖啡馆——现在大多通过无线电波传输到一体化路由器上的无线接入点，而不是通过物理电缆。因此，攻击者需要很少的资源就可以截获你的任何本地流量。这尤其令人担忧，因为大多数人很少采取措施保护跨他们本地网络传输的数据。此外，潜在的攻击者还可以针对我们的移动宽带连接，如3G、4G和5G。所有这些无线通信都是攻击者的易攻目标。
因此，在现代世界中，通过保护通信渠道来保持通信秘密的想法是一个绝望的幻想。我们所知的一切都需要极度的偏执：你应该始终假设有人在监听。而密码学是我们在这个现代环境中获得任何安全性的主要工具。

**注释：**

[7] 例如，参见Olga Khazan，“海底电缆窃听的令人毛骨悚然的长期实践”，*大西洋月刊*，2013年7月16日（可在[大西洋月刊](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/)获取）。

# 密码学的数学基础 1
<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

## 随机变量
<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

密码学依赖于数学。如果你想对密码学有一个超越表面的理解，你需要对这些数学感到舒适。

本章介绍了你在学习密码学时会遇到的大多数基础数学。这些主题包括随机变量、模运算、异或运算和伪随机性。你应该掌握这些部分的材料，以便对密码学有一个非肤浅的理解。

下一节将处理数论，这是更具挑战性的内容。

### 随机变量

随机变量通常用非粗体的大写字母表示。因此，例如，我们可能谈论一个随机变量$X$、一个随机变量$Y$或一个随机变量$Z$。这也是我从现在开始将要使用的表示法。

**随机变量**可以取两个或更多可能的值，每个值都有一定的正概率。可能的值列在**结果集**中。

每次你**抽样**一个随机变量时，你都会根据定义的概率从其结果集中抽取一个特定的值。

让我们来看一个简单的例子。假设一个变量$X$定义如下：

- $X$的结果集为$\{1,2\}$

$$
Pr[X = 1] = 0.5
$$

$$
Pr[X = 2] = 0.5
$$

很容易看出$X$是一个随机变量。首先，$X$可以取两个或更多可能的值，即$1$和$2$。其次，每次你抽样$X$时，每个可能的值都有发生的正概率，即$0.5$。
随机变量所需的一切就是一个具有两个或更多可能性的结果集，其中每个可能性在抽样时都有正概率发生。因此，原则上，随机变量可以被抽象地定义，不涉及任何上下文。在这种情况下，你可能会将“抽样”想象为进行某种自然实验以确定随机变量的值。
上述变量 $X$ 被抽象定义。因此，你可能会想象抽样变量 $X$ 就像是抛掷一枚公平的硬币，并在正面朝上时分配“2”，在反面朝上时分配“1”。对 $X$ 的每个样本，你再次抛掷硬币。

或者，你也可以想象抽样 $X$，就像是掷一个公平的骰子，并在骰子落在 $1$、$3$ 或 $4$ 时分配“2”，在骰子落在 $2$、$5$ 或 $6$ 时分配“1”。每次你抽样 $X$，你再次掷骰子。

实际上，任何能让你定义上述 $X$ 的可能值的概率的自然实验都可以想象出来。

然而，随机变量通常不仅仅是抽象地引入。相反，可能的结果值集合具有明确的现实世界意义（而不仅仅是作为数字）。此外，这些结果值可能是针对某种特定类型的实验定义的（而不是作为任何具有这些值的自然实验）。

现在让我们考虑一个不是抽象定义的变量 $X$ 的例子。$X$ 被定义为以下方式以确定哪个足球队开始比赛：

- $X$ 的结果集为 {红队开球, 蓝队开球}
- 抛掷特定的硬币 $C$：反面 = “红队开球”；正面 = “蓝队开球”

$$
Pr [X = \text{红队开球}] = 0.5
$$

$$
Pr [X = \text{蓝队开球}] = 0.5
$$

在这种情况下，X 的结果集提供了一个具体的含义，即哪个队伍在足球比赛中开始。此外，可能的结果及其相关概率是由一个具体的实验决定的，即抛掷特定的硬币 $C$。

在密码学讨论中，随机变量通常是针对具有现实世界意义的结果集引入的。这可能是所有可能被加密的消息的集合，称为消息空间，或者是使用加密的各方可以选择的所有密钥的集合，称为密钥空间。

然而，在密码学讨论中，随机变量通常不是针对某个特定的自然实验定义的，而是针对可能产生正确概率分布的任何实验定义的。

随机变量可以有离散或连续的概率分布。具有**离散概率分布**的随机变量——即离散随机变量——有有限数量的可能结果。到目前为止给出的两个例子中的随机变量 $X$ 都是离散的。

**连续随机变量**则可以在一个或多个区间内取值。例如，你可能会说，一个随机变量在抽样时会取 0 到 1 之间的任何实数值，并且这个区间内的每个实数都同样可能。在这个区间内，有无限多的可能值。

对于密码学讨论，你只需要理解离散随机变量。因此，从现在开始的任何关于随机变量的讨论都应该被理解为指的是离散随机变量，除非特别指明了其他情况。

### 绘制随机变量的图形
随机变量的可能值及其相关概率可以通过图形轻松可视化。例如，考虑上一节中的随机变量 $X$，其结果集为 $\{1, 2\}$，且 $Pr [X = 1] = 0.5$ 和 $Pr [X = 2] = 0.5$。我们通常会以条形图的形式展示这样的随机变量，如*图1*所示。
*图1：随机变量X*

![图1：随机变量X。](assets/Figure2-1.webp)

*图1*中的宽条并不意味着随机变量 $X$ 实际上是连续的。相反，条形被制作得宽一些是为了更具视觉吸引力（仅仅一条直线向上提供的直观感知较少）。  

### 均匀变量

在“随机变量”这个表达中，“随机”仅仅意味着“概率性的”。换句话说，它仅意味着变量的两个或多个可能结果发生具有某些概率。然而，这些结果*不一定*都具有相同的可能性（尽管在其他上下文中“随机”确实可以有这个意义）。

**均匀变量**是随机变量的一个特例。它可以取两个或更多个值，这些值都具有相等的概率。如*图1*所示的随机变量 $X$ 显然是一个均匀变量，因为两个可能的结果都以 $0.5$ 的概率发生。然而，有许多随机变量并不是均匀变量的实例。

例如，考虑随机变量 $Y$。它的结果集为 $\{1, 2, 3, 8, 10\}$，并且具有以下概率分布：

$$
\Pr[Y = 1] = 0.25
$$

$$
\Pr[Y = 2] = 0.35
$$

$$
\Pr[Y = 3] = 0.1
$$

$$
\Pr[Y = 8] = 0.25
$$

$$
\Pr[Y = 10] = 0.05
$$

虽然两个可能的结果确实具有相等的发生概率，即 $1$ 和 $8$，但在抽样时，$Y$ 也可以取某些与 $0.25$ 不同的概率值。因此，虽然 $Y$ 确实是一个随机变量，但它不是一个均匀变量。

$Y$ 的图形描述在*图2*中提供。

*图2：随机变量Y*

![图2：随机变量Y。](assets/Figure2-2.webp "图2：随机变量Y")

最后一个例子，考虑随机变量 Z。它的结果集为 {1,3,7,11,12}，并且具有以下概率分布：

$$
\Pr[Z = 2] = 0.2
$$

$$
\Pr[Z = 3] = 0.2
$$

$$
\Pr[Z = 9] = 0.2
$$

$$
\Pr[Z = 11] = 0.2
$$

$$
\Pr[Z = 12] = 0.2
$$

你可以在*图3*中看到它的描述。与 Y 相反，随机变量 Z 是一个均匀变量，因为在抽样时所有可能值的概率都是相等的。

*图3：随机变量Z*
![图 3：随机变量 Z。](assets/Figure2-3.webp "Figure 3: Random variable Z")

### 条件概率

假设鲍勃打算从上一年历的日历中均匀选择一天。我们应该如何判断所选天数落在夏季的概率是多少？

只要我们认为鲍勃的选择过程确实是完全均匀的，我们就应该得出鲍勃选择夏季某天的概率是 1/4。这是随机选中的日子落在夏季的**无条件概率**。

现在假设鲍勃不是均匀地抽取日历上的一天，而是只从新泽西州水晶湖（Crystal Lake）中午温度达到或超过 21 摄氏度的那些天中均匀选择。鉴于这一额外信息，我们可以得出鲍勃选择夏季某天的概率是多少？

即使没有任何进一步的具体信息（例如，去年全年每天中午的温度），我们也应该得出与之前不同的结论。

知道水晶湖位于新泽西州，我们肯定不会期望冬季中午的温度达到或超过 21 摄氏度。相反，更有可能是春季或秋季的一个温暖日子，或者是夏季的某一天。因此，知道水晶湖在所选日子中午的温度达到或超过 21 摄氏度，鲍勃选择的日子落在夏季的概率变得更高。这是鉴于水晶湖中午温度达到或超过 21 摄氏度的条件下，随机选中的日子落在夏季的**条件概率**。

与前一个例子不同，两个事件的概率也可以完全无关。在这种情况下，我们说它们是**独立的**。

例如，假设一个公平的硬币已经落地朝上。鉴于这一事实，那么明天下雨的概率是多少？在这种情况下，条件概率应该与明天下雨的无条件概率相同，因为硬币的翻转通常不会对天气产生任何影响。

我们使用 "|" 符号来书写条件概率陈述。例如，事件 $A$ 在事件 $B$ 发生的条件下的概率可以这样写：

$$
Pr[A|B]
$$

所以，当两个事件 $A$ 和 $B$ 是独立的时，那么：

$$
Pr[A|B] = Pr[A] \text{ 和 } Pr[B|A] = Pr[B]
$$

独立性的条件可以简化如下：

$$
Pr[A, B] = Pr[A] \cdot Pr[B]
$$

概率论中的一个关键结果被称为**贝叶斯定理**。它基本上表明 $Pr[A|B]$ 可以如下重写：

$$
Pr[A|B] = \frac{Pr[B|A] \cdot Pr[A]}{Pr[B]}
$$

我们也可以用两个或更多随机变量上的一组可能事件的条件概率，而不是使用具体事件的条件概率。假设有两个随机变量，$X$ 和 $Y$。我们可以用 $x$ 表示 $X$ 的任何可能值，用 $y$ 表示 $Y$ 的任何可能值。那么，我们可能会说，如果以下陈述成立，则两个随机变量是独立的：

$$
Pr[X = x, Y = y] = Pr[X = x] \cdot Pr[Y = y]
$$

对于所有的 $x$ 和 $y$。

让我们对这个陈述的含义做更明确的说明。
假设 $X$ 和 $Y$ 的结果集定义如下：**X** = $\{x_1, x_2, \ldots, x_i, \ldots, x_n\}$ 和 **Y** = $\{y_1, y_2, \ldots, y_i, \ldots, y_m\}$。（通常用粗体大写字母表示值的集合。）
现在假设你抽样 $Y$ 并观察到 $y_1$。上述陈述告诉我们，现在从 $X$ 抽样获得 $x_1$ 的概率，就像我们从未观察到 $y_1$ 一样。对于我们从 $Y$ 的初始抽样中可能抽取的任何 $y_i$，这都是真的。最后，这不仅适用于 $x_1$。对于任何 $x_i$，发生的概率都不受 $Y$ 抽样结果的影响。所有这些也适用于首先抽样 $X$ 的情况。

让我们以一个稍微更哲学的观点结束我们的讨论。在任何现实世界情况下，某个事件的概率总是针对特定的信息集来评估的。在非常严格的意义上，没有“无条件概率”。

例如，假设我问你到2030年猪会飞的概率。虽然我没有给你更多信息，但你显然知道很多关于世界的信息，这些信息可以影响你的判断。你从未见过猪飞。你知道大多数人不会期望它们飞。你知道它们并不是真的被造来飞。等等。

因此，当我们在现实世界背景下谈论某个事件的“无条件概率”时，这个术语真正的意义只能是如果我们将其理解为“没有任何进一步明确信息的概率”。那么，任何对“条件概率”的理解，都应该始终针对某个特定的信息。

例如，我可能会在给你证据之后问你到2030年猪会飞的概率，证据是新西兰的一些山羊在几年的训练后学会了飞。在这种情况下，你可能会调整你对2030年猪会飞的概率的判断。所以到2030年猪会飞的概率是基于关于新西兰山羊的这个证据的条件。

## 模运算
<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

### 模运算

**模运算**的最基本表达式如下：$x \mod y$。

变量 $x$ 被称为被除数，变量 $y$ 被称为除数。要用正被除数和正除数进行模运算，你只需确定除法的余数。

例如，考虑表达式 $25 \mod 4$。数字4进入数字25共6次。该除法的余数是1。因此，$25 \mod 4$ 等于 1。以类似的方式，我们可以评估下面的表达式：

* $29 \mod 30 = 29$（因为30进入29共0次，余数是29）
* $42 \mod 2 = 0$（因为2进入42共21次，余数是0）
* $12 \mod 5 = 2$（因为5进入12总共2次，余数是2）
* $20 \mod 8 = 4$（因为8进入20总共2次，余数是4）

当被除数或除数为负数时，不同的编程语言可能会以不同的方式处理模运算。

在密码学中，你肯定会遇到被除数为负数的情况。在这些情况下，典型的处理方法如下：

* 首先确定最接近被除数且小于或等于被除数的值，该值被除数除以后余数为零。称这个值为$p$。
* 如果被除数为$x$，那么模运算的结果就是$x – p$的值。

例如，假设被除数是$–20$，除数是3。最接近$–20$且小于或等于$–20$的值，3可以整除的是$–21$。这种情况下$x – p$的值是$–20 – (–21)$。这等于1，因此，$–20 \mod 3$等于1。以类似的方式，我们可以评估下面的表达式：

* $–8 \mod 5 = 2$
* $–19 \mod 16 = 13$
* $–14 \mod 6 = 4$

关于符号，你通常会看到以下类型的表达式：$x = [y \mod z]$。由于括号的存在，这种情况下模运算仅适用于表达式的右侧。例如，如果$y$等于25且$z$等于4，那么$x$计算结果为1。

没有括号时，模运算作用于表达式的*两边*。例如，假设以下表达式：$x = y \mod z$。如果$y$等于25且$z$等于4，那么我们只知道$x \mod 4$的计算结果为1。这与$x$的任何值一致，这些值来自集合$\{\ldots,–7, –3, 1, 5, 9,\ldots\}$。

涉及对数字和表达式进行模运算的数学分支被称为**模运算**。你可以将这个分支视为数字线不是无限长的情况下的算术。虽然我们在密码学中通常遇到的是对（正）整数进行模运算，但你也可以使用任何实数进行模运算。

### 移位密码

模运算在密码学中经常遇到。为了说明这一点，让我们考虑最著名的历史加密方案之一：移位密码。

首先定义它。假设一个字典*D*，它按顺序将英文字母表的所有字母与数字集$\{0, 1, 2, \ldots, 25\}$等同起来。假设一个消息空间**M**。那么，**移位密码**就是这样定义的加密方案：

- 从密钥空间**K**中均匀选择一个密钥$k$，其中**K** = $\{0, 1, 2, \ldots, 25\}$ [1]
- 按如下方式加密消息$m \in \mathbf{M}$：
    - 将$m$分解为其各个字母$m_0, m_1, \ldots, m_i, \ldots, m_l$
- 将每个 $m_i$ 根据 *D* 转换为一个数字
    - 对于每个 $m_i$，$c_i = [(m_i + k) \mod 26]$
    - 根据 *D* 将每个 $c_i$ 转换为一个字母
    - 然后合并 $c_0, c_1, \ldots, c_l$ 以产生密文 $c$
- 按以下方式解密一个密文 $c$：
    - 根据 *D* 将每个 $c_i$ 转换为一个数字
    - 对于每个 $c_i$，$m_i = [(c_i - k) \mod 26]$
    - 根据 *D* 将每个 $m_i$ 转换为一个字母
    - 然后合并 $m_0, m_1, \ldots, m_l$ 以产生原始消息 $m$

移位密码中的模运算符确保了字母的循环，因此所有的密文字母都是有定义的。为了说明，考虑在单词“DOG”上应用移位密码。

假设你均匀地选择了一个键值为17。字母“O”等于15。如果没有模运算，这个明文数字加上键值将得到一个密文数字32。然而，这个密文数字不能转换成一个密文字母，因为英文字母表只有26个字母。模运算确保了密文数字实际上是6（$32 \mod 26$的结果），这等于密文字母“G”。

使用键值17加密单词“DOG”的整个过程如下：

* 消息 = DOG = D,O,G = 3,15,6
* $c_0 = [(3 + 17) \mod 26] = [(20) \mod 26] = 20 = U$
* $c_1 = [(15 + 17) \mod 26] = [(32) \mod 26] = 6 = G$
* $c_2 = [(6 + 17) \mod 26] = [(23) \mod 26] = 23 = X$
* $c = UGX$

每个人都可以直观地理解移位密码的工作原理，并可能自己使用它。然而，为了提高你对密码学的知识，开始变得更加适应形式化是很重要的，因为方案将变得更加复杂。因此，移位密码的步骤被形式化的原因。

**注释：**

[1] 我们可以使用前一节的术语准确地定义这个声明。让一个均匀变量 $K$ 有 $K$ 作为其可能的结果集。所以：

$$
Pr[K = 0] = \frac{1}{26}
$$

$$
Pr[K = 1] = \frac{1}{26}
$$

...依此类推。采样一次均匀变量 $K$ 以产生一个特定的键。

## 异或操作
<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

所有计算机数据在处理、存储和跨网络传输时都是以位的级别进行的。应用于计算机数据的任何加密方案也在位级别操作。

例如，假设你在电子邮件应用中输入了一封电子邮件。你应用的任何加密都不是直接作用于电子邮件的ASCII字符上。相反，它是应用于电子邮件中的字母和其他符号的位表示。
要理解现代密码学的一个关键数学操作，除了模运算外，还有**异或运算**（XOR operation），或称为“排他性或”运算。这个操作接受两个比特作为输入，并产生另一个比特作为输出。异或运算简称为"XOR"。如果两个比特相同则产生0，如果两个比特不同则产生1。下面可以看到四种可能性。符号$\oplus$代表"XOR"：
* $0 \oplus 0 = 0$
* $0 \oplus 1 = 1$
* $1 \oplus 0 = 1$
* $1 \oplus 1 = 0$

举例来说，假设你有一个消息$m_1$（01111001）和一个消息$m_2$（01011001）。这两个消息的异或运算如下所示。

* $m_1 \oplus m_2 = 01111001 \oplus 01011001 = 00100000$

过程很直接。你首先对$m_1$和$m_2$的最左边的比特进行异或运算。在这个例子中，就是$0 \oplus 0 = 0$。然后你对从左边数的第二对比特进行异或运算。在这个例子中，就是$1 \oplus 1 = 0$。你继续这个过程，直到你对最右边的比特进行了异或运算。

很容易看出异或运算是可交换的，即$m_1 \oplus m_2 = m_2 \oplus m_1$。此外，异或运算也是可结合的。也就是说，$(m_1 \oplus m_2) \oplus m_3 = m_1 \oplus (m_2 \oplus m_3)$。

对不同长度的字符串进行异或运算可以有不同的解释，这取决于上下文。我们在这里不关心对不同长度的字符串进行异或运算的情况。

异或运算等同于在比特加法上执行模运算的特殊情况，当除数为2时。你可以在以下结果中看到等价性：

* $(0 + 0) \mod 2 = 0 \oplus 0 = 0$
* $(1 + 0) \mod 2 = 1 \oplus 0 = 1$
* $(0 + 1) \mod 2 = 0 \oplus 1 = 1$
* $(1 + 1) \mod 2 = 1 \oplus 1 = 0$

## 伪随机性
<chapterId>20463fc5-3e92-581f-a1b7-3151279bd95e</chapterId>

在我们讨论随机和均匀变量时，我们在“随机”和“均匀”之间做了特定的区分。这种区分在实践中通常会保持，当描述随机变量时。然而，在我们当前的上下文中，这种区分需要被抛弃，“随机”和“均匀”被同义使用。我将在本节末尾解释原因。

首先，我们可以称长度为$n$的二进制字符串为**随机**（或**均匀**），如果它是通过对一个均匀变量$S$进行采样的结果，该变量给予这样长度的$n$的每个二进制字符串相同的选择概率。
假设有一个所有8位二进制字符串的集合：$\{0000\ 0000, 0000\ 0001, \ldots, 1111\ 1111\}$。（通常将8位字符串写成两个四位组，每个称为一个**nibble**。）我们将这个字符串集合称为**$S_8$**。

根据上述定义，如果一个特定的8位二进制字符串是通过均匀变量$S$的采样结果，且$S$给**$S_8$**中的每个字符串提供相同的选择概率，那么我们可以称这个二进制字符串为随机的（或均匀的）。鉴于集合**$S_8$**包含$2^8$个元素，采样时的选择概率必须为每个字符串$1/2^8$。

二进制字符串的随机性的一个关键方面是，它是根据选择它的过程来定义的。因此，任何特定二进制字符串的形式本身，无法揭示其选择中的随机性。

例如，许多人直观地认为像$1111\ 1111$这样的字符串不可能是随机选择的。但这显然是错误的。

定义一个在所有8位二进制字符串上的均匀变量$S$，从集合**$S_8$**中选择$1111\ 1111$的可能性与选择如$0111\ 0100$这样的字符串的可能性相同。因此，仅通过分析字符串本身，你无法判断一个字符串的随机性。

我们也可以谈论随机字符串，而不特指二进制字符串。例如，我们可能会谈到一个随机的十六进制字符串$AF\ 02\ 82$。在这种情况下，该字符串是从所有长度为6的十六进制字符串集合中随机选择的。这相当于随机选择一个长度为24的二进制字符串，因为每个十六进制数字代表4位。

通常，“一个随机字符串”这个表达，没有特别说明，是指从所有长度相同的字符串集合中随机选择的字符串。这就是我上面所描述的。当然，一个长度为$n$的字符串也可以从一个不同的集合中随机选择。例如，一个仅包含所有长度为$n$的字符串的子集，或者可能包含不同长度字符串的集合。然而，在这些情况下，我们不会称其为“随机字符串”，而是“从某个集合**S**中随机选择的字符串”。

在密码学中，一个关键概念是伪随机性。长度为$n$的**伪随机字符串**看起来*好像*是通过采样一个均匀变量$S$的结果，$S$给**$S_n$**中的每个字符串提供相同的选择概率。然而，实际上，该字符串是通过采样一个均匀变量$S'$的结果，$S'$仅在**$S_n$**的一个子集上定义了一个概率分布——不一定是对所有可能结果都有相同概率的分布。这里的关键点是，即使你采取了很多样本，也没有人能真正区分出来自$S$和$S'$的样本。
假设有一个随机变量 $S$。它的结果集是 **$S_{256}$**，这是所有长度为256的二进制字符串的集合。这个集合有 $2^{256}$ 个元素。每个元素被选中的概率相等，为 $1/2^{256}$，在抽样时。

此外，假设有另一个随机变量 $S'$。它的结果集只包括长度为256的 $2^{128}$ 个二进制字符串。它对这些字符串有一些概率分布，但这个分布不一定是均匀的。

假设我现在从 $S$ 和 $S'$ 中各取了1000个样本，并将两组结果给你。我会告诉你哪组结果与哪个随机变量相关。接下来，我从这两个随机变量中的一个取一个样本。但这次我不告诉你我抽样的是哪个随机变量。如果 $S'$ 是伪随机的，那么你正确猜测我抽样的随机变量的概率实际上并不比 $1/2$ 更好。

通常，长度为 $n$ 的伪随机字符串是通过随机选择一个大小为 $n – x$ 的字符串，其中 $x$ 是一个正整数，并将其作为扩展算法的输入来产生的。这个大小为 $n – x$ 的随机字符串被称为 **种子**。

伪随机字符串是使密码学实用的关键概念。例如，考虑流密码。在流密码中，一个随机选定的密钥被插入到一个扩展算法中以产生一个更大的伪随机字符串。然后，这个伪随机字符串通过 XOR 操作与明文结合，产生一个密文。

如果我们无法为流密码产生这种类型的伪随机字符串，那么我们就需要一个与消息一样长的密钥来保证其安全性。在大多数情况下，这不是一个非常实用的选项。

本节讨论的伪随机性概念可以更正式地定义。它也扩展到其他上下文。但我们不需要在这里深入讨论。对于密码学的许多内容，你真正需要直观理解的是随机字符串和伪随机字符串之间的区别。[2]

我们在讨论中不再区分“随机”和“均匀”的原因现在也应该清楚了。在实践中，每个人都使用术语伪随机来指示一个看起来**好像**是从一个均匀变量 $S$ 抽样得到的结果的字符串。严格来说，我们应该称这样的字符串为“伪均匀”，采用我们之前的语言。由于“伪均匀”这个术语既笨拙又没有人使用，我们为了清晰起见，在这里不引入它。相反，我们只是在当前上下文中不再区分“随机”和“均匀”。

**注释**

[2] 如果对这些问题的更正式的阐述感兴趣，你可以参考 Katz 和 Lindell 的 *现代密码学导论*，特别是第3章。


# 数字密码学的数学基础 2
<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>




## 什么是数论？
<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>
本章涵盖了密码学数学基础上一个更高级的主题：数论。尽管数论对对称密码学（如Rijndael Cipher）很重要，但它在公钥密码学设置中尤为重要。
如果您发现数论的细节繁琐，我建议首次阅读时进行高层次的阅读。您总是可以在以后的某个时候回来参考。

___

您可以将**数论**描述为研究整数和与整数工作的数学函数的属性的学科。

例如，考虑任意两个数$a$和$N$是**互质数**（或**相对质数**），如果它们的最大公约数等于1。现在假设一个特定的整数$N$。有多少个小于$N$的整数与$N$互质？我们能对这个问题的答案做出一般性的陈述吗？这些是数论试图回答的典型类型的问题。

现代数论依赖于抽象代数的工具。**抽象代数**领域是数学的一个子学科，其主要分析对象是被称为代数结构的抽象对象。一个**代数结构**是一组元素与一个或多个操作相结合，满足某些公理。通过代数结构，数学家可以通过抽象出它们的细节来洞察特定的数学问题。

抽象代数领域有时也被称为现代代数。您也可能会遇到**抽象数学**（或**纯数学**）的概念。这个后者术语不是指抽象代数，而是指为了数学本身而研究数学，而不仅仅是着眼于潜在的应用。

抽象代数的集合可以处理许多类型的对象，从等边三角形上的保形变换到墙纸图案。对于数论，我们只考虑包含整数或与整数工作的函数的元素集合。

## 群
<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

数学中的一个基本概念是元素的集合。集合通常由大括号表示，元素之间用逗号分隔。

例如，所有整数的集合是$\{…, -2, -1, 0, 1, 2, …\}$。这里的省略号意味着某种模式在特定方向上继续。因此，所有整数的集合也包括$3, 4, 5, 6$等，以及$-3, -4, -5, -6$等。这个所有整数的集合通常表示为$\mathbb{Z}$。

另一个集合的例子是$\mathbb{Z} \mod 11$，或所有整数模11的集合。与整个集合$\mathbb{Z}$相比，这个集合只包含有限数量的元素，即$\{0, 1, \ldots, 9, 10\}$。
一个常见的错误是认为集合 $\mathbb{Z} \mod 11$ 实际上是 $\{-10, -9, \ldots, 0, \ldots, 9, 10\}$。但根据我们之前定义的模运算方式，情况并非如此。任何通过模11运算的负整数都会被映射到 $\{0, 1, \ldots, 9, 10\}$ 上。例如，表达式 $-2 \mod 11$ 映射到 $9$，而表达式 $-27 \mod 11$ 映射到 $5$。

数学中的另一个基本概念是二元运算。这是任何接受两个元素并产生第三个元素的运算。例如，从基础算术和代数中，你会熟悉四个基本的二元运算：加法、减法、乘法和除法。

这两个基本数学概念，集合和二元运算，被用来定义群的概念，这是抽象代数中最基本的结构。

具体来说，假设某个二元运算 $\circ$。此外，假设一些元素集合 **S** 配备了该运算。这里的“配备”意味着可以在集合 **S** 中的任意两个元素之间执行运算 $\circ$。

那么，组合 $\langle \mathbf{S}, \circ \rangle$ 是一个**群**，如果它满足四个特定条件，这些条件被称为群公理。

1. 对于任何属于 $\mathbf{S}$ 的元素 $a$ 和 $b$，$a \circ b$ 也是 $\mathbf{S}$ 的元素。这被称为**封闭性条件**。
2. 对于任何属于 $\mathbf{S}$ 的元素 $a$、$b$ 和 $c$，都有 $(a \circ b) \circ c = a \circ (b \circ c)$。这被称为**结合性条件**。
3. 在 $\mathbf{S}$ 中存在一个唯一的元素 $e$，对于 $\mathbf{S}$ 中的每个元素 $a$，以下等式成立：$e \circ a = a \circ e = a$。由于只有一个这样的元素 $e$，它被称为**单位元素**。这个条件被称为**单位元条件**。
4. 对于 $\mathbf{S}$ 中的每个元素 $a$，存在一个元素 $b$ 在 $\mathbf{S}$ 中，使得以下等式成立：$a \circ b = b \circ a = e$，其中 $e$ 是单位元素。这里的元素 $b$ 被称为**逆元素**，通常表示为 $a^{-1}$。这个条件被称为**逆元条件**或**可逆性条件**。

让我们进一步探索群。用 $\mathbb{Z}$ 表示所有整数的集合。这个集合与标准加法结合，或 $\langle \mathbb{Z}, + \rangle$，显然符合群的定义，因为它满足上述四个公理。

1. 对于任何属于 $\mathbb{Z}$ 的元素 $x$ 和 $y$，$x + y$ 也是 $\mathbb{Z}$ 的元素。所以 $\langle \mathbb{Z}, + \rangle$ 满足封闭性条件。
2. 对于任何属于 $\mathbb{Z}$ 的 $x$、$y$ 和 $z$，$(x + y) + z = x + (y + z)$。因此，$\langle \mathbb{Z}, + \rangle$ 满足结合律条件。
3. 在 $\langle \mathbb{Z}, + \rangle$ 中存在一个单位元素，即 0。对于 $\mathbb{Z}$ 中的任何 $x$，都有 $0 + x = x + 0 = x$。因此，$\langle \mathbb{Z}, + \rangle$ 满足单位元条件。
4. 最后，对于 $\mathbb{Z}$ 中的每个元素 $x$，都存在一个 $y$ 使得 $x + y = y + x = 0$。例如，如果 $x$ 是 10，那么 $y$ 就是 $-10$（如果 $x$ 是 0，$y$ 也是 0）。因此，$\langle \mathbb{Z}, + \rangle$ 满足逆元条件。

重要的是，整数集合与加法构成一个群，并不意味着它与乘法也构成一个群。你可以通过测试 $\langle \mathbb{Z}, \cdot \rangle$ 是否符合四个群公理来验证这一点（其中 $\cdot$ 表示标准乘法）。

前两个公理显然成立。此外，在乘法下，元素 1 可以作为单位元。任何整数 $x$ 乘以 1，即得到 $x$。然而，$\langle \mathbb{Z}, \cdot \rangle$ 不满足逆元条件。也就是说，对于 $\mathbb{Z}$ 中的每个 $x$，并不存在一个唯一的元素 $y$ 使得 $x \cdot y = 1$。

例如，假设 $x = 22$。$\mathbb{Z}$ 集合中的哪个值 $y$ 与 $x$ 相乘会得到单位元 1？值 $1/22$ 可以，但这不在 $\mathbb{Z}$ 集合中。实际上，对于任何整数 $x$，除了 1 和 -1 的值（其中 $y$ 必须分别是 1 和 -1），都会遇到这个问题。

如果我们允许我们的集合为实数，那么我们的问题大部分都消失了。对于集合中的任何元素 $x$，乘以 $1/x$ 会得到 1。由于分数包含在实数集中，因此可以为每个实数找到逆元。零是个例外，因为任何与零的乘法都不会得到单位元 1。因此，配备乘法的非零实数集确实是一个群。

一些群满足第五个一般条件，称为**交换律条件**。该条件如下：

* 假设一个群 $G$ 有一个集合 **S** 和一个二元运算符 $\circ$。假设 $a$ 和 $b$ 是 **S** 的元素。如果对于 **S** 中的任何两个元素 $a$ 和 $b$，都有 $a \circ b = b \circ a$，那么 $G$ 满足交换律条件。
任何满足交换律条件的群被称为**交换群**，或**阿贝尔群**（以尼尔斯·亨利克·阿贝尔命名）。很容易验证，加法下的实数集合和加法下的整数集合都是阿贝尔群。乘法下的整数集合根本不是一个群，因此事实上不能成为阿贝尔群。相比之下，乘法下的非零实数集合也是一个阿贝尔群。

你应该注意两个关于符号的重要约定。首先，“+”或“×”符号经常被用来表示群运算，即使元素实际上并非数字。在这些情况下，你不应将这些符号解释为标准的算术加法或乘法。相反，它们是与这些算术运算仅有抽象相似性的操作。

除非你特指算术加法或乘法，使用$\circ$和$\diamond$等符号表示群运算更为简便，因为这些符号没有很深的文化内涵。

其次，出于与“+”和“×”经常用于表示非算术操作相同的原因，群的单位元素经常用“0”和“1”表示，即使这些群中的元素并非数字。除非你指的是带有数字的群的单位元素，使用更中性的符号如“$e$”来表示单位元素更为简便。

数学中配备了某些二元运算的许多不同且非常重要的值集合是群。然而，密码学应用仅与整数集合或至少由整数描述的元素一起工作，即在数论的领域内。因此，在密码学应用中不使用除整数之外的实数集合。

让我们通过提供一个可以“由整数描述”的元素的例子来结束，尽管它们不是整数。一个好例子是椭圆曲线上的点。尽管椭圆曲线上的任何点显然不是整数，但这样的点确实由两个整数描述。

例如，椭圆曲线对于比特币至关重要。任何标准的比特币私钥和公钥对都是从以下椭圆曲线定义的点集中选取的：

$$
x^3 + 7 = y^2 \mod 2^{256} – 2^{32} – 29 – 28 – 27 – 26 - 24 - 1
$$

（小于$2^{256}$的最大素数）。$x$-坐标是私钥，$y$-坐标是你的公钥。

比特币中的交易通常以某种方式锁定输出到一个或多个公钥。然后，可以通过使用相应的私钥制作数字签名来解锁这些交易中的价值。

## 循环群
<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

我们可以区分的一个主要区别是**有限群**和**无限群**。前者有有限数量的元素，而后者有无限数量的元素。任何有限群中的元素数量被称为**群的阶**。涉及群使用的所有实用密码学都依赖于有限（数论）群。

在公钥密码学中，一类特定的有限阿贝尔群，被称为循环群，特别重要。为了理解循环群，我们首先需要理解群元素指数运算的概念。
假设有一个群 $G$，带有群运算 $\circ$，并且 $a$ 是 $G$ 的一个元素。那么，表达式 $a^n$ 应该被解释为元素 $a$ 自身与自身结合了总共 $n - 1$ 次。例如，$a^2$ 表示 $a \circ a$，$a^3$ 表示 $a \circ a \circ a$，依此类推。（注意，这里的指数运算不一定是标准算术意义上的指数运算。）

让我们来看一个例子。假设 $G = \langle \mathbb{Z} \mod 7, + \rangle$，并且我们的 $a$ 值等于 4。在这种情况下，$a^2 = [4 + 4 \mod 7] = [8 \mod 7] = 1 \mod 7$。另外，$a^4$ 将表示 $[4 + 4 + 4 + 4 \mod 7] = [16 \mod 7] = 2 \mod 7$。

一些阿贝尔群有一个或多个元素，可以通过持续的指数运算产生所有其他群元素。这些元素被称为**生成元**或**原始元素**。

这类群的一个重要类别是 $\langle \mathbb{Z}^* \mod N, \cdot \rangle$，其中 $N$ 是一个质数。这里的符号 $\mathbb{Z}^*$ 意味着该群包含所有小于 $N$ 的非零正整数。因此，这样的群总是有 $N - 1$ 个元素。

例如，考虑 $G = \langle \mathbb{Z}^* \mod 11, \cdot \rangle$。这个群有以下元素：$\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}$。这个群的阶是 10（确实等于 $11 - 1$）。

让我们探索从这个群中指数化元素 2。计算直到 $2^{12}$ 如下所示。请注意，在等式的左侧，指数指的是群元素的指数化。在我们的特定示例中，这确实涉及到等式右侧的算术指数化（但它也可能涉及到例如加法）。为了澄清，我已经写出了重复操作，而不是等式右侧的指数形式。

* $2^1 = 2 \mod 11$
* $2^2 = 2 \cdot 2 \mod 11 = 4 \mod 11$
* $2^3 = 2 \cdot 2 \cdot 2 \mod 11 = 8 \mod 11$
* $2^4 = 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 16 \mod 11 = 5 \mod 11$
* $2^5 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 32 \mod 11 = 10 \mod 11$
* $2^6 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 64 \mod 11 = 9 \mod 11$
* $2^7 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 128 \mod 11 = 7 \mod 11$
* $2^8 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 256 \mod 11 = 3 \mod 11$
* $2^9 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 512 \mod 11 = 6 \mod 11$
* $2^{10} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 1024 \mod 11 = 1 \mod 11$
* $2^{11} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 2048 \mod 11 = 2 \mod 11$
* $2^{12} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 4096 \mod 11 = 4 \mod 11$

如果您仔细观察，可以看到对元素2进行指数运算会按照以下顺序循环通过所有$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$的元素：2, 4, 8, 5, 10, 9, 7, 3, 6, 1。在$2^{10}$之后，继续对元素2进行指数运算会再次循环通过所有元素，并且顺序相同。因此，元素2是$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$中的一个生成元。

尽管$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$有多个生成元，但并非该群的所有元素都是生成元。例如，考虑元素3。运行前10次指数运算，不展示繁琐的计算，得到以下结果：

* $3^1 = 3 \mod 11$
* $3^2 = 9 \mod 11$
* $3^3 = 5 \mod 11$
* $3^4 = 4 \mod 11$
* $3^5 = 1 \mod 11$
* $3^6 = 3 \mod 11$
* $3^7 = 9 \mod 11$
* $3^8 = 5 \mod 11$
* $3^9 = 4 \mod 11$
* $3^{10} = 1 \mod 11$
与其在 $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ 中遍历所有值，指数化元素3只会导致这些值的一个子集：3, 9, 5, 4, 和 1。经过第五次指数化后，这些值开始重复。
我们现在可以将**循环群**定义为至少有一个生成元的任何群。也就是说，至少有一个群元素，通过指数化可以产生所有其他群元素。

您可能已经在上面的例子中注意到，$2^{10}$ 和 $3^{10}$ 都等于 $1 \mod 11$。实际上，虽然我们不进行计算，但群 $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ 中任何元素的10次指数化都将产生 $1 \mod 11$。为什么会这样呢？

这是一个重要的问题，但需要一些工作来回答。

首先，假设两个正整数 $a$ 和 $N$。数论中的一个重要定理指出，$a$ 有一个模 $N$ 的乘法逆元（即，一个整数 $b$ 使得 $a \cdot b = 1 \mod N$）当且仅当 $a$ 和 $N$ 之间的最大公约数等于1。也就是说，如果 $a$ 和 $N$ 是互质的。

因此，对于任何配备了模 $N$ 乘法的整数群，只有与 $N$ 较小的互质数被包含在集合中。我们可以用 $\mathbb{Z}^c \mod N$ 表示这个集合。

例如，假设 $N$ 是10。只有整数1, 3, 7, 和 9与10互质。因此集合 $\mathbb{Z}^c \mod 10$ 只包括 $\{1, 3, 7, 9\}$。使用1到10之间的任何其他整数，您无法创建一个模10的整数乘法群。对于这个特定的群，逆元是对 1 和 9，以及 3 和 7。

在 $N$ 本身是质数的情况下，从1到 $N – 1$ 的所有整数都与 $N$ 互质。因此，这样的群的阶为 $N – 1$。使用我们之前的符号，当 $N$ 是质数时，$\mathbb{Z}^c \mod N$ 等于 $\mathbb{Z}^* \mod N$。我们之前示例中选择的群，$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$，是这类群的一个特例。

接下来，函数 $\phi(N)$ 计算直到数字 $N$ 的互质数的数量，被称为**欧拉Phi函数**。[1] 根据**欧拉定理**，每当两个整数 $a$ 和 $N$ 是互质的，以下成立：

* $a^{\phi(N)} \mod N = 1 \mod N$
这对于群 $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ 的类别具有重要的含义，其中 $N$ 是质数。对于这些群，群元素的指数运算代表算术指数运算。也就是说，$a^{\phi(N)} \mod N$ 代表算术操作 $a^{\phi(N)} \mod N$。由于这些乘法群中的任何元素 $a$ 与 $N$ 互质，这意味着 $a^{\phi(N)} \mod N = a^{N – 1} \mod N = 1 \mod N$。

欧拉定理是一个非常重要的结果。首先，它意味着所有在 $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ 中的元素通过指数运算只能循环通过一个数值，这个数值能被 $N – 1$ 整除。在 $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ 的情况下，这意味着每个元素只能循环通过 2、5 或 10 个元素。任何元素通过指数运算循环通过的群值被称为该元素的**阶**。一个元素的阶等同于群的阶的话，这个元素是一个生成元。

此外，欧拉定理意味着我们总能知道对于任何群 $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ 中的 $a^{N – 1} \mod N$ 的结果，其中 $N$ 是质数。无论实际计算有多复杂，都是如此。

例如，假设我们的群是 $\mathbb{Z}^* \mod 160,481,182$（其中 160,481,182 确实是一个质数）。我们知道所有 1 到 160,481,181 的整数必须是这个群的元素，并且 $\phi(n) = 160,481,181$。尽管我们无法完成所有计算步骤，我们知道像 $514^{160,481,181}$、$2,005^{160,481,181}$ 和 $256,212^{160,481,181}$ 这样的表达式必须都等于 $1 \mod 160,481,182$。

**注释:**

[1] 该函数如下工作。任何整数 $N$ 可以被分解为质数的乘积。假设一个特定的 $N$ 被分解如下：$p_1^{e1} \cdot p_2^{e2} \cdot \ldots \cdot p_m^{em}$，其中所有的 $p$ 都是质数，所有的 $e$ 都是大于或等于 1 的整数。那么：

$$
\phi(N) = \sum_{i=1}^m \left[p_i^{e_i} - p_i^{e_i - 1}\right]
$$

欧拉 Phi 函数公式用于 $N$ 的质因数分解。

## 领域
<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

群是抽象代数中的基本代数结构，但还有更多。你需要熟悉的唯一其他代数结构是**域**，特别是**有限域**。这种代数结构经常用于密码学，例如在高级加密标准中。后者是你在实践中会遇到的主要对称加密方案。
一个**域**是从群的概念派生出来的。具体来说，一个**域**是一组元素**S**，配备了两个二元运算符$\circ$和$\diamond$，满足以下条件：
1. 配备$\circ$的集合**S**是一个阿贝尔群。
2. 对于“非零”元素，配备$\diamond$的集合**S**是一个阿贝尔群。
3. 配备这两个运算符的集合**S**满足所谓的分配条件：假设$a$、$b$和$c$是**S**的元素。那么当$a \circ (b \diamond c) = (a \circ b) \diamond (a \circ c)$时，配备两个运算符的集合**S**满足分配属性。

注意，与群的定义一样，域的定义非常抽象。它对**S**中元素的类型或操作$\circ$和$\diamond$不做任何声明。它只是声明一个域是任何满足上述三个条件的具有两种运算的元素集合。（第二个阿贝尔群中的“零”元素可以被抽象地解释。）

那么域的一个例子可能是什么呢？一个好例子是集合$\mathbb{Z} \mod 7$，或者定义在标准加法（代替上面的$\circ$）和标准乘法（代替上面的$\diamond$）上的$\{0, 1, \ldots, 7\}$。

首先，$\mathbb{Z} \mod 7$满足作为加法阿贝尔群的条件，如果你只考虑非零元素，它也满足作为乘法阿贝尔群的条件。其次，集合与两个运算符的组合满足分配条件。

通过使用一些特定的值来探索这些声明是有教育意义的。让我们取实验值5、2和3，一些从集合$\mathbb{Z} \mod 7$中随机选取的元素，来检查域$\langle \mathbb{Z} \mod 7, +, \cdot \rangle$。我们将按顺序使用这三个值，根据需要探索特定条件。

让我们首先探索配备加法的$\mathbb{Z} \mod 7$是否是一个阿贝尔群。

1. **封闭性条件**：让我们取5和2作为我们的值。在这种情况下，$[5 + 2] \mod 7 = 7 \mod 7 = 0$。这确实是$\mathbb{Z} \mod 7$的一个元素，所以结果与封闭性条件一致。
2. **结合律条件**：让我们取5、2和3作为我们的值。在这种情况下，$[(5 + 2) + 3] \mod 7 = [5 + (2 + 3)] \mod 7 = 10 \mod 7 = 3$。这与结合律条件一致。
3. **单位元条件**：让我们取5作为我们的值。在这种情况下，$[5 + 0] \mod 7 = [0 + 5] \mod 7 = 5$。所以0看起来是加法的单位元。
4. **逆元条件**：考虑5的逆元。需要满足条件$[5 + d] \mod 7 = 0$，对某个值$d$而言。在这种情况下，满足此条件的$\mathbb{Z} \mod 7$中的唯一值是2.5。**交换律条件**：我们取5和3作为我们的值。在这种情况下，$[5 + 3] \mod 7 = [3 + 5] \mod 7 = 1$。这与交换律条件一致。

集合$\mathbb{Z} \mod 7$配备加法显然似乎是一个阿贝尔群。现在让我们探索$\mathbb{Z} \mod 7$配备乘法对所有非零元素是否为一个阿贝尔群。

1. **封闭性条件**：我们取5和2作为我们的值。在这种情况下，$[5 \cdot 2] \mod 7 = 10 \mod 7 = 3$。这也是$\mathbb{Z} \mod 7$的一个元素，因此结果与封闭性条件一致。
2. **结合律条件**：我们取5、2和3作为我们的值。在这种情况下，$[(5 \cdot 2) \cdot 3] \mod 7 = [5 \cdot (2 \cdot 3)] \mod 7 = 30 \mod 7 = 2$。这与结合律条件一致。
3. **单位元条件**：我们取5作为我们的值。在这种情况下，$[5 \cdot 1] \mod 7 = [1 \cdot 5] \mod 7 = 5$。所以1看起来是乘法的单位元。
4. **逆元条件**：考虑5的逆元。需要满足条件$[5 \cdot d] \mod 7 = 1$，对某个值$d$而言。满足此条件的$\mathbb{Z} \mod 7$中的唯一值是3。这与逆元条件一致。
5. **交换律条件**：我们取5和3作为我们的值。在这种情况下，$[5 \cdot 3] \mod 7 = [3 \cdot 5] \mod 7 = 15 \mod 7 = 1$。这与交换律条件一致。

集合$\mathbb{Z} \mod 7$显然似乎满足作为一个阿贝尔群的规则，当与加法或乘法结合使用在非零元素上时。

最后，这个集合结合了两种运算符似乎满足分配律条件。我们取5、2和3作为我们的值。我们可以看到$[5 \cdot (2 + 3)] \mod 7 = [5 \cdot 2 + 5 \cdot 3] \mod 7 = 25 \mod 7 = 4$。

我们现在已经看到$\mathbb{Z} \mod 7$配备加法和乘法满足有限域的公理，当用特定值测试时。当然，我们也可以一般性地展示，但在这里不会这样做。

一个关键区别在于两种类型的域：有限域和无限域。
一个**无限域**涉及到一个集合**S**无限大的域。配备了加法和乘法的实数集$\mathbb{R}$就是一个无限域的例子。一个**有限域**，也被称为**伽罗瓦域**，是一个集合**S**有限的域。我们上面的例子$\langle \mathbb{Z} \mod 7, +, \cdot \rangle$就是一个有限域。
在密码学中，我们主要对有限域感兴趣。通常，可以证明，如果某个元素集合**S**有$p^m$个元素，其中$p$是一个素数，$m$是一个大于或等于1的正整数，那么就存在一个有限域。换句话说，如果某个集合**S**的阶是一个素数（$p^m$，其中$m = 1$）或某个素数的幂（$p^m$，其中$m > 1$），那么你可以找到两个运算符$\circ$和$\diamond$，使得域的条件得到满足。

如果某个有限域的元素数量是一个素数，那么它被称为一个**素域**。如果有限域中的元素数量是一个素数的幂，那么这个域被称为一个**扩展域**。在密码学中，我们对素域和扩展域都感兴趣。[2]

在密码学中感兴趣的主要素域是那些所有整数集合通过某个素数调制，并且运算符是标准加法和乘法的域。这类有限域将包括$\mathbb{Z} \mod 2$、$\mathbb{Z} \mod 3$、$\mathbb{Z} \mod 5$、$\mathbb{Z} \mod 7$、$\mathbb{Z} \mod 11$、$\mathbb{Z} \mod 13$等。对于任何素域$\mathbb{Z} \mod p$，该域的整数集合如下：$\{0, 1, \ldots, p – 2, p – 1\}$。

在密码学中，我们也对扩展域感兴趣，特别是那些有$2^m$个元素的域，其中$m > 1$。这样的有限域例如在Rijndael密码中使用，它构成了高级加密标准的基础。虽然素域相对直观，但这些基于2的扩展域对于不熟悉抽象代数的人来说可能并不是那么直观。

首先，确实，任何有$2^m$个元素的整数集合都可以指定两个运算符，这将使它们的组合成为一个域（只要$m$是一个正整数）。然而，仅仅因为一个域存在，并不一定意味着它容易被发现或特别适用于某些应用。

事实证明，在密码学中特别适用的$2^m$扩展域是那些定义在特定的多项式表达式集合上的，而不是某些整数集合。

例如，假设我们想要一个有$2^3$（即，8）个元素的扩展域。虽然可能有许多不同的集合可以用于那种大小的域，但其中一个集合包括所有形式为$a_2x^2 + a_1x + a_0$的唯一多项式，其中每个系数$a_i$要么是0要么是1。因此，这个集合**S**包括以下元素：
1. $0$: 当 $a_2 = 0$、$a_1 = 0$ 且 $a_0 = 0$ 的情况。
2. $1$: 当 $a_2 = 0$、$a_1 = 0$ 且 $a_0 = 1$ 的情况。
3. $x$: 当 $a_2 = 0$、$a_1 = 1$ 且 $a_0 = 0$ 的情况。
4. $x + 1$: 当 $a_2 = 0$、$a_1 = 1$ 且 $a_0 = 1$ 的情况。
5. $x^2$: 当 $a_2 = 1$、$a_1 = 0$ 且 $a_0 = 0$ 的情况。
6. $x^2 + 1$: 当 $a_2 = 1$、$a_1 = 0$ 且 $a_0 = 1$ 的情况。
7. $x^2 + x$: 当 $a_2 = 1$、$a_1 = 1$ 且 $a_0 = 0$ 的情况。
8. $x^2 + x + 1$: 当 $a_2 = 1$、$a_1 = 1$ 且 $a_0 = 1$ 的情况。

因此 **S** 将是集合 $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$。可以定义哪两种操作在这组元素上以确保它们的组合是一个域？

集合 **S** 上的第一种操作 ($\circ$) 可以定义为标准的多项式加法模 2。你所要做的就是像平常一样加多项式，然后对结果多项式的每个系数应用模 2。这里有一些例子：

* $[(x^2) + (x^2 + x + 1)] \mod 2 = [2x^2 + x + 1] \mod 2 = x + 1$
* $[(x^2 + x) + (x)] \mod 2 = [x^2 + 2x] \mod 2 = x^2$
* $[(x + 1) + (x^2 + x + 1)] \mod 2 = [x^2 + 2x + 2] \mod 2 = x^2 + 1$

集合 **S** 上需要创建域的第二种操作 ($\diamond$) 更为复杂。它是一种乘法，但不是算术中的标准乘法。相反，你需要将每个元素视为一个向量，并理解该操作为这两个向量模一个不可约多项式的乘法。

首先让我们来看看不可约多项式的概念。**不可约多项式**是指不能被分解的多项式（就像质数不能被分解成除了 1 和质数本身之外的组成部分）。就我们的目的而言，我们对那些相对于所有整数集不可约的多项式感兴趣。（注意，你可能能够通过例如实数或复数来分解某些多项式，即使你不能使用整数来分解它们。）
例如，考虑多项式 $x^2 - 3x + 2$。这可以重写为 $(x – 1)(x – 2)$。因此，这不是不可约的。现在考虑多项式 $x^2 + 1$。仅使用整数，没有办法进一步分解这个表达式。因此，这是一个关于整数的不可约多项式。

接下来，让我们转向向量乘法的概念。我们不会深入探讨这个话题，但你只需要理解一个基本规则：任何向量除法都可以进行，只要被除数的度数高于或等于除数的度数。如果被除数的度数低于除数的度数，那么被除数就不能再被除数除了。

例如，考虑表达式 $x^6 + x + 1 \mod x^5 + x^2$。这显然可以进一步简化，因为被除数的度数，6，高于除数的度数，5。现在考虑表达式 $x^5 + x + 1 \mod x^5 + x^2$。这也可以进一步简化，因为被除数的度数，5，和除数的度数，5，是相等的。

然而，现在考虑表达式 $x^4 + x + 1 \mod x^5 + x^2$。这不会进一步简化，因为被除数的度数，4，低于除数的度数，5。

基于这些信息，我们现在准备找到集合 $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$ 的第二个运算。

我已经说过，第二个运算应该被理解为某个不可约多项式模下的向量乘法。这个不可约多项式应该确保第二个运算在 **S** 上定义了一个阿贝尔群，并且与分配条件一致。那么这个不可约多项式应该是什么呢？

由于集合中的所有向量的度数都是2或更低，不可约多项式应该是3度的。如果集合中两个向量的任何乘法产生了3度或更高度的多项式，我们知道模3度的多项式总是产生2度或更低度的多项式。这是因为任何3度或更高度的多项式总是可以被3度的多项式除尽。此外，作为除数的多项式必须是不可约的。

事实证明，有几个3度的不可约多项式我们可以用作我们的除数。这些多项式中的每一个与我们的集合 **S** 以及模2加法结合定义了一个不同的域。这意味着当在密码学中使用扩展域 $2^m$ 时，你有多个选项。

以我们的例子为例，假设我们选择多项式 $x^3 + x + 1$。这确实是不可约的，因为你不能使用整数来分解它。此外，它将确保任何两个元素的乘法都会产生2度或更低度的多项式。
让我们通过一个例子来演示第二种操作，使用多项式 $x^3 + x + 1$ 作为除数来说明它是如何工作的。假设你将元素 $x^2 + 1$ 与 $x^2 + x$ 在我们的集合 **S** 中相乘。然后，我们需要计算表达式 $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1$。这可以简化如下：
* $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1 =$
* $[x^2 \cdot x^2 + x^2 \cdot x + 1 \cdot x^2 + 1 \cdot x] \mod x^3 + x + 1 =$
* $[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$

我们知道 $[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$ 可以被简化，因为被除数的度数（4）高于除数的度数（3）。

首先，你可以看到表达式 $x^3 + x + 1$ 进入 $x^4 + x^3 + x^2 + x$ 总共 $x$ 次。你可以通过将 $x^3 + x + 1$ 乘以 $x$ 来验证这一点，即 $x^4 + x^2 + x$。由于后者项的度数与被除数相同，即 4，我们知道这是可行的。你可以如下计算这次除法的余数：

* $[(x^4 + x^3 + x^2 + x) - (x^4 + x^2 + x)] \mod x^3 + x + 1 =$
* $[x^3] \mod x^3 + x + 1 =$
* $x^3$

所以在将 $x^4 + x^3 + x^2 + x$ 除以 $x^3 + x + 1$ 总共 $x$ 次后，我们得到一个余数 $x^3$。这个余数还能进一步被 $x^3 + x + 1$ 除吗？

直觉上，可能会认为 $x^3$ 不能再被 $x^3 + x + 1$ 除，因为后者项看起来更大。然而，记住我们之前关于向量除法的讨论。只要被除数的度数大于或等于除数的度数，表达式就可以进一步简化。具体来说，表达式 $x^3 + x + 1$ 可以准确地进入 $x^3$ 一次。余数如下计算：

$$
[(x^3) - (x^3 + x + 1)] \mod x^3 + x + 1 = [x + 1] \mod x^3 + x + 1 = x + 1
$$

你可能想知道为什么 $(x^3) - (x^3 + x + 1)$ 的计算结果是 $x + 1$ 而不是 $-x - 1$。记住，我们的字段的第一操作是定义为模 2。因此，两个向量的减法产生的结果与两个向量的加法完全相同。
总结一下$x^2 + 1$和$x^2 + x$的乘法：当你将这两个项相乘时，你会得到一个四次多项式$x^4 + x^3 + x^2 + x$，这需要对$x^3 + x + 1$进行模约简。这个四次多项式可以被$x^3 + x + 1$整除恰好$x + 1$次。将$x^4 + x^3 + x^2 + x$除以$x^3 + x + 1$恰好$x + 1$次后的余数是$x + 1$。这确实是我们集合$\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$中的一个元素。

为什么像上面例子中的基于多项式集合的二进制扩展域对密码学有用呢？原因是你可以将这些集合中的多项式的系数，不是0就是1，视为具有特定长度的二进制字符串的元素。例如，我们上面的例子中的集合**S**，可以被视为包含所有长度为3的二进制字符串的集合**S**（从000到111）。然后，对**S**的操作，也可以用来对这些二进制字符串执行操作并产生相同长度的二进制字符串。

**注释：**

[2] 扩展域变得非常反直觉。它们不是有整数元素，而是有多项式集合。此外，任何操作都是对某个不可约多项式进行模运算。

## 实践中的抽象代数
<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>

尽管讨论的语言正式且抽象，但群的概念不应该太难以理解。它只是一组元素以及一个二元运算，其中对这些元素执行该二元运算满足四个一般条件。阿贝尔群只是多了一个称为交换律的额外条件。循环群，反过来，是一种特殊的阿贝尔群，即有一个生成元的群。域仅仅是从基本群概念中派生出的更复杂的结构。

但如果你是一个实际倾向的人，你可能会在这一点上想知道：谁在乎呢？知道一些元素和操作符集合是一个群，甚至是一个阿贝尔群或循环群，有什么现实世界的相关性吗？知道某些东西是一个域有什么用？

不深入细节，答案是“是的”。群首次在19世纪由法国数学家埃瓦里斯特·伽罗瓦创建。他使用它们来得出关于解决高于五次的多项式方程的结论。

从那时起，群的概念帮助解决了数学和其他领域的许多问题。例如，物理学家穆雷-盖尔曼能够在实验中实际观察到一个粒子之前预测其存在。[3] 另一个例子，化学家使用群论来分类分子的形状。数学家甚至使用群的概念得出关于像墙纸这样具体的东西的结论！
本质上，展示一组元素与某些运算符构成群，意味着你所描述的具有特定的对称性。这里的对称性不是常见意义上的对称，而是一种更抽象的形式。这可以为特定系统和问题提供重要的洞见。抽象代数中更复杂的概念只是给我们提供了额外的信息。
最重要的是，通过它们在密码学中的应用，尤其是公钥密码学中的应用，你将看到数论群和域的重要性。例如，在我们讨论域的时候，我们已经看到了扩展域是如何在Rijndael密码中被使用的。我们将在*第5章*中详细讨论这个例子。

关于抽象代数的进一步讨论，我推荐Socratica的抽象代数优秀视频系列。[4] 我特别推荐以下视频：“什么是抽象代数？”，“群定义（扩展）”，“环定义（扩展）”，和“域定义（扩展）”。这四个视频将为你提供对上述讨论的一些额外洞见。（我们没有讨论环，但域只是一种特殊类型的环。）

关于现代数论的进一步讨论，你可以查阅许多关于密码学的高级讨论。我会建议Jonathan Katz和Yehuda Lindell的《现代密码学导论》或Christof Paar和Jan Pelzl的《理解密码学》进行进一步的讨论。[5]

**注释：**

[3] 见 [YouTube视频](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be)

[4] Socratica, [抽象代数](https://www.socratica.com/subject/abstract-algebra)

[5] Katz和Lindell, *现代密码学导论*，第2版，2015年（CRC出版社：佛罗里达州博卡拉顿）。Paar和Pelzl, *理解密码学*，2010年（施普林格-维拉格：柏林）。

# 对称密码学
<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

## Alice和Bob
<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

密码学的两个主要分支之一是对称密码学。它包括加密方案以及与认证和完整性有关的方案。直到1970年代，所有的密码学都会包括对称加密方案。

主要讨论从查看对称加密方案开始，并在流密码和块密码之间做出关键区分。然后，我们转向消息认证码，这是确保消息完整性和真实性的方案。最后，我们探讨如何将对称加密方案和消息认证码结合起来，以确保安全通信。

本章顺便讨论了各种实践中的对称密码学方案。下一章将提供使用实践中的流密码和块密码进行加密的详细阐述，分别是RC4和AES。

在开始我们对对称密码学的讨论之前，我想简要地对本章及后续章节中的Alice和Bob插图做一些说明。

___

在阐述密码学原理时，人们常常依赖于涉及Alice和Bob的例子。我也将这样做。

特别是如果你是密码学的新手，重要的是要意识到，这些Alice和Bob的例子只是为了在简化的环境中说明密码学原理和构造。然而，这些原理和构造适用于更广泛的现实生活情境。
以下是关于密码学中涉及Alice和Bob的例子需要记住的五个关键点：
1. 它们可以轻松地转换为涉及其他类型参与者的例子，如公司或政府组织。
2. 它们可以轻松扩展到包括三个或更多参与者。
3. 在这些例子中，Bob和Alice通常是创建每条消息并在该消息上应用加密方案的积极参与者。但实际上，电子通信大多是自动化的。例如，当你使用传输层安全协议访问网站时，加密通常完全由你的计算机和Web服务器处理。
4. 在电子通信的背景下，通过通信渠道发送的“消息”通常是TCP/IP数据包。这些可以属于电子邮件、Facebook消息、电话对话、文件传输、网站、软件上传等。它们并不是传统意义上的消息。尽管如此，密码学家通常会简化这一现实，比如说消息就是一封电子邮件。
5. 这些例子通常关注电子通信，但它们也可以扩展到传统的通信形式，如信件。

## 对称加密方案
<chapterId>41bfdbe1-6d41-5272-98bb-81f24b2fd6af</chapterId>

我们可以宽泛地定义**对称加密方案**为任何带有三种算法的加密方案：

1. **密钥生成算法**，生成一个私钥。
2. **加密算法**，以私钥和明文作为输入，输出一个密文。
3. **解密算法**，以私钥和密文作为输入，输出原始明文。

通常，无论是对称还是非对称加密方案，都提供了一个基于核心算法的加密模板，而不是确切的规范。

例如，考虑Salsa20，一种对称加密方案。它可以使用128位和256位的密钥长度。关于密钥长度的选择影响算法的一些细节（确切地说是算法中的轮数）。

但人们不会说，使用128位密钥的Salsa20与使用256位密钥的Salsa20是不同的加密方案。核心算法保持不变。只有当核心算法改变时，我们才真正谈论两种不同的加密方案。

对称加密方案通常在两种情况下特别有用：（1）两个或多个代理在远距离通信并希望保密他们通信内容的情况；以及（2）一个代理希望随时间保密消息内容的情况。

你可以在下面的*图1*中看到情况（1）的描述。Bob想要跨越一定距离发送消息$M$给Alice，但不希望其他人能够阅读该消息。

Bob首先使用私钥$K$加密消息$M$。然后，他将密文$C$发送给Alice。一旦Alice收到密文，她就可以使用密钥$K$解密并阅读明文。有了一个好的加密方案，任何截获密文$C$的攻击者都不应该能够了解到关于消息$M$的任何实质性信息。

你可以在下面的*图2*中看到情况（2）的描述。Bob想要阻止其他人查看某些信息。一个典型的情况可能是Bob是一名员工，他在自己的计算机上存储敏感数据，这些数据不应该被外人或同事阅读。
鲍勃在时间$T_0$使用密钥$K$加密消息$M$，生成密文$C$。在时间$T_1$，他需要再次获取该消息，并使用密钥$K$解密密文$C$。与此同时，任何可能偶然发现密文$C$的攻击者都不应该能够从中推断出关于$M$的任何重要信息。

*图1：空间上的保密性*

![图1：空间上的保密性](assets/Figure4-1.webp "图1：空间上的保密性")

*图2：时间上的保密性*

![图2：时间上的保密性](assets/Figure4-2.webp "图2：时间上的保密性")

## 一个例子：移位密码
<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

在第2章中，我们遇到了移位密码，这是一个非常简单的对称加密方案的例子。让我们在这里再次审视它。

假设有一个字典*D*，它将英文字母表中的所有字母按顺序与一组数字$\{0,1,2,\dots,25\}$等同起来。假设有一组可能的消息**M**。那么，移位密码是这样定义的加密方案：

- 从可能的密钥集合**K**中随机选择一个密钥$k$，其中**K** = $\{0,1,2,\dots,25\}$
- 按如下方式加密消息$m \in$ **M**：
    - 将$m$分解为其各个字母$m_0, m_1,\dots, m_i, \dots, m_l$
    - 根据*D*将每个$m_i$转换为一个数字
    - 对于每个$m_i$，$c_i = [(m_i + k) \mod 26]$
    - 根据*D*将每个$c_i$转换为一个字母
    - 然后组合$c_0, c_1,\dots, c_l$以产生密文$c$
- 按如下方式解密一个密文$c$：
    - 根据*D*将每个$c_i$转换为一个数字
    - 对于每个$c_i$，$m_i = [(c_i - k) \mod 26]$
    - 根据*D*将每个$m_i$转换为一个字母
    - 然后组合$m_0, m_1,\dots, m_l$以产生原始消息$m$

移位密码是对称加密方案的一个例子，因为加密和解密过程使用的是同一个密钥。例如，假设你想使用移位密码加密消息“DOG”，并且你随机选择了"24"作为密钥。使用这个密钥加密消息将产生“BME”。检索原始消息的唯一方法是在解密过程中使用相同的密钥"24"。

这种移位密码是**单字母替换密码**的一个例子：一个加密方案，其中密文字母表是固定的（即，只使用一个字母表）。假设解密算法是确定性的，那么替换密文中的每个符号最多只能对应明文中的一个符号。
直到18世纪，许多加密应用严重依赖于单字母替换密码，尽管这些密码往往比移位密码要复杂得多。例如，你可以从字母表中随机选择一个字母来代替原文中的每个字母，但约束条件是密文字母表中每个字母只能出现一次。这意味着你将拥有26的阶乘种可能的私钥，这在计算机时代之前是巨大的。

请注意，在密码学中你会频繁遇到**密码（cipher）**这个术语。要知道这个术语有多种含义。实际上，我至少知道在密码学中这个术语有五种不同的含义。

在某些情况下，它指的是加密方案，就像在移位密码和单字母替换密码中一样。然而，这个术语也可以特指加密算法、私钥，或任何此类加密方案的密文。

最后，密码（cipher）这个术语还可以指一种核心算法，你可以从中构建加密方案。这些可以包括各种加密算法，但也包括其他类型的加密方案。在区块密码（请参见下面的“区块密码”部分）的上下文中，这种意义变得相关。

你还可能遇到**加密（encipher）**或**解密（decipher）**这些术语。这些术语仅仅是加密和解密的同义词。

## 暴力攻击和克克霍夫原则
<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

移位密码是一个非常不安全的对称加密方案，至少在现代世界是这样。[1] 攻击者可以尝试用所有26个可能的密钥对任何密文进行解密，看哪个结果有意义。这种攻击方式，即攻击者只是循环尝试密钥以查看哪个有效，被称为**暴力攻击**或**穷尽密钥搜索**。

任何加密方案要满足最基本的安全概念，必须拥有一个可能的密钥集，或**密钥空间**，其大小足以使暴力攻击变得不可行。所有现代加密方案都满足这一标准。这被称为**足够密钥空间原则**。在不同类型的加密方案中通常也适用类似的原则。

为了感受现代加密方案中巨大的密钥空间大小，假设一个文件已经使用高级加密标准的128位密钥进行了加密。这意味着攻击者需要循环穿过$2^{128}$个密钥来进行暴力攻击。要以0.78%的成功率实现这种策略，攻击者需要循环穿过大约$2.65 \times 10^{36}$个密钥。

假设我们乐观地假设攻击者每秒可以尝试$10^{16}$个密钥（即，每秒10万亿个密钥）。要测试密钥空间中0.78%的所有密钥，她的攻击必须持续$2.65 \times 10^{20}$秒。这大约是8.4万亿年。所以，即使是一个异常强大的对手进行暴力攻击，在现代128位加密方案中也是不现实的。这就是足够密钥空间原则的作用。

如果攻击者不知道加密算法，移位密码是否更安全？也许是，但提升不大。
无论如何，现代密码学总是假设任何对称加密方案的安全性仅依赖于保持私钥的秘密。攻击者总是假定知道所有其他细节，包括消息空间、密钥空间、密文空间、密钥选择算法、加密算法和解密算法。
认为对称加密方案的安全性仅依赖于私钥的保密性，这一想法被称为**克克霍夫原则**（Kerckhoffs’ principle）。

正如克克霍夫最初的意图，该原则仅适用于对称加密方案。然而，一个更通用的版本的原则，也适用于所有其他现代类型的密码学方案：任何密码学方案的设计不需要保密，以确保其安全；保密性只能延伸到某些信息串，通常是一个私钥。

克克霍夫原则之所以对现代密码学至关重要，有四个原因。首先，对于特定类型的应用，只有有限数量的密码学方案。例如，大多数现代对称加密应用使用Rijndael密码。因此，关于方案设计的保密性非常有限。然而，在保持Rijndael密码的某个私钥的保密性方面，有更多的灵活性。

其次，替换信息串比替换整个密码学方案更容易。假设一家公司的所有员工都使用相同的加密软件，并且每两个员工都有一个私钥来保密通信。在这种情况下，密钥泄露是一个麻烦，但至少公司可以保留这样的安全漏洞软件。如果公司依赖于方案的保密性，那么任何保密性的泄露都将需要替换所有软件。

第三，克克霍夫原则允许密码学方案之间的标准化和兼容性。这对效率有巨大的好处。例如，很难想象如果安全性需要保持密码学方案的秘密，每天有数百万人如何能安全地连接到谷歌的网络服务器。

第四，克克霍夫原则允许对密码学方案进行公开审查。这种类型的审查对于实现安全的密码学方案绝对必要。例如，对称密码学中的主要核心算法，Rijndael密码，是由国家标准与技术研究院在1997年到2000年间组织的一场竞赛的结果。

任何试图通过**安全性模糊性**（security by obscurity）来实现安全的系统，都是依赖于保持其设计和/或实现细节的秘密。在密码学中，这将是特别依赖于保持密码学方案的设计细节秘密的系统。因此，安全性模糊性与克克霍夫原则形成了直接对比。

开放性提高质量和安全性的能力也更广泛地扩展到了数字世界，而不仅仅是密码学。例如，自由和开源的Linux发行版，如Debian，通常在隐私、稳定性、安全性和灵活性方面比其Windows和MacOS对应版本有几个优势。虽然这可能有多种原因，但最重要的原则可能是，正如Eric Raymond在他著名的论文《大教堂与集市》中所说的那样，“只要有足够多的眼睛，所有的错误都是显而易见的。”这种群体智慧类型的原则给了Linux其最显著的成功。
我们永远不能明确无误地说一个加密方案是“安全的”或“不安全的”。相反，对于加密方案有各种各样的安全概念。每一个**加密安全的定义**都必须指定（1）安全目标，以及（2）攻击者的能力。针对一个或多个特定的安全概念分析加密方案，可以提供对其应用和限制的见解。虽然我们不会深入探讨各种加密安全概念的所有细节，但你应该知道，对于对称和非对称方案（以及某种形式的其他加密原语）所有现代加密安全概念都普遍存在两个假设：

* 攻击者对方案的了解符合克科霍夫原则。
* 攻击者不能可行地对方案进行暴力攻击。具体来说，加密安全概念的威胁模型通常甚至不允许暴力攻击，因为它们假设这些不是一个相关的考虑因素。

**注释：**

[1] 根据塞乌托尼乌斯的说法，朱利叶斯·凯撒在他的军事通信中使用了一个密钥值恒定为3的移位密码。所以A总是变成D，B总是变成E，C总是变成F，等等。这个特定版本的移位密码因此被称为**凯撒密码**（尽管它在现代词汇的意义上并不真正是一个密码，因为密钥值是恒定的）。如果罗马的敌人对加密非常不熟悉，凯撒密码在公元前一世纪可能是安全的。但在现代，它显然不会是一个非常安全的方案。

[2] Jonathan Katz 和 Yehuda Lindell，《现代密码学导论》，CRC 出版社（佛罗里达州博卡拉顿：2015年），第7页及以后。

[3] Eric Raymond，“大教堂与集市”，论文在德国维尔茨堡的Linux Kongress上发表（1997年5月27日）。有许多后续版本可用，以及一本书。我的引用来自书中的第30页：Eric Raymond，《大教堂与集市：一个偶然的革命者对Linux和开源的沉思》，修订版（2001年），O’Reilly：加利福尼亚州塞巴斯托波尔。

## 流密码
<chapterId>479aa6f4-45c4-59ca-8616-8cf8e61fc871</chapterId>

对称加密方案通常分为两种类型：**流密码**和**块密码**。然而，这种区分有些麻烦，因为人们对这些术语的使用并不一致。在接下来的几节中，我将按照我认为最好的方式阐述这种区别。不过，你应该知道，许多人对这些术语的使用与我所阐述的有所不同。

首先让我们来看看流密码。**流密码**是一种对称加密方案，加密包括两个步骤。

首先，通过私钥产生一个与明文长度相同的字符串。这个字符串被称为**密钥流**。

接下来，密钥流与明文通过数学方式结合产生密文。这种组合通常是一个XOR操作。对于解密，你可以简单地反向操作。（注意，$A \oplus B = B \oplus A$，在$A$和$B$是位字符串的情况下。所以在流密码中XOR操作的顺序对结果没有影响。这个属性被称为**交换律**。）
一个典型的XOR流密码器如*图3*所示。首先，你需要取一个私钥$K$并使用它来生成一个密钥流。然后，通过XOR操作将密钥流与明文结合，以产生密文。任何收到密文的代理如果拥有密钥$K$，就可以轻松解密。她所需要做的就是根据方案指定的程序创建一个与密文一样长的密钥流，并将其与密文进行XOR操作。

*图3：一个XOR流密码器*

![图3：一个XOR流密码器](assets/Figure4-3.webp "图3：一个XOR流密码器")

请记住，加密方案通常是一个加密模板，具有相同的核心算法，而不是一个确切的规范。相应地，流密码通常是一个加密模板，在其中你可以使用不同长度的密钥。尽管密钥长度可以影响方案的一些细节，但不会影响其基本形式。

移位密码是一个非常简单且不安全的流密码示例。使用单个字母（私钥），你可以产生一串与消息长度相同的字母（密钥流）。然后，通过模运算将这个密钥流与明文结合，以产生密文。（当用比特表示字母时，这个模运算可以简化为XOR操作）。

另一个著名的流密码示例是**维吉尼亚密码**，以16世纪末完全发展它的布莱斯·德·维吉尼亚命名（尽管其他人之前已经做了很多工作）。它是**多表替代密码**的一个示例：一个加密方案，其中明文符号的密文字母表根据其在文本中的位置而变化。与单表替代密码相比，密文符号可以与多个明文符号相关联。

随着加密在文艺复兴时期欧洲的普及，**密码分析**——即破解密文——特别是使用**频率分析**，也变得流行。后者利用我们语言中的统计规律来破解密文，早在九世纪就被阿拉伯学者发现。这是一种特别适用于较长文本的技术。即使是最复杂的单表替代密码，到了18世纪的欧洲，特别是在军事和安全设置中，也不再能抵抗频率分析。由于维吉尼亚密码在安全性上提供了显著的进步，它在这一时期变得流行，并在18世纪晚期广为流传。

非正式地讲，加密方案的工作原理如下：

1. 选择一个多字母单词作为私钥。
2. 对任何消息，使用密钥词中对应的字母作为移位，对消息的每个字母应用移位密码。
3. 如果你已经循环使用了密钥词，但还没有完全加密明文，再次将密钥词的字母作为移位密码应用于文本剩余部分中对应的字母。
4. 继续这个过程，直到整个消息都被加密。

举例来说，假设你的私钥是"GOLD"，你想加密消息"CRYPTOGRAPHY"。在这种情况下，你将根据维吉尼亚密码按如下方式进行：

- $c_0  = [(2 + 6) \mod 26] = 8 = I$
- $c_1  = [(17 + 14) \mod 26] = 5 = F$
- $c_2  = [(24 + 11) \mod 26] = 9 = J$
- $c_3 = [(15 + 3) \mod 26] = 18 = S$
- $c_4 = [(19 + 6) \mod 26] = 25 = Z$
- $c_5 = [(14 + 14) \mod 26] = 2 = C$
- $c_6 = [(6 + 11) \mod 26] = 17 = R$
- $c_7 = [(17 + 3) \mod 26] = 20 = U$
- $c_8 = [(0 + 6) \mod 26] = 6 = G$
- $c_9 = [(15 + 14) \mod 26] = 3 = D$
- $c_{10} = [(7 + 11) \mod 26] = 18 = S$
- $c_{11} = [(24 + 3) \mod 26] = 1 = B$

因此，密文 $c$ = "IFJSZCRUGDSB"。

另一个著名的流密码例子是**一次性密码本**。使用一次性密码本时，你只需创建一个与明文消息等长的随机比特串，并通过XOR操作产生密文。因此，私钥和密钥流在一次性密码本中是等价的。

尽管在现代，移位密码和维吉尼亚密码非常不安全，但如果正确使用，一次性密码本非常安全。可能直到1980年代，一次性密码本最著名的应用是用于**华盛顿-莫斯科热线**。

热线是华盛顿和莫斯科之间用于紧急事务的直接通信链接，安装于古巴导弹危机后。这项技术多年来已经发生了变化。目前，它包括一条直接的光纤电缆以及两个卫星链接（为了冗余），这使得电子邮件和文本消息成为可能。链接在美国的多个地方结束。五角大楼、白宫和乌鸦岩山是已知的终点。与流行观点相反，热线从未涉及电话。

一次性密码本方案的本质如下。华盛顿和莫斯科将拥有两套随机数字。一套由俄罗斯人创建的随机数字，用于任何俄语消息的加密和解密。一套由美国人创建的随机数字，用于任何英语消息的加密和解密。不时地，更多的随机数字会通过可信的快递员送达对方。

通过使用这些随机数字创建一次性密码本，华盛顿和莫斯科能够秘密通信。每次你需要通信时，你将使用随机数字的下一部分来传递你的消息。

虽然高度安全，一次性密码本面临着重大的实际限制：密钥需要与消息一样长，且一次性密码本的任何部分都不能重复使用。这意味着你需要跟踪你在一次性密码本中的位置，存储大量的比特，并不时地与你的对手交换随机比特。因此，一次性密码本在实践中并不经常使用。

相反，实践中常用的流密码是**伪随机流密码**。Salsa20及其密切相关的变体ChaCha是常用的伪随机流密码示例。
在这些伪随机流密码中，您首先随机选择一个密钥$K$，其长度短于明文的长度。这样的随机密钥$K$通常是由我们的计算机基于它随时间收集的不可预测数据创建的，例如网络消息之间的时间、鼠标移动等等。
然后，这个随机密钥$K$被插入到一个扩展算法中，该算法创建一个与消息一样长的伪随机密钥流。您可以精确指定密钥流需要多长（例如，500位、1000位、1200位、29,117位等等）。

伪随机密钥流看起来*仿佛*是从与其长度相同的所有字符串集合中完全随机选择的。因此，使用伪随机密钥流进行加密看起来就像是使用了一次性密码本进行加密。但实际上当然不是这样。

由于我们的私钥比密钥流短，而我们的扩展算法需要是确定性的，以便加密/解密过程能够工作，所以并非所有特定长度的密钥流都可能作为我们的扩展操作的输出结果。

假设，例如，我们的私钥长度为128位，我们可以将其插入到一个扩展算法中以创建一个更长的密钥流，比如说2500位。由于我们的扩展算法需要是确定性的，我们的算法最多只能选择$1/2^{128}$个长度为2500位的字符串。所以这样的密钥流永远不可能完全随机地从相同长度的所有字符串中选择。

我们对流密码的定义有两个方面：（1）利用私钥生成与明文一样长的密钥流；（2）这个密钥流通过典型的XOR操作与明文结合，产生密文。

有时人们更严格地定义条件（1），断言密钥流必须特别是伪随机的。这意味着移位密码和一次性密码本将不被视为流密码。

在我看来，更广泛地定义条件（1）提供了组织加密方案的更简单方式。此外，这意味着我们不必因为我们了解到某个特定的加密方案实际上并不依赖于伪随机密钥流，就停止称其为流密码。

**注释：**

[4] Crypto Museum, "华盛顿-莫斯科热线," 2013, 可在[https://www.cryptomuseum.com/crypto/hotline/index.htm](https://www.cryptomuseum.com/crypto/hotline/index.htm)查看。

## 块密码
<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

块密码通常被理解的第一种方式是作为比流密码更原始的东西：一个核心算法，它在适当长度的字符串上执行保持长度不变的转换，辅以密钥。这个算法可以用于创建加密方案和可能的其他类型的密码学方案。
通常，分组密码可以处理不同长度的输入字符串，如64、128或256位，以及不同长度的密钥，如128、192或256位。尽管算法的某些细节可能会因这些变量而改变，但核心算法不会改变。如果改变了，我们就会说这是两种不同的分组密码。请注意，这里使用的核心算法术语与加密方案的用法相同。
下面的*图4*展示了分组密码的工作方式。长度为$L$的消息$M$和密钥$K$作为分组密码的输入。它输出一个长度为$L$的消息$M'$。对于大多数分组密码而言，密钥的长度不必与$M$和$M'$的长度相同。

*图4：一个分组密码*

![图4：一个分组密码](assets/Figure4-4.webp "图4：一个分组密码")

分组密码本身不是一个加密方案。但是，分组密码可以与各种**操作模式**一起使用，以产生不同的加密方案。操作模式仅仅在分组密码之外添加一些额外的操作。

为了说明这是如何工作的，假设一个分组密码（BC），它需要一个128位的输入字符串和一个128位的私钥。下面的图5展示了这个分组密码如何与**电子密码本模式**（**ECB模式**）一起使用来创建一个加密方案。（右侧的省略号表示你可以根据需要重复这个模式）。

*图5：一个带有ECB模式的分组密码*

![图5：一个带有ECB模式的分组密码](assets/Figure4-5.webp "图5：一个带有ECB模式的分组密码")

使用分组密码进行电子密码本加密的过程如下。看看你是否可以将你的明文消息分割成128位的块。如果不行，向消息添加**填充**，以便结果可以被128位的块大小均匀分割。这是你用于加密过程的数据。

现在将数据分割成128位字符串的块（$M_1$、$M_2$、$M_3$等等）。通过分组密码运行每个128位字符串和你的128位密钥，以产生128位的密文块（$C_1$、$C_2$、$C_3$等等）。这些块重新组合后，形成完整的密文。

解密只是反向过程，尽管接收者确实需要某种可识别的方式来去除解密数据中的任何填充，以产生原始的明文消息。

尽管相对简单，但带有电子密码本模式的分组密码缺乏安全性。这是因为它导致了**确定性加密**。任何两个相同的128位数据字符串都以完全相同的方式加密。这些信息可以被利用。

相反，从分组密码构建的任何加密方案都应该是**概率性的**：也就是说，任何消息$M$的加密，或$M$的任何特定块，通常应该每次产生不同的结果。[5]

**密码块链接模式**（**CBC模式**）可能是与分组密码一起使用最常见的模式。如果正确完成，组合将产生一个概率性加密方案。你可以在下面的*图6*中看到这种操作模式的描述。

*图6：一个带有CBC模式的分组密码*
![Figure 6: 带有CBC模式的块密码](assets/Figure4-6.webp "图6：带有CBC模式的块密码")
假设块大小再次为128位。因此，首先，您需要确保您的原始明文消息接收到必要的填充。

然后，您将您的明文的第一个128位部分与一个128位的**初始化向量**进行异或（XOR）运算。结果放入块密码中，以产生第一个块的密文。对于第二个128位的块，您首先将明文与第一个块的密文进行异或运算，然后再将其插入块密码。您继续这个过程，直到加密了整个明文消息。

完成后，您将加密消息连同未加密的初始化向量一起发送给接收者。接收者需要知道初始化向量，否则她无法解密密文。

当正确使用时，这种构造比电子密码本模式更安全。首先，您应确保初始化向量是一个随机或伪随机字符串。此外，您应该每次使用这种加密方案时都使用不同的初始化向量。

换句话说，您的初始化向量应该是一个随机或伪随机的一次性数字（nonce），其中**nonce**代表“仅使用一次的数字”。如果您保持这种做法，那么带有块密码的CBC模式确保任何两个相同的明文块每次加密时通常都会不同。

最后，让我们关注**输出反馈模式**（**OFB模式**）。您可以在*图7*中看到这种模式的描述。

*图7：带有OFB模式的块密码*

![图7：带有OFB模式的块密码](assets/Figure4-7.webp "图7：带有OFB模式的块密码")

使用OFB模式时，您也会选择一个初始化向量。但在这里，对于第一个块，初始化向量直接与您的密钥一起插入块密码。然后，产生的128位被视为密钥流。这个密钥流与明文进行异或运算，以产生该块的密文。对于后续的块，您使用前一个块的密钥流作为输入插入块密码，并重复这些步骤。

如果您仔细观察，实际上在OFB模式下创建的是一个流密码。您生成128位的密钥流部分，直到您拥有与明文长度相同的密钥流（丢弃最后一个128位密钥流部分中不需要的位）。然后，您将密钥流与您的明文消息进行异或运算，以获得密文。

在之前关于流密码的部分中，我提到您借助私钥生成密钥流。确切地说，它不仅可以用私钥创建。正如您在OFB模式中看到的，密钥流是在私钥和初始化向量的支持下产生的。

注意，与CBC模式一样，每次在OFB模式下使用块密码时，选择一个伪随机或随机的一次性数字作为初始化向量很重要。否则，相同的128位消息字符串在不同的通信中将以相同的方式被加密。这是用流密码创建概率加密的一种方式。
一些流密码仅使用私钥来创建密钥流。对于这些流密码，重要的是您需要使用一个随机的随机数（nonce）来为每次通信选择私钥。否则，使用这些流密码的加密结果也将是确定性的，导致安全问题。
最流行的现代块密码是**Rijndael密码**。它是在1997年到2000年间，由国家标准与技术研究院（NIST）举办的一场比赛中从十五个提交作品中脱颖而出的获胜作品，目的是为了替换旧的加密标准，即**数据加密标准**（**DES**）。

Rijndael密码可以使用不同的密钥长度和块大小规格，以及不同的操作模式。NIST比赛的委员会采纳了Rijndael密码的一个限制版本——即一个要求128位块大小和128位、192位或256位的密钥长度的版本，作为**高级加密标准**（**AES**）的一部分。这实际上是对称加密应用的主要标准。它非常安全，以至于即使是美国国家安全局（NSA）也显然愿意使用256位密钥来加密最高机密文件。[6]

AES块密码将在*第5章*中详细解释。

**注释:**

[5] Shafi Goldwasser和Silvio Micali首次强调了概率加密的重要性，“概率加密”，_计算机与系统科学杂志_，28 (1984)，270–99。

[6] 参见NSA, "商业国家安全算法套件", [https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm](https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm)。

## 消除混淆
<chapterId>121c1858-27e3-5862-b0ce-4ff2f70f9f0f</chapterId>

关于块密码和流密码之间区别的混淆，是因为有时人们会将块密码的术语特指*具有块加密模式的块密码*。

考虑前一节中的ECB和CBC模式。这些模式特别要求加密数据能被块大小整除（意味着您可能需要为原始消息使用填充）。此外，这些模式中的数据也直接由块密码操作（而不仅仅是与块密码操作的结果结合，如OFB模式中所做的）。

因此，另一种方式，您可以将**块密码**定义为任何一种加密方案，它一次操作固定长度的消息块（任何块必须长于一个字节，否则它就会变成流密码）。加密数据和密文都必须能均匀地分割成这个块大小。通常，块大小长度为64、128、192或256位。相比之下，流密码可以一次加密任何消息中的一位或一个字节。

有了对块密码更具体的理解，您确实可以声称现代加密方案要么是流密码，要么是块密码。从现在开始，除非另有说明，我将在更一般的意义上使用块密码这个术语。
在上一节关于OFB模式的讨论中，还提出了另一个有趣的观点。一些流密码是由块密码构建的，比如使用OFB的Rijndael。而像Salsa20和ChaCha这样的密码则不是由块密码创建的。你可以称后者为**原始流密码**。（实际上并没有一个标准化的术语来指代这样的流密码。）
当人们讨论流密码和块密码的优缺点时，他们通常是在比较原始流密码和基于块密码的加密方案。

虽然你总是可以轻易地从块密码构造出一个流密码，但通常很难从一个原始流密码构建出某种带有块加密模式（如CBC模式）的构造。

通过这次讨论，你现在应该理解*图8*。它提供了对称加密方案的概览。我们使用三种类型的加密方案：原始流密码、块密码流密码和块模式下的块密码（在图中也称为“块密码”）。

*图8：对称加密方案概览*

![图8：对称加密方案概览](assets/Figure4-8.webp "图8：对称加密方案概览")


## 消息认证码
<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>

加密关注的是保密性。但密码学还涉及更广泛的主题，如消息的完整性、真实性和不可否认性。所谓的**消息认证码**（MACs）是支持通信中的真实性和完整性的对称密钥密码学方案。

为什么通信中除了保密性之外还需要其他东西呢？假设Bob使用几乎无法破解的加密向Alice发送一条消息。任何截获此消息的攻击者都无法就内容获得任何重要见解。然而，攻击者仍然至少有两个其他的攻击途径可供选择：

1. 她可以截获密文，更改其内容，然后将更改后的密文发送给Alice。
2. 她可以完全阻止Bob的消息，并发送她自己创建的密文。

在这两种情况下，攻击者可能对来自密文（1）和（2）的内容没有任何见解。但她仍然可以通过这种方式造成重大损害。这就是消息认证码变得重要的地方。

消息认证码被宽泛定义为具有三种算法的对称密码学方案：一个密钥生成算法、一个标签生成算法和一个验证算法。一个安全的MAC确保标签对任何攻击者来说都是**存在性不可伪造的**——也就是说，除非他们拥有私钥，否则他们不能成功地创建一个能够验证的消息标签。

Bob和Alice可以使用MAC来对抗对特定消息的操纵。假设他们暂时不关心保密性。他们只想确保Alice收到的消息确实来自Bob，并且没有以任何方式被更改。

这个过程在*图9*中描述。要使用**MAC**（消息认证码），他们首先生成一个私钥$K$，这个私钥在他们两人之间共享。Bob使用私钥$K$为消息创建一个标签$T$。然后，他将消息及其消息标签发送给Alice。她可以通过运行私钥、消息和标签的验证算法来验证Bob确实制作了标签。

*图9：对称加密方案概览*
![图 9：对称加密方案概览](assets/Figure4-9.webp "图 9：对称加密方案概览")
由于**存在性不可伪造性**，攻击者无法以任何方式更改消息 $M$ 或用有效标签创建她自己的消息。即使攻击者观察到使用相同私钥的 Bob 和 Alice 之间许多消息的标签，情况也是如此。最多，攻击者可以阻止 Alice 接收消息 $M$（这是密码学无法解决的问题）。

消息认证码（MAC）保证了消息确实是由 Bob 创建的。这种真实性，自动意味着消息的完整性——也就是说，如果 Bob 创建了某些消息，那么，事实上，它不会以任何方式被攻击者更改。因此，从现在开始，任何对认证的关注都应自动理解为对完整性的关注。

虽然在我的讨论中我区分了消息的真实性和完整性，但通常也将这些术语作为同义词使用。它们指的是由特定发送者创建且未以任何方式更改的消息的概念。本着这种精神，消息认证码也经常被称为**消息完整性码**。


## 认证加密
<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>

通常，您会希望在通信中同时保证秘密性和真实性，因此，加密方案和 MAC 方案通常会一起使用。

**认证加密方案**是一种将加密与 MAC 结合在高度安全的方式中的方案。具体来说，它必须满足存在性不可伪造性的标准以及非常强的秘密性概念，即抵抗**选择密文攻击**的能力。[7]

为了使加密方案能够抵抗选择密文攻击，它必须满足**不可变性**的标准：即，攻击者对密文的任何修改都应该产生无效的密文或解密为与原始密文无关的明文。[8]

由于认证加密方案确保攻击者创建的密文始终无效（因为标签不会被验证），它满足了抵抗选择密文攻击的标准。有趣的是，你可以证明，总是可以从组合一个存在性不可伪造的 MAC 和一个满足较弱安全概念的加密方案（即**选择明文攻击安全性**）创建认证加密方案。

我们不会深入探讨构建认证加密方案的所有细节。但了解其构建的两个细节很重要。

首先，认证加密方案首先处理加密，然后在密文上创建消息标签。事实证明，其他方法——如将密文与明文上的标签结合，或首先创建标签然后加密明文和标签——是不安全的。此外，这两个操作都有它们自己随机选择的私钥，否则您的安全性将受到严重威胁。

上述原则更普遍地适用：*在结合基本加密方案时，你应该始终使用不同的密钥*。

认证加密方案在*图 10*中描述。Bob 首先使用随机选择的密钥 $K_C$ 从消息 $M$ 创建密文 $C$。然后，他通过运行密文和另一个随机选择的密钥 $K_T$ 通过标签生成算法来创建消息标签 $T$。密文和消息标签都发送给 Alice。
爱丽丝现在首先检查给定密文$C$和密钥$K_T$时，标签是否有效。如果有效，她就可以使用密钥$K_C$解密消息。她不仅确信他们的通信具有非常强的保密性，而且她还知道这条消息是由鲍勃创建的。
*图 10: 一个认证加密方案*

![图 10: 一个认证加密方案](assets/Figure4-10.webp "图 10: 一个认证加密方案")

MAC是如何创建的？虽然MAC可以通过多种方法创建，但一种常见且高效的方法是通过**加密哈希函数**。

我们将在*第6章*中更详细地介绍加密哈希函数。现在，只需知道**哈希函数**是一种能够高效计算的函数，它接受任意大小的输入并产生固定长度的输出。例如，流行的哈希函数**SHA-256**（安全哈希算法256）无论输入大小如何，总是生成一个256位的输出。像SHA-256这样的哈希函数在密码学中有着有用的应用。

使用加密哈希函数生成的最常见的标签类型是**基于哈希的消息认证码**（HMAC）。该过程在*图 11*中描述。一方从私钥$K$产生两个不同的密钥，内部密钥$K_1$和外部密钥$K_2$。然后将明文$M$或密文$C$与内部密钥一起哈希。结果$T'$然后与外部密钥一起哈希以产生消息标签$T$。

有一系列的哈希函数可以用来创建HMAC。最常用的哈希函数是SHA-256。

*图 11: HMAC*

![图 11: HMAC](assets/Figure4-11.webp "图 11: HMAC")

**注释:**

[7] 本节讨论的具体结果来自Katz和Lindell，第131-147页。

[8] 从技术上讲，选择密文攻击的定义与非可塑性的概念不同。但你可以证明这两种安全概念是等价的。

## 安全通信会话
<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

假设两方处于通信会话中，因此他们来回发送多条消息。

认证加密方案允许消息的接收者验证消息是否由其通信会话中的伙伴创建（只要私钥没有泄露）。对于单条消息来说，这已经足够好了。然而，通常情况下，两方在通信会话中来回发送消息。在这种设置中，如前一节所述的普通认证加密方案在提供安全性方面存在不足。

主要原因是认证加密方案并不保证消息实际上也是由通信会话中创建它的代理发送的。考虑以下三种攻击向量：

1. **重放攻击**：攻击者重新发送她在两方之间之前某个时刻截获的密文和标签。
2. **重排序攻击**：攻击者在不同时间截获两条消息，并以相反的顺序将它们发送给接收者。
3. **反射攻击**：攻击者观察从A发送到B的消息，并且也将该消息发送给A。

尽管攻击者不知道密文并且不能创建伪造的密文，上述攻击仍然可以在通信中造成重大损害。
假设，例如，两方之间的特定消息涉及财务资金的转移。重放攻击可能会第二次转移资金。一个普通的认证加密方案对这类攻击无防御能力。
幸运的是，这类攻击在通信会话中通过使用**标识符**和**相对时间指示器**可以很容易地被缓解。

在加密之前，可以向明文消息添加标识符。这将阻止任何反射攻击。相对时间指示器，例如，可以是特定通信会话中的序列号。每方在加密前向消息添加序列号，以便接收方知道消息的发送顺序。这消除了重排序攻击的可能性。它也消除了重放攻击。攻击者发送的任何消息都会有一个旧的序列号，接收方将知道不再处理该消息。

为了说明安全通信会话是如何工作的，再次假设有Alice和Bob。他们来回发送了总共四条消息。你可以在*图11*下面看到一个带有标识符和序列号的认证加密方案是如何工作的。

通信会话开始时，Bob向Alice发送一个带有消息标签$T_{0,B}$的密文$C_{0,B}$。密文包含消息，以及一个标识符（BOB）和一个序列号（0）。标签$T_{0,B}$是在整个密文上生成的。在随后的通信中，Alice和Bob维持这一协议，根据需要更新字段。

*图12：一个安全的通信会话*

![图12：一个安全的通信会话](assets/Figure4-12.webp "图12：一个安全的通信会话")

# RC4和AES
<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

## RC4流密码
<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>

在本章中，我们将讨论一个现代原始流密码，RC4（或“Rivest密码4”），以及一个现代块密码，AES的加密方案的细节。虽然RC4密码作为加密方法已经不受青睐，AES是现代对称加密的标准。这两个例子应该能更好地说明对称加密的内部工作原理。

___

为了了解现代伪随机流密码是如何工作的，我将重点介绍RC4流密码。它是一个伪随机流密码，曾在WEP和WAP无线接入点安全协议以及TLS中使用。由于RC4有许多已证实的弱点，它已经不受青睐。事实上，互联网工程任务组现在禁止在所有TLS实例中的客户端和服务器应用程序使用RC4套件。尽管如此，它作为一个原始流密码的例子，很好地说明了其工作原理。

首先，我将展示如何使用一个简单的RC4密码对明文消息进行加密。假设我们的明文消息是“SOUP”。然后，使用我们的简单RC4密码进行加密，分四步进行。

### 第1步
首先，定义一个数组 **S**，其中 $S[0] = 0$ 到 $S[7] = 7$。这里的数组简单来说就是一个通过索引组织的可变值集合，也在一些编程语言中被称为列表（例如，Python）。在这个例子中，索引从0到7，值也从0到7。因此，**S** 如下所示：
- $S = [0, 1, 2, 3, 4, 5, 6, 7]$

这里的值不是ASCII数字，而是1字节字符串的十进制值表示。因此，值2等于 $0000 \ 0011$。因此，数组 **S** 的长度是8字节。

### 第二步

其次，通过选择一个1到8字节之间的密钥来定义一个长度为8字节的密钥数组 **K**（不允许字节的小数部分）。由于每个字节是8位，你可以为你的密钥的每个字节选择一个0到255之间的任何数字。

假设我们选择我们的密钥 **k** 为 $[14, 48, 9]$，这样它的长度为3字节。然后，我们的密钥数组的每个索引根据该特定密钥元素的十进制值按顺序设置。如果你遍历整个密钥，从头开始，直到你填满了密钥数组的8个槽位。因此，我们的密钥数组如下所示：

- $K = [14, 48, 9, 14, 48, 9, 14, 48]$

### 第三步

第三，我们将使用密钥数组 **K** 转换数组 **S**，这个过程被称为**密钥调度**。该过程如下伪代码所示：

- 创建变量 **j** 和 **i**
- 设置变量 $j = 0$
- 对于从0到7的每个 $i$：
    - 设置 $j = (j + S[i] + K[i]) \mod 8$
    - 交换 $S[i]$ 和 $S[j]$

数组 **S** 的转换由*表1*捕获。

从一开始，你可以看到 **S** 的初始状态为 $[0, 1, 2, 3, 4, 5, 6, 7]$，**j** 的初始值为0。这将使用密钥数组 $[14, 48, 9, 14, 48, 9, 14, 48]$ 进行转换。

for循环从 $i = 0$ 开始。根据上面的伪代码，**j** 的新值变为6（$j = (j + S[0] + K[0]) \mod 8 = (0 + 0 + 14) \mod 8 = 6 \mod 8$）。交换 $S[0]$ 和 $S[6]$，经过1轮后 **S** 的状态变为 $[6, 1, 2, 3, 4, 5, 0, 7]$。
在下一行中，$i = 1$。再次通过for循环，**j**获得了7的值（$j = (j + S[1] + K[1]) \mod 8 = (6 + 1 + 48) \mod 8 = 55 \mod 8 = 7 \mod 8$）。从当前状态的**S**中交换$S[1]$和$S[7]$，$[6, 1, 2, 3, 4, 5, 0, 7]$，得到第二轮后的$[6, 7, 2, 3, 4, 5, 0, 1]$。
我们继续这个过程，直到我们为数组**S**产生最底部的最终行，$[6, 4, 1, 0, 3, 7, 5, 2]$。

*表1：密钥调度表*

| 轮次   | i   | j   |     | S[0] | S[1] | S[2] | S[3] | S[4] | S[5] | S[6] | S[7] |
| ------- | --- | --- | --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|         |     |     |     |      |      |      |      |      |      |      |      |
| 初始状态 |     | 0   |     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| 1       | 0   | 6   |     | 6    | 1    | 2    | 3    | 4    | 5    | 0    | 7    |
| 2       | 1   | 7   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 3       | 2   | 2   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 4       | 3   | 3   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 5       | 4   | 3   |     | 6    | 7    | 2    | 0    | 3    | 5    | 4    | 1    |
| 6       | 5   | 6   |     | 6    | 4    | 2    | 0    | 3    | 7    | 5    | 1    |
| 7       | 6   | 1   |     | 6    | 4    | 2    | 0    | 3    | 7    | 5    | 2    |
| 8       | 7   | 2   |     | 6    | 4    | 1    | 0    | 3    | 7    | 5    | 2    |

### 第4步
作为第四步，我们生成**密钥流**。这是一个与我们想要发送的消息长度相等的伪随机字符串。这将用于加密原始消息“SOUP”。由于密钥流需要与消息一样长，因此我们需要一个有4个字节的密钥流。
密钥流通过以下伪代码产生：

- 创建变量 **j**、**i** 和 **t**。
- 设置 $j = 0$。
- 对于明文的每个 $i$，从 $i = 1$ 开始，一直到 $i = 4$，密钥流的每个字节按以下方式产生：
    - $j = (j + S[i]) \mod 8$
    - 交换 $S[i]$ 和 $S[j]$。
    - $t = (S[i] + S[j]) \mod 8$
    - 第 $i^{th}$ 个字节的密钥流 = $S[t]$

您可以在*表2*中跟随计算过程。

**S**的初始状态是 $S = [6, 4, 1, 0, 3, 7, 5, 2]$。设置 $i = 1$，**j** 的值变为 4（$j = (j + S[i]) \mod 8 = (0 + 4) \mod 8 = 4$）。然后我们交换 $S[1]$ 和 $S[4]$，以产生**S**在第二行的变换，$[6, 3, 1, 0, 4, 7, 5, 2]$。然后 **t** 的值是 7（$t = (S[i] + S[j]) \mod 8 = (3 + 4) \mod 8 = 7$）。最后，密钥流的字节是 $S[7]$，或者说是 2。

然后我们继续产生其他字节，直到我们有以下四个字节：2、6、3 和 7。每个字节都可以用来加密明文“SOUP”的每个字母。

首先，使用ASCII表，我们可以看到“SOUP”通过底层字节字符串的十进制值编码是“83 79 85 80”。与密钥流“2 6 3 7”结合产生“85 85 88 87”，经过模256操作后保持不变。在ASCII中，密文“85 85 88 87”等于“UUXW”。

如果要加密的单词比数组**S**更长会怎样？在这种情况下，只要明文的每个字节**i**，数组**S**就会以上述显示的方式不断变换，直到我们得到一个与明文中字母数量相等的密钥流字节数。


*表2：密钥流生成*

| i   | j   | t   | 密钥流 | S[0] | S[1] | S[2] | S[3] | S[4] | S[5] | S[6] | S[7] |
| --- | --- | --- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|     | 0   |     |           | 6    | 4    | 1    | 0    | 3    | 7    | 5    | 2    || 1   | 4   | 7   | 2         | 6    | 3    | 1    | 0    | 4    | 7    | 5    | 2    |
| 2   | 5   | 0   | 6         | 6    | 3    | 7    | 0    | 4    | 1    | 5    | 2    |
| 3   | 5   | 1   | 3         | 6    | 3    | 7    | 1    | 4    | 0    | 5    | 2    |
| 4   | 1   | 7   | 2         | 6    | 4    | 7    | 1    | 3    | 0    | 5    | 2    |

我们刚刚讨论的例子只是**RC4流密码**的简化版本。实际的RC4流密码有一个长度为256字节的**S**数组，而不是8字节，密钥长度可以在1到256字节之间，而不是1到8字节。然后，密钥数组和密钥流都是考虑到**S**数组的256字节长度来产生的。计算变得极其复杂，但原理保持不变。使用相同的密钥[14,48,9]，标准RC4密码加密的明文消息"SOUP"以十六进制格式加密为67 02 ed df。

一个密钥流独立于明文消息或密文更新的流密码是**同步流密码**。密钥流仅依赖于密钥。显然，RC4是同步流密码的一个例子，因为密钥流与明文或密文无关。我们在前一章提到的所有原始流密码，包括移位密码、维吉尼亚密码和一次性密码本，也都是同步类型的。

相比之下，**异步流密码**的密钥流是由密钥和密文的前几个元素共同产生的。这种类型的密码也被称为**自同步密码**。

重要的是，用RC4产生的密钥流应该被视为一次性密码本，你不能以完全相同的方式下一次产生密钥流。与其每次更换密钥，一个实用的解决方案是将密钥与**随机数**结合起来产生字节流。

## 带有128位密钥的AES
<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

如前一章所述，国家标准与技术研究院（NIST）在1997年到2000年间举办了一个比赛，以确定新的对称加密标准。**Rijndael密码**成为了获胜的参赛作品。这个名字是基于比利时创造者Vincent Rijmen和Joan Daemen的名字的文字游戏。
Rijndael密码是一种**块密码**，意味着它有一个核心算法，可以用不同的密钥长度和块大小的规格来使用。然后，您可以将其与不同的操作模式结合，构建加密方案。
NIST竞赛委员会采用了Rijndael密码的一个限制版本——即一个要求128位块大小和128位、192位或256位的密钥长度的版本——作为**高级加密标准（AES）**的一部分。这个限制版本的Rijndael密码也可以在多种操作模式下使用。该标准的规范被称为**高级加密标准（AES）**。

为了展示Rijndael密码的工作原理，即AES的核心，我将以128位密钥的加密过程为例进行说明。密钥大小会影响每个加密块所需的轮数。对于128位密钥，需要10轮。对于192位和256位，则分别需要12轮和14轮。

此外，我将假设AES使用**ECB模式**。这使得阐述稍微简单一些，并且对于Rijndael算法来说并不重要。确实，ECB模式在实践中是不安全的，因为它导致了确定性加密。与AES一起使用的最常见的安全模式是**CBC**（Cipher Block Chaining）。

我们称密钥为$K_0$。则以上参数的构造，如*图1*所示，其中$M_i$代表128位的明文消息的一部分，$C_i$代表128位的密文的一部分。如果明文不能被块大小均匀分割，则在最后一个块中添加填充。


*图1: 128位密钥的AES-ECB*

![图1: 128位密钥的AES-ECB](assets/Figure5-1.webp "图1: 128位密钥的AES-ECB")

每个128位的文本块在Rijndael加密方案中经过十轮。这需要为每一轮产生一个单独的轮密钥（$K_1$至$K_{10}$）。这些轮密钥是从原始的128位密钥$K_0$使用**密钥扩展算法**为每一轮产生的。因此，对于要加密的每个文本块，我们将使用原始密钥$K_0$以及十个单独的轮密钥。注意，这相同的11个密钥用于需要加密的每个128位的明文块。

密钥扩展算法既长又复杂。深入研究它的教育效益不大。如果您愿意，可以自行查看密钥扩展算法。一旦产生了轮密钥，Rijndael密码将操作第一个128位的明文块$M_1$，如*图2*所示。我们现在将通过这些步骤。

*图2: 使用Rijndael密码操作$M_1$的过程:*

**第0轮:**
- 将$M_1$和$K_0$进行XOR运算产生$S_0$

---

**第n轮，对于n = {1,...,9}:**
- 将$S_{n-1}$和$K_n$进行XOR运算
- 字节替换
- 行移位
- 列混淆
- 将$S$和$K_n$进行XOR运算产生$S_n$

---

**第10轮:**
- 将 $S_9$ 和 $K_{10}$ 进行异或操作 - 字节替换
- 行移位
- 将 $S$ 和 $K_{10}$ 进行异或操作以产生 $S_{10}$
- $S_{10}$ = $C_1$

### 第0轮

Rijndael密码的第0轮相对简单。通过128位明文和私钥之间的异或操作产生一个数组 $S_0$。即，

- $S_0 = M_1 \oplus K_0$

### 第1轮

在第1轮中，首先使用异或操作将数组 $S_0$ 与轮密钥 $K_1$ 结合。这产生了一个新的状态 $S$。

其次，对当前状态 $S$ 执行**字节替换**操作。它通过取16字节 $S$ 数组的每个字节，并将其替换为称为**Rijndael的S盒**的数组中的一个字节来工作。每个字节都有一个独特的变换，结果产生了一个新的状态 $S$。Rijndael的S盒在*图3*中显示。

*图3：Rijndael的S-盒*

|     | 00  | 01  | 02  | 03  | 04  | 05  | 06  | 07  | 08  | 09  | 0A  | 0B  | 0C  | 0D  | 0E  | 0F  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 00  | 63  | 7C  | 77  | 7B  | F2  | 6B  | 6F  | C5  | 30  | 01  | 67  | 2B  | FE  | D7  | AB  | 76  |
| 10  | CA  | 82  | C9  | 7D  | FA  | 59  | 47  | F0  | AD  | D4  | A2  | AF  | 9C  | A4  | 72  | C0  |
| 20  | B7  | FD  | 93  | 26  | 36  | 3F  | F7  | CC  | 34  | A5  | E5  | F1  | 71  | D8  | 31  | 15  |
| 30  | 04  | C7  | 23  | C3  | 18  | 96  | 05  | 9A  | 07  | 12  | 80  | E2  | EB  | 27  | B2  | 75  |
| 40  | 09  | 83  | 2C  | 1A  | 1B  | 6E  | 5A  | A0  | 52  | 3B  | D6  | B3  | 29  | E3  | 2F  | 84  |
| 50  | 53  | D1  | 00  | ED  | 20  | FC  | B1  | 5B  | 6A  | CB  | BE  | 39  | 4A  | 4C  | 58  | CF  || 60  | D0  | EF  | AA  | FB  | 43  | 4D  | 33  | 85  | 45  | F9  | 02  | 7F  | 50  | 3C  | 9F  | A8  |
| 70  | 51  | A3  | 40  | 8F  | 92  | 9D  | 38  | F5  | BC  | B6  | DA  | 21  | 10  | FF  | F3  | D2  |
| 80  | CD  | 0C  | 13  | EC  | 5F  | 97  | 44  | 17  | C4  | A7  | 7E  | 3D  | 64  | 5D  | 19  | 73  |
| 90  | 60  | 81  | 4F  | DC  | 22  | 2A  | 90  | 88  | 46  | EE  | B8  | 14  | DE  | 5E  | 0B  | DB  |
| A0  | E0  | 32  | 3A  | 0A  | 49  | 06  | 24  | 5C  | C2  | D3  | AC  | 62  | 91  | 95  | E4  | 79  |
| B0  | E7  | C8  | 37  | 6D  | 8D  | D5  | 4E  | A9  | 6C  | 56  | F4  | EA  | 65  | 7A  | AE  | 08  |
| C0  | BA  | 78  | 25  | 2E  | 1C  | A6  | B4  | C6  | E8  | DD  | 74  | 1F  | 4B  | BD  | 8B  | 8A  |
| D0  | 70  | 3E  | B5  | 66  | 48  | 03  | F6  | 0E  | 61  | 35  | 57  | B9  | 86  | C1  | 1D  | 9E  |
| E0  | E1  | F8  | 98  | 11  | 69  | D9  | 8E  | 94  | 9B  | 1E  | 87  | E9  | CE  | 55  | 28  | DF  |
| F0  | 8C  | A1  | 89  | 0D  | BF  | E6  | 42  | 68  | 41  | 99  | 2D  | 0F  | B0  | 54  | BB  | 16  |

这个S-盒是抽象代数在Rijndael密码算法中发挥作用的一个地方，特别是**伽罗瓦域**。

首先，你将每个可能的字节元素00至FF定义为一个8位向量。每个这样的向量都是**伽罗瓦域GF(2^8)**中的一个元素，其中模运算的不可约多项式是$x^8 + x^4 + x^3 + x + 1$。具有这些规格的伽罗瓦域也被称为**Rijndael的有限域**。

接下来，对于域中的每个可能元素，我们创建所谓的**Nyberg S-盒**。在这个盒子中，每个字节都映射到其**乘法逆元**（即，使它们的乘积等于1）。然后我们将Nyberg S-盒中的值通过**仿射变换**映射到Rijndael的S-盒。

在**S**数组上的第三个操作是**行移位**操作。它取**S**的状态并列出矩阵中的所有十六个字节。填充矩阵从左上角开始，并通过从上到下进行，然后，每次填充完一列，就向右移动一列并回到顶部。

一旦**S**的矩阵构建完成，四行将被移位。第一行保持不变。第二行向左移动一位。第三行向左移动两位。第四行向左移动三位。过程的一个示例在*图4*中提供。**S**的原始状态显示在顶部，移位行操作后的结果状态显示在下面。

*图4：行移位操作*

| F1   | A0   | B1   | 23   |
|------|------|------|------|
| 59   | EF   | 09   | 82   |
| 97   | 01   | B0   | CC   |
| D4   | 72   | 04   | 21   |

| F1   | A0   | B1   | 23   |
|------|------|------|------|
| EF   | 09   | 82   | 59   |
| B0   | CC   | 97   | 01   |
| 21   | D4   | 72   | 04   |


在第四步中，**伽罗瓦域**再次出现。首先，**S**矩阵的每一列与*图5*中看到的4 x 4矩阵的一列相乘。但这不是常规的矩阵乘法，而是向量乘法**模一个不可约多项式**，$x^8 + x^4 + x^3 + x + 1$。结果向量的系数代表一个字节的各个位。

*图5：列混淆矩阵*

| 02   | 03   | 01   | 01   |
|------|------|------|------|
| 01   | 02   | 03   | 01   |
| 01   | 01   | 02   | 03   || 03   | 01   | 01   | 02   |

**S** 矩阵的第一列与上面的 4 x 4 矩阵相乘的结果如*图 6*所示。

*图 6：第一列的乘法：*

$$
\begin{matrix}
02 \cdot F1 + 03 \cdot EF + 01 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 02 \cdot EF + 03 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 01 \cdot EF + 02 \cdot B0 + 03 \cdot 21 \\
03 \cdot F1 + 01 \cdot EF + 01 \cdot B0 + 02 \cdot 21
\end{matrix}
$$

下一步，矩阵中的所有项都需要转换成多项式。例如，F1 代表 1 字节，将变成 $x^7 + x^6 + x^5 + x^4 + 1$，03 代表 1 字节，将变成 $x + 1$。

然后所有的乘法运算都是在 $x^8 + x^4 + x^3 + x + 1$ 下进行**模**运算。这将导致每个列的四个单元中加上四个多项式。在对这些加法进行**模 2**运算后，你将得到四个多项式。这些多项式中的每一个都代表一个 8 位字符串，或者说，1 字节的 **S**。我们不会在这里对*图 6*中的矩阵进行所有这些计算，因为它们是广泛的。

一旦处理完第一列，**S** 矩阵的其他三列也以相同的方式处理。最终，这将产生一个可以转换成数组的十六字节矩阵。

作为最后一步，数组 **S** 再次与轮密钥通过**异或**（XOR）操作结合。这产生了状态 $S_1$。即，

- $S_1 = S \oplus K_0$

### 第 2 至 10 轮

第 2 至 9 轮只是第 1 轮的重复，*变通地说*。最后一轮与前几轮非常相似，除了省略了**混合列**步骤。即，第 10 轮如下执行：

- $S_9 \oplus K_{10}$
- 字节替换
- 行移位
- $S_{10} = S \oplus K_{10}$

状态 $S_{10}$ 现在设置为 $C_1$，即密文的前 128 位。处理剩余的 128 位明文块，产生完整的密文 **C**。

### Rijndael 密码的操作

Rijndael 密码中不同操作的原理是什么？

不深入细节，加密方案是基于它们创建混淆和扩散的程度来评估的。如果加密方案具有高度的**混淆**，这意味着密文与明文看起来截然不同。如果加密方案具有高度的**扩散**，这意味着对明文的任何小改动都会产生截然不同的密文。
Rijndael密码背后操作的推理是它们既产生高度的混淆也产生扩散。混淆是通过字节替换操作产生的，而扩散是通过行移位和列混合操作产生的。
# 非对称密码学
<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

## 密钥分发和管理问题
<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

与对称密码学一样，非对称方案可以用来确保机密性和认证性。然而，与之相反的是，这些方案使用两个密钥而不是一个：一个私钥和一个公钥。

我们从发现非对称密码学开始，特别是激发它的问题。接下来，我们讨论非对称加密和认证方案在高层次上是如何工作的。然后，我们介绍哈希函数，这对于理解非对称认证方案至关重要，并且在其他密码学上下文中也有相关性，例如我们在第4章讨论的基于哈希的消息认证码。

___

假设Bob想从Jim的体育用品店，一个在北美拥有数百万客户的在线体育用品零售商，购买一件新的雨衣。这将是他第一次从他们那里购买，他想使用他的信用卡。因此，Bob首先需要在Jim的体育用品店创建一个账户，这需要发送个人详细信息，如他的地址和信用卡信息。然后，他可以完成购买雨衣所需的步骤。

Bob和Jim的体育用品店将希望确保他们的通信在整个过程中是安全的，考虑到互联网是一个开放的通信系统。例如，他们将希望确保没有潜在的攻击者可以获取Bob的信用卡和地址详细信息，没有潜在的攻击者可以重复他的购买或代表他创建假的购买。

正如上一章所讨论的，一个高级的认证加密方案肯定可以使Bob和Jim的体育用品店之间的通信安全。但显然实施这样的方案存在实际障碍。

为了说明这些实际障碍，假设我们生活在一个只存在对称密码学工具的世界中。那么，Jim的体育用品店和Bob可以做些什么来确保安全通信呢？

在那种情况下，他们将面临沟通安全的巨大成本。由于互联网是一个开放的通信系统，他们不能仅仅通过它交换一组密钥。因此，Bob和Jim的体育用品店的代表将需要亲自进行密钥交换。

一种可能性是Jim的体育用品店创建特殊的密钥交换地点，Bob和其他新客户可以在那里获取一套安全通信的密钥。这显然会带来巨大的组织成本，并大大降低新客户进行购买的效率。

或者，Jim的体育用品店可以通过一个高度信任的快递员发送一对密钥给Bob。这可能比组织密钥交换地点更有效率。但这仍然会带来巨大的成本，特别是如果许多客户只进行一次或几次购买。

接下来，一个对称的认证加密方案也迫使Jim的体育用品店为所有客户存储单独的密钥集。对于成千上万的客户来说，这将是一个重大的实际挑战，更不用说数百万了。
要理解这个后一点，假设吉姆体育用品店为每位顾客提供相同的一对钥匙。这将允许每个顾客——或任何其他能够获得这对钥匙的人——阅读甚至操纵吉姆体育用品店及其顾客之间的所有通信。那么，你可能也不需要在你的通信中使用密码学了。
即使只为一些顾客重复一组钥匙，也是一个极其糟糕的安全做法。任何潜在的攻击者都可能尝试利用该方案的这一特点（记住，根据克尔克霍夫原则，攻击者假定知道方案的一切，但不知道钥匙。）

因此，吉姆体育用品店不得不为每位顾客存储一对钥匙，无论这些钥匙对是如何分发的。这显然带来了几个实际问题。

- 吉姆体育用品店不得不存储数百万对钥匙，每位顾客一套。
- 这些钥匙必须得到妥善保护，因为它们将成为黑客的首要目标。任何安全漏洞都将需要重复进行成本高昂的钥匙交换，无论是在特殊的钥匙交换地点还是通过快递。
- 吉姆体育用品店的任何顾客都必须在家中安全地存储一对钥匙。丢失和盗窃将发生，需要重复进行钥匙交换。顾客还必须为他们希望通过互联网与之通信和交易的任何其他在线商店或其他类型的实体经历这一过程。

直到20世纪70年代末，这两个主要挑战一直是非常基本的关注点。它们被称为**密钥分发问题**和**密钥管理问题**。

当然，这些问题一直存在，并且在过去经常造成头疼。例如，军事力量不得不不断地将带有安全通信密钥的书籍分发给前线人员，这既冒着巨大的风险又需要大量成本。但随着世界越来越多地转向长距离、数字通信，特别是对于非政府实体，这些问题变得更加严重。

如果这些问题在1970年代没有得到解决，吉姆体育用品店的高效和安全购物可能根本就不会存在。事实上，我们大多数现代世界的实用和安全电子邮件、在线银行和购物可能只是一个遥远的幻想。任何类似比特币的东西根本就不可能存在。

那么，1970年代发生了什么？我们如何能够立即在线进行购买并安全地浏览万维网？我们如何能够即时从我们的智能手机向全世界发送比特币？

## 密码学的新方向
<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

到了1970年代，密钥分发和密钥管理问题引起了一群美国学术密码学家的注意：惠特菲尔德·迪菲（Whitfield Diffie）、马丁·赫尔曼（Martin Hellman）和拉尔夫·默克尔（Ralph Merkle）。面对来自大多数同行的严重怀疑，他们冒险提出了一个解决方案。

他们冒险的至少一个主要动机是预见到开放的计算机通信将深刻影响我们的世界。正如迪菲和赫尔曼在1976年指出的，
计算机控制的通信网络的发展，承诺实现人与人或计算机与计算机之间跨越世界两端的无劳力且低成本的联系，取代了大多数邮件和许多出行，转而使用电信通讯。对于许多应用来说，这些联系必须对窃听和非法消息的注入保持安全。然而，目前，安全问题的解决方案在通信技术的其他领域远远落后。*现代密码学无法满足要求，因为它的使用会给系统用户带来如此严重的不便，以至于消除了电子处理的许多好处。*[1]

Diffie、Hellman 和 Merkle 的坚持得到了回报。他们的研究成果首次发表是在 1976 年 Diffie 和 Helmann 发表的一篇题为《密码学的新方向》的论文中。在这篇论文中，他们提出了两种解决密钥分发和密钥管理问题的原创方法。

他们提供的第一个解决方案是一个远程*密钥交换协议*，即一套在不安全的通信渠道上交换一个或多个对称密钥的规则。这个协议现在被称为*Diffie-Helmann 密钥交换*或*Diffie-Helmann-Merkle 密钥交换*。[2]

通过 Diffie-Helmann 密钥交换，两方首先在一个不安全的渠道如互联网上公开交换一些信息。基于这些信息，他们然后独立地创建一个对称密钥（或一对对称密钥）以进行安全通信。虽然双方独立创建他们的密钥，但他们公开共享的信息确保了这个密钥创建过程对他们双方来说产生相同的结果。

重要的是，虽然每个人都可以观察到双方通过不安全渠道公开交换的信息，但只有参与信息交换的两方才能从中创建对称密钥。

这当然听起来完全违反直觉。两方如何能公开交换一些信息，仅允许他们从中创建对称密钥？为什么观察信息交换的其他人不能创建相同的密钥？

这当然依赖于一些美妙的数学。Diffie-Helmann 密钥交换通过一个带有陷门的单向函数工作。让我们依次讨论这两个术语的含义。

假设你被给定了某个函数$f(x)$和结果$f(a) = y$，其中$a$是$x$的一个特定值。我们说$f(x)$是一个**单向函数**，如果当给定$a$和$f(x)$时，计算值$y$是容易的，但是当给定$y$和$f(x)$时，计算值$a$在计算上是不可行的。当然，**单向函数**这个名称源于这样一个事实：这样的函数只能在一个方向上实际计算。

一些单向函数具有所谓的**陷门**。虽然仅给定$y$和$f(x)$时计算$a$几乎是不可能的，但有一种特定的信息$Z$使得从$y$计算$a$在计算上变得可行。这种信息$Z$被称为**陷门**。具有陷门的单向函数被称为**陷门函数**。
我们在这里不会深入探讨Diffie-Helmann密钥交换的细节。但本质上，每个参与者都会创建一些信息，其中一部分公开分享，而另一部分保密。然后，每一方都会取他们的保密信息和另一方公开分享的信息来创建一个私钥。有些神奇的是，两方最终会得到相同的私钥。
任何仅观察两方在Diffie-Helmann密钥交换中公开分享的信息的一方都无法复制这些计算。他们需要从两方中的一方那里获得私人信息才能做到这一点。

虽然1976年论文中介绍的Diffie-Helmann密钥交换的基本版本并不非常安全，但基本协议的复杂版本今天肯定仍在使用。最重要的是，传输层安全协议（version 1.3）的最新版本中的每一个密钥交换协议本质上都是Diffie和Hellman在1976年提出的协议的丰富版本。传输层安全协议是安全交换根据超文本传输协议（http）格式化的信息的主要协议，http是交换Web内容的标准。

重要的是，Diffie-Helmann密钥交换不是一个非对称方案。严格来说，它可以说属于对称密钥密码学的领域。但由于Diffie-Helmann密钥交换和非对称密码学都依赖于具有陷门的单向数论函数，它们通常一起讨论。

Diffie和Helmann在他们1976年的论文中提出的解决密钥分发和管理问题的第二种方式，当然是通过非对称密码学。

与他们对Diffie-Hellman密钥交换的介绍相比，他们只提供了如何可能构建非对称密码学方案的一般轮廓。他们没有提供任何一种特定的单向函数，这种函数可以具体满足这些方案中合理安全性所需的条件。

然而，一年后，三位不同的学术密码学家和数学家找到了一种非对称方案的实际实现：Ronald Rivest, Adi Shamir和Leonard Adleman。[3] 他们介绍的密码系统被称为**RSA密码系统**（以他们的姓氏命名）。

在非对称密码学（和Diffie Helmann密钥交换）中使用的陷门函数都与两个主要的**计算难题**相关：素数分解和离散对数的计算。

**素数分解**，顾名思义，需要将一个整数分解成其素因数。RSA问题是迄今为止与素数分解相关的最著名的密码系统示例。

**离散对数问题**是在循环群中出现的问题。给定一个特定循环群中的生成元，它需要计算产生该群中另一个元素所需的唯一指数。

基于离散对数的方案依赖于两种主要的循环群：整数的乘法群和包括椭圆曲线上点的群。原始的Diffie Helmann密钥交换，如“密码学的新方向”中所呈现，是与整数的循环乘法群一起工作的。比特币的数字签名算法和最近引入的Schnorr签名方案（2021）都是基于特定椭圆曲线循环群的离散对数问题。

接下来，我们将转向非对称设置中的秘密性和认证的高层次概述。然而，在此之前，我们确实需要做一个简短的历史说明。
现在看来，一组为政府通信总部（GCHQ）工作的英国密码学家和数学家似乎在几年前就独立完成了上述发现。这个小组由James Ellis、Clifford Cocks和Malcolm Williamson组成。

根据他们自己的说法以及GCHQ的说法，是James Ellis在1969年首先提出了公钥密码学的概念。据称，Clifford Cocks在1973年发现了RSA密码系统，而Malcolm Williamson在1974年提出了Diffie-Hellman密钥交换的概念。[4]然而，由于在GCHQ所做工作的秘密性质，他们的发现直到1997年才被披露。

**注释：**

[1] Whitfield Diffie和Martin Hellman，“密码学的新方向”，_IEEE信息理论交易_ IT-22（1976），第644-654页，第644页。

[2] Ralph Merkle也在“通过不安全渠道的安全通信”中讨论了一个密钥交换协议，_计算机协会通讯_，21（1978），294-99。虽然Merkle实际上在Diffie和Hellman的论文之前提交了这篇论文，但它的发表时间较晚。与Diffie-Hellman的解决方案不同，Merkle的解决方案不是指数级安全的。

[3] Ron Rivest, Adi Shamir和Leonard Adleman，“获取数字签名和公钥密码系统的方法”，_计算机协会通讯_，21（1978），第120-126页。

[4] Simon Singh的_密码书_提供了这些发现的良好历史，第四版（伦敦，1999），第6章。

## 非对称加密和认证
<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

*图1*提供了Bob和Alice帮助下的**非对称加密**概述。

Alice首先创建一对密钥，包括一个公钥（$K_P$）和一个私钥（$K_S$），其中“P”在$K_P$中代表“公共的”，“S”在$K_S$中代表“秘密的”。然后，她将这个公钥自由地分发给其他人。我们稍后会回到这个分发过程的细节。但就目前而言，假设任何人，包括Bob，都可以安全地获取Alice的公钥$K_P$。

在某个稍后的时间点，Bob想要给Alice写一条包含敏感信息的消息$M$。他希望这些内容对除了Alice之外的所有人保密。因此，Bob首先使用$K_P$加密他的消息$M$。然后，他将得到的密文$C$发送给Alice，Alice使用$K_S$解密$C$以产生原始消息$M$。

*图1：非对称加密*

![图1：非对称加密](assets/Figure6-1.webp "图1：非对称加密")

任何监听Bob和Alice通信的对手都可以观察到$C$。她还知道$K_P$和加密算法$E(\cdot)$。然而，重要的是，这些信息不允许攻击者可行地解密密文$C$。解密特别需要$K_S$，而攻击者并不拥有。
对称加密方案通常需要对能够有效加密明文消息的攻击者（称为选择密文攻击安全性）保持安全。然而，它并非专门设计用于允许攻击者或其他任何人创建这样有效的密文。
这与非对称加密方案形成鲜明对比，其整个目的是允许任何人，包括攻击者，生成有效的密文。因此，非对称加密方案可以被标记为**多重访问密码**。

为了更好地理解发生了什么，想象一下，如果不是通过电子方式发送消息，鲍勃想要秘密地发送一封实体信件。确保秘密的一种方式是爱丽丝发送一个安全的挂锁给鲍勃，但保留解锁它的钥匙。鲍勃写完信后，可以将信放入一个盒子中，并用爱丽丝的挂锁关闭它。然后，他可以将锁着的盒子连同消息一起发送给拥有钥匙的爱丽丝。

虽然鲍勃能够锁上挂锁，但如果挂锁确实安全，他或任何截获盒子的人都无法打开挂锁。只有爱丽丝可以解锁它并查看鲍勃信件的内容，因为她拥有钥匙。

粗略地说，非对称加密方案是这一过程的数字版本。挂锁类似于公钥，挂锁钥匙类似于私钥。然而，因为挂锁是数字的，所以对爱丽丝来说，将其分发给任何可能想要向她发送秘密消息的人更加容易且成本不高。

在非对称设置中，我们使用**数字签名**进行认证。因此，它们具有与对称设置中的消息认证码相同的功能。*图2*提供了数字签名的概述。

鲍勃首先创建一对密钥，包括公钥（$K_P$）和私钥（$K_S$），并分发他的公钥。当他想要发送经过认证的消息给爱丽丝时，他首先取他的消息$M$和他的私钥来创建一个**数字签名**$D$。然后鲍勃将他的消息连同数字签名一起发送给爱丽丝。

爱丽丝将消息、公钥和数字签名输入到一个**验证算法**中。这个算法产生**true**表示签名有效，或**false**表示签名无效。

数字签名，正如其名称清楚地表明的，是信件、合同等书面签名的数字等价物。实际上，数字签名通常更加安全。你可以通过一些努力伪造书面签名；这一过程因为书面签名经常不被仔细验证而变得更容易。然而，一个安全的数字签名，就像一个安全的消息认证码一样，是**存在性不可伪造的**：也就是说，有了一个安全的数字签名方案，除非他们拥有私钥，否则没有人可以可行地为一条消息创建一个通过验证程序的签名。

*图2：非对称认证*

![图2：非对称认证](assets/Figure6-2.webp "图2：非对称认证")

与非对称加密一样，我们看到数字签名和消息认证码之间有一个有趣的对比。对于后者，验证算法只能由参与安全通信的一方使用。这是因为它需要一个私钥。然而，在非对称设置中，任何人都可以验证鲍勃制作的数字签名$S$。
数字签名使其成为一种极其强大的工具。例如，它是创建可出于法律目的验证的合同签名的基础。如果鲍勃在上述交换中对合同进行了签名，爱丽丝可以向法庭展示消息$M$、合同和签名$S$。然后，法庭可以使用鲍勃的公钥来验证签名。[5]
另一个例子是，数字签名是安全软件和软件更新分发的重要方面。这种公开可验证性是仅仅使用消息认证码无法实现的。

作为数字签名力量的最后一个例子，考虑比特币。关于比特币，尤其是在媒体中，最常见的误解之一是交易被加密了：实际上并没有。相反，比特币交易通过使用数字签名来确保安全性。

比特币以称为未花费交易输出（或**UTXO**）的批次存在。假设你在一个特定的比特币地址收到了三笔每笔2比特币的支付。技术上讲，你现在在那个地址上并没有6比特币。相反，你有三批每批2比特币，它们被与该地址相关联的加密问题锁定。对于你进行的任何支付，根据交易所需的金额，你可以使用这些批次中的一批、两批或全部三批。

对未花费交易输出的所有权证明通常通过一个或多个数字签名来展示。比特币之所以有效，正是因为在不拥有制作它们所需的秘密信息的情况下，对未花费交易输出进行有效数字签名在计算上是不可行的。

当前，比特币交易透明地包含了网络中的参与者需要验证的所有信息，例如交易中使用的未花费交易输出的来源。虽然有可能隐藏一些信息同时仍允许进行验证（就像一些替代加密货币如门罗币所做的那样），但这也创建了特定的安全风险。

有时会对数字签名和数字化捕获的书面签名产生混淆。在后一种情况下，你捕获你的书面签名的图像，并将其粘贴到电子文档（如雇佣合同）上。然而，这并不是加密意义上的数字签名。后者只是一个长数字，只有拥有私钥的情况下才能产生。

就像在对称密钥设置中一样，你也可以将非对称加密和认证方案一起使用。类似的原则适用。首先，你应该使用不同的私钥-公钥对进行加密和制作数字签名。此外，你应该先加密消息，然后对其进行认证。

重要的是，在许多应用中，并不是在整个通信过程中都使用非对称加密。相反，它通常只用于*交换对称密钥*，以便双方实际进行通信。

例如，当你在线购买商品时就是这种情况。知道卖方的公钥后，她可以向你发送经过数字签名的消息，你可以验证这些消息的真实性。在此基础上，你可以遵循多种协议之一来交换对称密钥，以安全地通信。

采用上述方法的主要原因是，与对称加密相比，非对称加密在产生特定安全级别时效率要低得多。这是我们仍然需要对称密钥加密与公钥加密并存的原因之一。此外，对称密钥加密在特定应用中更为自然，例如计算机用户加密自己的数据。

那么，数字签名和公钥加密是如何准确解决密钥分发和密钥管理问题的呢？
这里没有唯一的答案。非对称加密是一种工具，并没有唯一的使用方式。但让我们以之前提到的吉姆体育用品店的例子来展示这种情况下问题通常如何被解决。
首先，吉姆体育用品店可能会接近一个**证书颁发机构**，这是一个支持公钥分发的组织。证书颁发机构会注册一些关于吉姆体育用品店的细节，并授予它一个公钥。然后，它会发送给吉姆体育用品店一个证书，称为**TLS/SSL证书**，该证书上有吉姆体育用品店的公钥，并使用证书颁发机构自己的公钥进行数字签名。通过这种方式，证书颁发机构确认一个特定的公钥确实属于吉姆体育用品店。

理解这个过程中TLS/SSL证书的关键是，虽然你通常不会在你的电脑上存储吉姆体育用品店的公钥，但是认可的证书颁发机构的公钥确实存储在你的浏览器或操作系统中。这些存储在所谓的**根证书**中。

因此，当吉姆体育用品店提供给你它的TLS/SSL证书时，你可以通过浏览器或操作系统中的根证书验证证书颁发机构的数字签名。如果签名有效，你可以相对确定证书上的公钥确实属于吉姆体育用品店。基于此，很容易建立与吉姆体育用品店的安全通信协议。

对于吉姆体育用品店来说，密钥分发现在变得极为简单。不难看出，密钥管理也变得大为简化。吉姆体育用品店不需要存储成千上万的密钥，只需存储一个私钥，该私钥允许它为其SSL证书上的公钥做签名。每当客户访问吉姆体育用品店的网站时，他们可以从这个公钥建立一个安全的通信会话。客户也不需要存储任何信息（除了在他们的操作系统和浏览器中认可的证书颁发机构的公钥）。

**注释：**

[5] 任何试图实现不可否认性的方案，这是我们在第一章讨论的另一个主题，其基础需要涉及数字签名。

## 哈希函数
<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

哈希函数在密码学中无处不在。它们既不是对称方案也不是非对称方案，但属于它们自己的密码学类别。

我们已经在第4章遇到了哈希函数，在创建基于哈希的认证消息时。它们在数字签名的上下文中也很重要，尽管原因略有不同：数字签名通常是在某个（加密的）消息的哈希值上进行的，而不是实际的（加密的）消息。在这一节中，我将提供关于哈希函数的更详细介绍。

让我们开始定义哈希函数。**哈希函数**是任何可以高效计算的函数，它接受任意大小的输入并产生固定长度的输出。

**加密哈希函数**只是一种对密码学应用有用的哈希函数。加密哈希函数的输出通常称为**哈希**、**哈希值**或**消息摘要**。

在密码学的上下文中，“哈希函数”通常指的是加密哈希函数。从现在开始，我将采用这种做法。
一个流行的哈希函数的例子是 **SHA-256**（安全哈希算法256）。无论输入的大小如何（例如，15位、100位或10,000位），这个函数都会产生一个256位的哈希值。下面你可以看到SHA-256函数的一些示例输出。
“Hello”：`185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969`

“52398”：`a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90`

“Cryptography is fun”：`3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c`

所有的输出都是以十六进制格式精确表示的256位（每个十六进制数字可以由四个二进制数字表示）。所以，即使你输入了托尔金的《指环王》一书到SHA-256函数中，输出仍然是256位。

在密码学中，SHA-256等哈希函数被用于各种目的。哈希函数所需的属性真正取决于特定应用的上下文。在密码学中，通常希望哈希函数具有两个主要属性：[6]

1. 抗碰撞性
2. 隐藏性

如果找到两个值$x$和$y$，使得$x \neq y$，但是$H(x) = H(y)$是不可行的，那么哈希函数$H$被称为**抗碰撞性**的。

抗碰撞性哈希函数在例如软件验证中很重要。假设你想下载比特币核心0.21.0版本的Windows发布（一个用于处理比特币网络流量的服务器应用程序）。为了验证软件的合法性，你需要采取的主要步骤如下：

1. 首先，你需要下载并导入一个或多个比特币核心贡献者的公钥到可以验证数字签名的软件中（例如Kleopetra）。你可以在[这里](https://github.com/bitcoin/bitcoin/blob/master/contrib/builder-keys/keys.txt)找到这些公钥。建议你使用多个贡献者的公钥来验证比特币核心软件。
2. 接下来，你需要验证你导入的公钥。至少你应该采取的一个步骤是验证你找到的公钥与在各种其他位置发布的公钥相同。例如，你可能会咨询你导入的公钥所属人的个人网页、Twitter页面或Github页面。通常，这种公钥比较是通过比较公钥的一个简短哈希，即指纹来完成的。
3. 接下来，你需要从他们的[网站](www.bitcoincore.org)下载比特币核心的可执行文件。将会有适用于Linux、Windows和MAC操作系统的包。
4. 接下来，你必须定位两个发布文件。第一个包含了你下载的可执行文件的官方SHA-256哈希，以及所有其他发布包的哈希。另一个发布文件将包含各个贡献者对包含包哈希的发布文件的签名。这两个发布文件应该位于比特币核心网站上。
5. 接下来，您需要在自己的电脑上计算从比特币核心网站下载的可执行文件的SHA-256哈希值。然后，将此结果与官方包哈希值进行比较。两者应该是相同的。6. 最后，您需要验证一个或多个对发布文件的数字签名是否确实对应于您导入的一个或多个公钥（比特币核心的发布不总是由每个人签名）。您可以使用Kleopetra等应用程序来完成这一操作。

这个软件验证过程有两个主要好处。首先，它确保在从比特币核心网站下载时没有传输错误。其次，它确保没有攻击者能够让您下载被修改的恶意代码，无论是通过黑客攻击比特币核心网站还是通过拦截流量。

那么，上述软件验证过程是如何保护免受这些问题影响的呢？

如果您认真验证了您导入的公钥，那么您可以相当确定这些密钥实际上是他们的，并且没有被泄露。鉴于数字签名具有存在性不可伪造性，您知道只有这些贡献者才能在发布文件上的官方包哈希值上做出数字签名。

假设您下载的发布文件上的签名检查无误。您现在可以将您本地计算的Windows可执行文件的哈希值与正确签名的发布文件中包含的哈希值进行比较。正如您所知，SHA-256哈希函数是抗碰撞的，匹配意味着您的可执行文件与官方可执行文件完全相同。

现在让我们转向哈希函数的第二个常见属性：**隐藏性**。任何哈希函数$H$被认为具有隐藏性，如果对于从非常大的范围内随机选择的任何$x$，仅给定$H(x)$时，找到$x$是不可行的。

下面，您可以看到我写的一条消息的SHA-256输出。为了确保足够的随机性，消息在最后包含了一个随机生成的字符串。鉴于SHA-256具有隐藏性，没有人能够解读这条消息。

- `b194221b37fa4cd1cfce15aaef90351d70de17a98ee6225088b523b586c32ded`

但我不会让你们悬念直到SHA-256变得更弱。我写的原始消息如下：

* “这是一个非常随机的消息，或者说有点随机。这个开始部分不是，但我会以一些相对随机的字符结束，以确保消息非常不可预测。XLWz4dVG3BxUWm7zQ9qS”。

哈希函数具有隐藏性的一个常见用途是在密码管理中（抗碰撞性对这个应用也很重要）。任何像Facebook或Google这样的体面的在线账户基础服务都不会直接存储您的密码来管理对您账户的访问。相反，它们只会存储该密码的哈希值。每次您在浏览器上填写密码时，首先会计算一个哈希值。只有该哈希值被发送到服务提供商的服务器，并与后端数据库中存储的哈希值进行比较。隐藏性可以帮助确保攻击者无法从哈希值中恢复它。
通过哈希管理密码，当然，只有当用户真正选择了难以猜测的密码时才有效。隐藏属性假设x是从非常大的范围内随机选择的。选择像“1234”、“mypassword”或你的生日日期这样的密码将不会提供任何真正的安全性。存在长列表的常见密码及其哈希值，攻击者如果获得了你的密码的哈希值，就可以利用这些信息。这类攻击被称为**字典攻击**。如果攻击者知道你的一些个人细节，他们也可能尝试一些有根据的猜测。因此，你总是需要长的、安全的密码（最好是密码管理器中的长随机字符串）。

有时候，一个应用可能需要一个既具有抗碰撞性又具有隐藏性的哈希函数。但肯定不总是需要的。例如，我们讨论的软件验证过程，只要求哈希函数显示出抗碰撞性，隐藏性并不重要。

虽然在密码学中寻求的哈希函数的主要属性是抗碰撞性和隐藏性，在某些应用中也可能需要其他类型的属性。

**注释：**

[6] “隐藏”术语不是通用语言，而是特别引用自Arvind Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller, 和 Steven Goldfeder的作品，*比特币和加密货币技术*，普林斯顿大学出版社（普林斯顿，2016年），第1章。

# RSA密码系统
<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

## 因式分解问题
<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

对于大多数人来说，对称密码学通常相当直观，但非对称密码学通常不是这样。虽然你可能对之前章节提供的高层描述感到舒适，但你可能想知道单向函数到底是什么，以及它们是如何确切用于构建非对称方案的。

在本章中，我将通过深入探讨一个具体示例，即RSA密码系统，来揭开非对称密码学的一些神秘面纱。在第一节中，我将介绍RSA问题所基于的因式分解问题。然后，我将介绍数论中的一些关键结果。在最后一节中，我们将把这些信息整合在一起，以解释RSA问题，以及如何使用它来创建非对称加密方案。

深入讨论这个问题并不容易。它需要介绍相当多的数论定理和命题。但不要让数学吓到你。通过这个讨论将显著提高你对非对称密码学基础的理解，这是值得的投资。

现在让我们首先来看因式分解问题。

___

每当你将两个数相乘，比如$a$和$b$，我们将数$a$和$b$称为**因子**，结果称为**乘积**。尝试将一个数$N$写成两个或更多因子的乘积被称为**因式分解**或**分解**。[1] 你可以称任何需要这样做的问题为**因式分解问题**。

大约2500年前，亚历山大的希腊数学家欧几里得发现了一个关于整数因式分解的关键定理。它通常被称为**唯一因式分解定理**，其内容如下：

**定理1**。每个大于1的整数$N$要么是一个质数，要么可以表示为质数因子的乘积。
这段话的后半部分意味着，你可以取任何一个大于1的非质数整数$N$，并将其表示为质数的乘积。下面是几个非质数整数表示为质因数乘积的例子。
* $18 = 2 \cdot 3 \cdot 3 = 2 \cdot 3^2$
* $84 = 2 \cdot 2 \cdot 3 \cdot 7 = 2^2 \cdot 3 \cdot 7$
* $144 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 3 \cdot 3 = 2^4 \cdot 3^2$

对于上述所有三个整数，计算它们的质因数相对容易，即使你只给定了$N$。你从最小的质数，即2开始，看看整数$N$可以被它除几次。然后你继续测试$N$被3、5、7等的可除性。你继续这个过程，直到你的整数$N$被写为只有质数的乘积。

以整数84为例。下面你可以看到确定其质因数的过程。在每一步，我们取出剩余的最小质因数（在左边）并确定要被分解的剩余项。我们继续，直到剩余项也是一个质数。在每一步，84的当前因式分解在最右边显示。

* 质因数 = 2：剩余项 = 42 	($84 = 2 \cdot 42$)
* 质因数 = 2：剩余项 = 21 	($84 = 2 \cdot 2 \cdot 21$)
* 质因数 = 3：剩余项 = 7 	($84 = 2 \cdot 2 \cdot 3 \cdot 7$)
* 由于7是一个质数，结果是$2 \cdot 2 \cdot 3 \cdot 7$，或$2^2 \cdot 3 \cdot 7$。

假设现在$N$非常大。将$N$分解成其质因数有多困难？

这真的取决于$N$。假设，例如，$N$是50,450,400。虽然这个数字看起来很吓人，但计算并不复杂，可以很容易地手工完成。如上所述，你只需从2开始，然后继续。下面，你可以以类似上述的方式看到这个过程的结果。

* 2: 25,225,200 	($50,450,400 = 2 \cdot 25,225,200$)  
* 2: 12,612,600 	($50,450,400 = 2^2 \cdot 12,612,600$)  
* 2: 6,306,300 	($50,450,400 = 2^3 \cdot 6,306,300$)  
* 2: 3,153,150 	($50,450,400 = 2^4 \cdot 3,153,150$)  
* 2: 1,576,575 	($50,450,400 = 2^5 \cdot 1,576,575$)
* 3: 525,525 ($50,450,400 = 2^5 \cdot 3 \cdot 525,525$)
* 3: 175,175 ($50,450,400 = 2^5 \cdot 3^2 \cdot 175,175$)
* 5: 35,035 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5 \cdot 35,035$)
* 5: 7,007 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7,007$)
* 7: 1,001 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7 \cdot 1,001$)
* 7: 143 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 143$)
* 11: 13 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$)
* 由于13是一个质数，结果是 $2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$。

手工解决这个问题需要一些时间。当然，计算机可以在一小部分秒内完成所有这些工作。实际上，计算机经常甚至可以在一小部分秒内分解极大的整数。

然而，有一些例外。假设我们首先随机选择两个非常大的质数。通常将这些质数标记为 $p$ 和 $q$，我在这里也将采用这种约定。

为了具体说明，假设 $p$ 和 $q$ 都是1024位的质数，并且确实需要至少1024位才能表示（所以第一位必须是1）。所以，例如，37不能是其中一个质数。你当然可以用1024位来表示37。但显然*你不需要*这么多位来表示它。你可以用任何有6位或更多的字符串来表示37。（在6位中，37将被表示为 $100101$）。

重要的是要理解如果按照上述条件选择，$p$ 和 $q$ 有多大。作为一个例子，我在下面选择了一个随机质数，它需要至少1024位来表示。
* 14,752,173,874,503,595,484,930,006,383,670,759,559,764,562,721,397,166,747,289,220,945,457,932,666,751,048,198,854,920,097,085,690,793,755,254,946,188,163,753,506,778,089,706,699,671,722,089,715,624,760,049,594,106,189,662,669,156,149,028,900,805,928,183,585,427,782,974,951,355,515,394,807,209,836,870,484,558,332,897,443,152,653,214,483,870,992,618,171,825,921,582,253,023,974,514,209,142,520,026,807,636,589

假设现在我们随机选择两个质数$p$和$q$，然后将它们相乘得到一个整数$N$。因此，这个整数是一个2048位的数字，它的表示至少需要2048位。它比$p$或$q$要大得多。

假设你只给计算机$N$，并要求它找到$N$的两个1024位的质因数。计算机发现$p$和$q$的概率极小。你可以说，出于所有实际目的，这是不可能的。即使你使用超级计算机或者一网络的超级计算机，情况也是如此。

首先，假设计算机尝试通过循环遍历1024位的数字来解决这个问题，在每种情况下测试它们是否为质数以及它们是否是$N$的因数。那么，要测试的质数集大约是$1.265 \cdot 10^{305}$。[2]

即使你利用地球上所有的计算机尝试以这种方式找到并测试1024位的质数，成功找到$N$的一个质因数的机会也需要一个比宇宙年龄还要长的计算期。[3]

现实中，计算机可以比刚才描述的粗略程序做得更好。存在几种算法，计算机可以应用这些算法更快地进行因式分解。然而，重点是，即使使用这些更高效的算法，计算机的任务仍然是计算上不可行的。

重要的是，刚才描述的条件下因式分解的难度基于这样一个假设：不存在用于计算质因数的计算上高效的算法。我们实际上不能证明一个高效的算法不存在。尽管如此，这个假设非常合理：尽管经过数百年的广泛努力，我们还没有找到这样一个计算上高效的算法。

因此，在某些情况下，因式分解问题可以合理地假设为一个难题。具体来说，当$p$和$q$是非常大的质数时，它们的乘积$N$不难计算；但仅给定$N$进行因式分解实际上是不可能的。

**注释：**

[1] 因式分解也可以用于处理除了数字之外的其他类型的数学对象。例如，它可以用于因式分解多项式表达式，如$x^2 - 2x + 1$。在我们的讨论中，我们将只关注数字的因式分解，特别是整数。
根据**素数定理**，小于或等于 $N$ 的素数数量大约是 $N/\ln(N)$。这意味着你可以通过以下方式近似计算长度为1024位的素数数量：
$$ \frac{2^{1024}}{\ln(2^{1024})} - \frac{2^{1023}}{\ln(2^{1023})} $$

...其结果大约等于 $1.265 \times 10^{305}$。

对于离散对数问题也是如此。因此，非对称构造使用的密钥比对称密码构造的密钥要大得多。

## 数论结果
<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

不幸的是，因式分解问题不能直接用于非对称密码方案。然而，我们可以使用一个更复杂但相关的问题来实现这一效果：RSA问题。

要理解RSA问题，我们需要理解数论中的一些定理和命题。这些内容在本节的三个小节中介绍：(1) N的阶，(2) 模N的可逆性，和 (3) 欧拉定理。

这三个小节中的一些材料已经在*第3章*中介绍过。但我将在这里为方便起见重新陈述这些材料。

### N的阶

如果整数 $a$ 与整数 $N$ 是**互质**或**相对质数**，即它们之间的最大公约数为1。虽然按照惯例1不是质数，但它是每个整数的互质数（-1也是）。

例如，考虑当 $a = 18$ 和 $N = 37$ 的情况。这些显然是互质的。同时能被18和37整除的最大整数是1。相比之下，考虑当 $a = 42$ 和 $N = 16$ 的情况。这些显然不是互质的。两个数都能被2整除，这大于1。

我们现在可以这样定义 $N$ 的阶。假设 $N$ 是一个大于1的整数。那么，**N的阶**就是所有与 $N$ 互质的数的数量，对于每个互质数 $a$，满足以下条件：$1 \leq a < N$。

例如，如果 $N = 12$，那么1, 5, 7, 和 11是唯一满足上述要求的互质数。因此，12的阶等于4。

假设 $N$ 是一个质数。那么任何小于 $N$ 但大于或等于1的整数都与它互质。这包括以下集合中的所有元素：$\{1,2,3,….,N - 1\}$。因此，当 $N$ 是质数时，N的阶是 $N - 1$。这在命题1中有陈述，其中 $\phi(N)$ 表示 $N$ 的阶。

**命题 1**。当 $N$ 是质数时，$\phi(N) = N - 1$
假设 $N$ 不是质数。那么，你可以使用**欧拉Φ函数**来计算它的阶。虽然计算一个小整数的阶相对直接，但对于较大的整数，欧拉Φ函数变得特别重要。欧拉Φ函数的命题如下所述。
**定理 2**。设 $N = p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_i^{e_i} \cdot \ldots \cdot p_n^{e_n}$，其中集合 $\{p_i\}$ 包含了 $N$ 的所有不同质因数，每个 $e_i$ 表示质因数 $p_i$ 在 $N$ 中出现的次数。那么，

$$\phi(N) = p_1^{e_1 - 1} \cdot (p_1 - 1) \cdot p_2^{e_2 - 1} \cdot (p_2 - 1) \cdot \ldots \cdot p_n^{e_n - 1} \cdot (p_n - 1)$$

**定理 2** 显示了一旦你将任何非质数 $N$ 分解成其不同的质因数，计算 $N$ 的阶就变得简单了。

例如，假设 $N = 270$。这显然不是一个质数。将 $N$ 分解成其质因数得到表达式：$2 \cdot 3^3 \cdot 5$。根据欧拉Φ函数，$N$ 的阶如下：

$$\phi(N) = 2^{1 - 1} \cdot (2 - 1) + 3^{3 - 1} \cdot (3 - 1) + 5^{1 - 1} \cdot (5 - 1) = 1 \cdot 1 + 9 \cdot 2 + 1 \cdot 4 = 1 + 18 + 4 = 23$$

接下来假设 $N$ 是两个质数 $p$ 和 $q$ 的乘积。那么，上述**定理 2** 表明 $N$ 的阶如下：

$$p^{1 - 1} \cdot (p - 1) \cdot q^{1 - 1} \cdot (q - 1) = (p - 1) \cdot (q - 1)$$

这是解决 RSA 问题的关键结果，如下面的**命题 2**所述。

**命题 2**。如果 $N$ 是两个质数 $p$ 和 $q$ 的乘积，那么 $N$ 的阶是乘积 $(p - 1) \cdot (q - 1)$。

举例来说，假设 $N = 119$。这个整数可以分解为两个质数，即 7 和 17。因此，欧拉Φ函数表明 119 的阶如下：

$$\phi(119) = (7 - 1) \cdot (17 - 1) = 6 \cdot 16 = 96$$

换句话说，整数 119 在 1 到 119 的范围内有 96 个互质数。实际上，这个集合包括了从 1 到 119 的所有整数，这些整数不是 7 或 17 的倍数。
从这里开始，让我们用 $C_N$ 表示决定 $N$ 阶的互质集合。以 $N = 119$ 为例，集合 $C_{119}$ 太大而无法完全列出。但是其中的一些元素如下：
$$C_{119} = \{1, 2, \dots 6, 8 \dots 13, 15, 16, 18, \dots 33, 35 \dots 96\}$$

### 模 N 的可逆性

我们可以说，如果存在至少一个整数 $b$ 使得 $a \cdot b \mod N = 1 \mod N$，那么整数 $a$ 是**模 N 可逆的**。任何这样的整数 $b$ 被称为 $a$ 的**逆元**（或**乘法逆元**），给定模 $N$ 的约简。

假设，例如，$a = 5$ 且 $N = 11$。有许多整数可以乘以 5，使得 $5 \cdot b \mod 11 = 1 \mod 11$。考虑，例如，整数 20 和 31。很容易看出，这两个整数都是 5 在模 11 约简下的逆元。

* $5 \cdot 20 \mod 11 = 100 \mod 11 = 1 \mod 11$
* $5 \cdot 31 \mod 11 = 155 \mod 11 = 1 \mod 11$

虽然 5 在模 11 约简下有许多逆元，但你可以证明只存在一个小于 11 的正逆元。实际上，这不仅仅是我们特定例子的情况，而是一个普遍结果。

**命题 3**。如果整数 $a$ 是模 $N$ 可逆的，那么必须有一个且仅有一个正逆元小于 $N$。（所以，这个唯一的 $a$ 的逆元必须来自集合 $\{1, \dots, N - 1\}$）。

让我们将 **命题 3** 中 $a$ 的唯一逆元表示为 $a^{-1}$。对于 $a = 5$ 且 $N = 11$ 的情况，你可以看到 $a^{-1} = 9$，因为 $5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$。

注意，在我们的例子中，你也可以通过简单地将 $a$ 的任何其他逆元通过模 11 约简来获得 $a^{-1}$ 的值 9。例如，$20 \mod 11 = 31 \mod 11 = 9 \mod 11$。所以，每当一个整数 $a > N$ 是模 $N$ 可逆的，那么 $a \mod N$ 也必须是模 $N$ 可逆的。

并不是必然的情况是 $a$ 的逆元存在模 $N$ 约简。例如，假设 $a = 2$ 且 $N = 8$。不存在任何 $b$，或者具体来说，任何 $a^{-1}$，使得 $2 \cdot b \mod 8 = 1 \mod 8$。这是因为任何 $b$ 的值总是产生 2 的倍数，所以不可能通过 8 除以任何数得到余数等于 1。
我们如何确切地知道某个整数$a$对于给定的$N$是否有逆元？正如您在上面的例子中注意到的，2和8之间的最大公约数大于1，即为2。这实际上说明了以下一般结果：
**命题4**。整数$a$在模$N$下的逆元存在，并且特别是存在一个唯一的正逆元小于$N$，当且仅当$a$和$N$之间的最大公约数为1（即，如果它们是互质的）。

对于当$a = 5$且$N = 11$的情况，我们得出$a^{-1} = 9$，因为$5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$。重要的是要注意，反向也是成立的。也就是说，当$a = 9$且$N = 11$时，$a^{-1} = 5$。

### 欧拉定理

在讨论RSA问题之前，我们需要理解另一个关键定理，即**欧拉定理**。它声明如下：

**定理3**。假设两个整数$a$和$N$是互质的。那么，$a^{\phi(N)} \mod N = 1 \mod N$。

这是一个了不起的结果，但一开始可能有点令人困惑。让我们通过一个例子来理解它。

假设$a = 5$且$N = 7$。这些确实是欧拉定理所要求的互质数。我们知道7的阶等于6，因为7是一个质数（见**命题1**）。

欧拉定理现在声明的是$5^6 \mod 7$必须等于$1 \mod 7$。以下是显示这确实是真实的计算。

* $5^6 \mod 7 = 15,625 \mod 7 = 1 \mod N$

整数7除以15,624共计2,233次。因此，16,625除以7的余数是1。

接下来，使用欧拉的Phi函数，**定理2**，你可以推导出下面的**命题5**。

**命题5**。对于任何正整数$a$和$b$，$\phi(a \cdot b) = \phi(a) \cdot \phi(b)$。

我们不会展示为什么会这样。但只需注意，您已经通过$\phi(p \cdot q) = \phi(p) \cdot \phi(q) = (p - 1) \cdot (q - 1)$的事实看到了这个命题的证据，当$p$和$q$是质数时，如**命题2**中所述。

欧拉定理与**命题5**结合有重要的含义。例如，在下面的表达式中，看看发生了什么，其中$a$和$N$是互质的。

* $a^{2 \cdot \phi(N)} \mod N = a^{\phi(N)} \cdot a^{\phi(N)} \mod N = 1 \cdot 1 \mod N = 1 \mod N$
* $a^{\phi(N) + 1} \mod N = a^{\phi(N)} \cdot a^1 \mod N = 1 \cdot a^1 \mod N = a \mod N$
* $a^{8 \cdot \phi(N) + 3} \mod N = a^{8 \cdot \phi(N)} \cdot a^3 \mod N = 1 \cdot a^3 \mod N = a^3 \mod N$

因此，欧拉定理和**命题 5**的结合允许我们简单地计算许多表达式。一般来说，我们可以将这个见解总结为**命题 6**。

**命题 6**。$a^x \mod N = a^{x \mod \phi(N)}$

现在我们必须在一个棘手的最后步骤中把所有东西整合起来。

就像 $N$ 有一个阶 $\phi(N)$，它包括集合 $C_N$ 的元素，我们知道整数 $\phi(N)$ 必须反过来也有一个阶和一组互质数。设 $\phi(N) = R$。然后我们知道 $\phi(R)$ 也有一个值和一组互质数 $C_R$。

假设我们现在从集合 $C_R$ 中选择一个整数 $e$。我们从**命题 3** 知道这个整数 $e$ 只有一个唯一的正逆小于 $R$。也就是说，$e$ 有一个来自集合 $C_R$ 的唯一逆。我们称这个逆为 $d$。根据逆的定义，这意味着 $e \cdot d = 1 \mod R$。

我们可以使用这个结果对我们原始的整数 $N$ 做出声明。这总结在**命题 7** 中。

**命题 7**。假设 $e \cdot d \mod \phi(N) = 1 \mod \phi(N)$。那么对于集合 $C_N$ 的任何元素 $a$，必须满足 $a^{e \cdot d \mod \phi(N)} = a^{1 \mod \phi(N)} = a \mod N$。

我们现在拥有了陈述 RSA 问题所需的所有数论结果。

## RSA 密码系统
<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>

我们现在准备好陈述 RSA 问题了。假设你创建了一组变量，包括 $p$、$q$、$N$、$\phi(N)$、$e$、$d$ 和 $y$。称这组为 $\Pi$。它是这样创建的：

1. 生成两个大小相等的随机质数 $p$ 和 $q$ 并计算它们的乘积 $N$。
2. 通过以下乘积计算 $N$ 的阶，$\phi(N)$：$(p - 1) \cdot (q - 1)$。
3. 选择一个大于 2 的 $e$，使其小于并且与 $\phi(N)$ 互质。
4. 通过设置 $e \cdot d \mod \phi(N) = 1$ 来计算 $d$。
5. 选择一个小于并且与 $N$ 互质的随机值 $y$。
RSA问题包括找到一个$x$，使得$x^e = y$，同时只给出关于$\Pi$的一部分信息，即变量$N$、$e$和$y$。当$p$和$q$非常大时，通常建议它们的大小为1024位，RSA问题被认为是难解的。鉴于前述讨论，你现在可以看到为什么会这样。

当$x^e \mod N = y \mod N$时，计算$x$的一个简单方法就是直接计算$y^d \mod N$。我们知道$y^d \mod N = x \mod N$，通过以下计算得出：

$$ y^d \mod N = x^{e \cdot d} \mod N = x^{e \cdot d \mod \phi(N)} \mod N = x^{1 \mod \phi(N)} \mod N = x \mod N. $$

问题在于我们不知道$d$的值，因为问题中没有给出。因此，我们不能直接计算$y^d \mod N$来得出$x \mod N$。

然而，我们可能能够间接地从$N$的阶，$\phi(N)$，计算出$d$，因为我们知道$e \cdot d \mod \phi(N) = 1 \mod \phi(N)$。但是根据假设，问题也没有给出$\phi(N)$的值。

最后，阶可以通过质因数$p$和$q$间接计算，这样我们最终可以计算出$d$。但是根据假设，$p$和$q$的值也没有提供给我们。

严格来说，即使在RSA问题中的因式分解问题很难，我们也不能证明RSA问题也是难的。可能还有其他解决RSA问题的方法，而不仅仅是通过因式分解。然而，通常接受和假设的是，如果RSA问题中的因式分解问题很难，那么RSA问题本身也是难的。

如果RSA问题确实很难，那么它就产生了一个带陷门的单向函数。这里的函数是$f(g) = g^e \mod N$。有了$f(g)$的知识，任何人都可以轻松计算出特定的$g = x$的值$y$。然而，仅仅通过知道值$y$和函数$f(g)$，实际上是不可能计算出特定的值$x$。例外情况是当你被给予一个信息$d$，即陷门。在那种情况下，你可以简单地计算$y^d$来得到$x$。

让我们通过一个具体的例子来说明RSA问题。我不能选择一个在上述条件下被认为是难解的RSA问题，因为数字会很笨重。相反，这个例子只是为了说明RSA问题通常是如何工作的。

首先，假设你选择了两个随机质数13和31。所以$p = 13$和$q = 31$。这两个质数的乘积$N$等于403。我们可以轻松计算出403的阶。它等于$(13 - 1) \cdot (31 - 1) = 360$。
接下来，按照RSA问题的第3步，我们需要为360选择一个大于2且小于360的互质数。我们不必随机选择这个值。假设我们选择了103。由于它与360的最大公约数为1，因此103是360的一个互质数。

第4步现在要求我们计算一个值$d$，使得$103 \cdot d \mod 360 = 1$。当$N$的值很大时，手工完成这项任务并不容易。这需要我们使用一种称为**扩展欧几里得算法**的过程。

虽然我在这里没有展示这个过程，但当$e = 103$时，它得出的值是7。你可以验证一下，值对103和7确实满足一般条件$e \cdot d \mod \phi(n) = 1$，通过下面的计算可以验证。

* $103 \cdot 7 \mod 360 = 721 \mod 360 = 1 \mod 360$

重要的是，根据*命题4*，我们知道在1到360之间，没有其他整数$d$会产生$103 \cdot d = 1 \mod 360$的结果。此外，该命题意味着，为$e$选择一个不同的值，将产生一个不同的、唯一的$d$值。

在RSA问题的第5步中，我们必须选择一个较小的403的互质数正整数$y$。假设我们设置$y = 2^{103}$。2的103次方的结果如下。

* $2^{103} \mod 403 = 10,141,204,801,825,835,211,973,625,643,008 \mod 403 = 349 \mod 403$

在这个特定示例中的RSA问题现在如下：你被提供了$N = 403$、$e = 103$和$y = 349 \mod 403$。你现在必须计算$x$，使得$x^{103} = 349 \mod 403$。也就是说，你必须找到103次方之前的原始值是2。

如果我们知道$d = 7$，计算$x$将会很容易（至少对于计算机来说）。在这种情况下，你可以如下确定$x$。

* $x = y^7 \mod 403 = 349^7 \mod 403 = 630,634,881,591,804,949 \mod 403 = 2 \mod 403$

问题在于，你没有被提供$d = 7$的信息。当然，你可以从$103 \cdot d = 1 \mod 360$的事实中计算出$d$。问题是，你也没有被告知$N = 360$的顺序。最后，你也可以通过计算以下乘积来计算403的顺序：$(p - 1) \cdot (q - 1)$。但你也没有被告知$p = 13$和$q = 31$。

当然，对于这个例子，计算机仍然可以相对容易地解决RSA问题，因为涉及的质数不大。但是，当质数变得非常大时，它面临着一个几乎不可能完成的任务。
我们现在已经介绍了RSA问题，以及在某些条件下它变得困难的一系列条件和背后的数学原理。这一切如何帮助我们理解非对称加密呢？具体来说，我们如何将RSA问题在特定条件下的难度转化为一个加密方案或数字签名方案呢？

一种方法是直接以RSA问题为基础构建方案。例如，假设你按照RSA问题中描述的生成了一组变量$\Pi$，并确保$p$和$q$足够大。你将你的公钥设置为$(N, e)$并与世界分享这些信息。如上所述，你保密$p$、$q$、$\phi(n)$和$d$的值。实际上，$d$是你的私钥。

任何想要给你发送消息$m$（$m$是$C_N$的一个元素）的人都可以简单地这样加密：$c = m^e \mod N$。（这里的密文$c$等同于RSA问题中的$y$值。）你可以通过计算$c^d \mod N$来轻松解密这条消息。

你也许会尝试以同样的方式创建一个数字签名方案。假设你想给某人发送一条带有数字签名$S$的消息$m$。你可以简单地设置$S = m^d \mod N$，并将$(m,S)$对发送给接收者。任何人都可以通过检查$S^e \mod N = m \mod N$来验证数字签名。然而，任何攻击者在不拥有$d$的情况下，都很难为一条消息创建有效的$S$。

不幸的是，将本身就是一个难题的RSA问题转化为加密方案并不是这么直接。对于直接的加密方案，你只能选择$N$的互质数作为你的消息。这并不会留给我们太多可能的消息，肯定不足以进行标准通信。此外，这些消息必须被随机选择。这似乎有些不切实际。最后，任何被选择两次的消息都会产生完全相同的密文。这在任何加密方案中都极其不受欢迎，并且不符合加密中任何严格的现代安全标准。

对于我们直接的数字签名方案来说，问题变得更糟。按照目前的情况，任何攻击者都可以通过首先选择$N$的一个互质数作为签名，然后计算相应的原始消息来轻松伪造数字签名。这显然违反了存在性不可伪造的要求。

尽管如此，通过增加一点巧妙的复杂性，RSA问题可以用来创建一个安全的公钥加密方案以及一个安全的数字签名方案。我们在这里不会详细介绍这些构建。[4] 重要的是，这种额外的复杂性并不改变这些方案所基于的基本RSA问题。

**注释：**

[4] 例如，参见Jonathan Katz和Yehuda Lindell，《现代密码学导论》，CRC出版社（佛罗里达州博卡拉顿：2015年），第410-32页关于RSA加密，以及第444-41页关于RSA数字签名。