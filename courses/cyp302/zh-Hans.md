---
name: 形式密码学入门
goal: 深入浅出地介绍密码学的科学与实践。
objectives: 

  - 探索 Beale 密码和现代密码方法，了解密码学的基本和历史概念。
  - 深入研究数论、群和场，掌握密码学的关键数学概念。
  - 学习 RC4 流密码和 128 位密钥的 AES，了解对称加密算法。
  - 研究 RSA 密码系统、密钥分配和散列函数，探索非对称密码学。

---
# 深入了解密码学

在密码学教育中，很难找到许多能提供良好中间立场的教材。

一方面，有一些冗长、正式的论文，只有那些在数学、逻辑学或其他正式学科方面有深厚背景的人才能读懂。另一方面，也有一些非常高层次的介绍，对于任何至少有点好奇心的人来说，确实隐藏了太多的细节。

这本密码学入门书试图抓住中间地带。虽然它对任何刚接触密码学的人来说都具有一定的挑战性和详尽性，但它并不是典型的基础性论文。

+++
# 导言

<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## 简要说明

<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

本书深入浅出地介绍了密码学的科学与实践。在可能的情况下，它侧重于概念性而非形式性的材料阐述。

> 本课程基于 [JWBurgers's repo](https://github.com/JWBurgers/An_Introduction_to_Cryptography)。版权归他所有。内容尚未完成，仅在此展示如果 JWBurger 同意，我们可以如何将其整合。
### 动机和目标

在密码学教育中，很难找到许多能提供良好中间立场的教材。

一方面，有一些冗长、正式的论文，只有那些在数学、逻辑学或其他正式学科方面有深厚背景的人才能读懂。另一方面，也有一些非常高层次的介绍，对于任何至少有点好奇心的人来说，确实隐藏了太多的细节。

这本密码学入门书试图抓住中间地带。虽然它对任何刚接触密码学的人来说都具有一定的挑战性和详尽性，但它并不是典型的基础性论文。

### 目标受众

从开发人员到求知欲旺盛的读者，本书对任何希望深入了解密码学的人都非常有用。如果你的目标是掌握密码学领域，那么本书也是一个很好的起点。

### 阅读指南

本书目前包含七章："什么是密码学？"（第 1 章）、"密码学的数学基础 I"（第 2 章）、"密码学的数学基础 II"（第 3 章）、"对称密码学"（第 4 章）、"RC4 和 AES"（第 5 章）、"非对称密码学"（第 6 章）和 "RSA 密码系统"（第 7 章）。最后一章 "实践中的密码学 "仍将添加。该章将重点介绍各种加密应用，包括传输层安全、洋葱路由和比特币的价值交换系统。

除非你有很强的数学背景，否则数论可能是本书中最难的主题。我在第 3 章对其进行了概述，在第 5 章对 AES 和第 7 章对 RSA 密码系统的阐述中也有涉及。

如果你真的对书中这些部分的形式细节感到吃力，我建议你第一遍就对它们进行高水平的阅读。

### 致谢

对这本书影响最大的是乔纳森-卡茨（Jonathan Katz）和耶胡达-林德尔（Yehuda Lindell）的《现代密码学入门》（_Introduction to Modern Cryptography_），CRC出版社（佛罗里达州博卡拉顿），2015年。Coursera 上有一门名为 "密码学 "的配套课程。

对编写本书概述有帮助的其他主要资料来源有：Simon Singh，_The Code Book_，Fourth Estate（伦敦，1999 年）；Christof Paar 和 Jan Pelzl，_Understanding Cryptography_，Springer（海德堡，2010 年）和[根据 Paar 的书编写的课程 "密码学导论"](https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg)；以及 Bruce Schneier，Applied Cryptography，2nd edn，2015 年（印第安纳波利斯：John Wiley & Sons）。

我只会引用我从这些来源获得的非常具体的信息和结果，但希望在此向他们致谢。

如果读者在阅读完这本介绍后还想了解更高级的密码学知识，我强烈推荐卡茨和林德尔的这本书。卡茨在 Coursera 上的课程比这本书更通俗易懂。

### 会费

请查看 [资源库中的贡献文件](https://github.com/JWBurgers/An_Introduction_to_Cryptography/blob/master/Contributions.md) 了解如何支持该项目的一些指导原则。

### 符号

**关键术语：**

入门指南中的关键术语用黑体表示。例如，将 Rijndael 密码作为关键术语介绍如下： **Rijndael 密码**。

关键术语均有明确定义，除非它们是专有名词或其含义在讨论中显而易见。

任何定义通常都是在引入关键术语时给出的，但有时将定义留到后面更方便。

**强调的单词和短语：**

单词和短语用斜体强调。例如，"请记住您的密码 "短语如下： *记住您的密码*。

**正式符号：**

正式符号主要涉及变量、随机变量和集合。


- 变量：通常只用小写字母表示（如 "x "或 "y"）。有时为了清楚起见，也会大写（如 "M "或 "K"）。
- 随机变量：这些变量总是用大写字母表示（如 "X "或 "Y"）。
- 集合：总是用粗体大写字母表示（如 **S**）

# 什么是密码学？

<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

## 比厄密码

<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>

让我们从密码学历史上最迷人、最有趣的事件之一：比厄密码开始，探究密码学领域。[1]

在我看来，比厄密码的故事更像是虚构而非真实。但据说事情是这样的

1820 年和 1822 年的冬天，一个名叫托马斯-J-比厄（Thomas J. Beale）的人住在弗吉尼亚州林奇堡罗伯特-莫里斯（Robert Morriss）开的一家旅馆里。在比厄第二次住宿结束时，他交给莫里斯一个装有贵重文件的铁盒子，让其妥善保管。

几个月后，莫里斯收到了比厄于 1822 年 5 月 9 日写给他的一封信。信中强调了铁盒内物品的巨大价值，并对莫里斯做了一些指示：如果比厄或他的任何同伙都没有来认领铁盒，那么他就应该在写信之日起十年后（即 1832 年 5 月 9 日）打开铁盒。盒子里的一些文件是用正常文字书写的。然而，其他一些文件 "没有钥匙的帮助是无法理解的"。这把 "钥匙 "将于 1832 年 6 月由比厄的一位不愿透露姓名的朋友交给莫里斯。

尽管有明确的指示，莫里斯还是没有在 1832 年 5 月打开盒子，而比厄的神秘朋友也没有在同年 6 月出现。直到 1845 年，旅馆老板才最终决定打开盒子。莫里斯在其中发现了一张纸条，上面解释了比厄和他的同伙是如何在西部发现金银财宝，并将其与一些珠宝一起埋藏起来保管的。此外，盒子里还有三**密文**：即用密码写成的文字，需要**密钥**或秘密，以及相应的算法才能解开。解锁密文的过程称为**解密**，而锁定密文的过程称为**加密**。(如第 3 章所述，密码一词有多种含义。在 "比厄密码 "这个名称中，它是密文的简称）。

莫里斯在铁盒子里发现的三份密码文本，每份都由一串用逗号隔开的数字组成。根据比厄的说明，这些密文分别提供了宝藏的位置、宝藏的内容以及宝藏合法继承人的姓名及其份额清单（后一信息与比厄及其同伙从未前来认领铁盒有关）。

莫里斯尝试解密这三个密码文本长达二十年之久。如果有了密钥，这本来是很容易做到的。但莫里斯没有密钥，他试图恢复原文（或密码学中通常所说的**纯文本**）的努力没有成功。

1862 年，莫里斯在生命即将结束时将盒子转交给了一位朋友。这位朋友随后于 1885 年用 J.B. Ward 的笔名出版了一本小册子。这本小册子描述了盒子的（所谓）历史、三个密码文本以及他找到的第二个密码文本的解法。(显然，每个密码文本都有一个密钥，而不是比厄最初在给莫里斯的信中所说的一个密钥适用于所有三个密码文本）。

您可以在下面的*图 2* 中看到第二个密码文本。[2] 密文的关键是美国的《独立宣言》。解密过程可归结为应用以下两条规则：


- 对于密文中的任意数字 n，找出《美国独立宣言》中的第 n 个单词
- 用找到的单词的第一个字母替换数字 n

*图 1：Beale 密码 No.2*

![Figure 1: Beale cipher no 2.](assets/Figure1-1.webp "Figure 1: Beale cipher no. 2")

例如，第二个密码文本的第一个数字是 115。独立宣言》的第 115 个单词是 "instituted"，因此明文的第一个字母是 "i"。密码文本没有直接显示单词间距和大小写。但在解密前几个单词后，可以顺理成章地推断出明文的第一个单词就是 "I"。(明文开头是 "我在贝德福德郡存款"）。

解密后，第二条信息提供了宝藏的详细内容（金、银和珠宝），并暗示宝藏被埋在铁锅里，并用石头覆盖在贝德福德郡（弗吉尼亚州）。人们喜欢神秘的东西，因此人们花费了大量精力破解另外两个比厄密码，尤其是描述宝藏地点的密码。就连一些著名的密码专家也对它们跃跃欲试。然而，到目前为止，还没有人能够破解另外两个密码。

**注：**

[1] 关于这个故事的精彩摘要，见 Simon Singh，*The Code Book*，Fourth Estate（伦敦，1999 年），第 82-99 页。安德鲁-艾伦（Andrew Allen）于 2010 年将这个故事拍成了一部短片。您可在其网站](http://www.thomasbealecipher.com/) 上找到这部电影《托马斯-比厄密码》。

[2] 该图片可在维基百科比厄密码页面上找到。

## 现代密码学

<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

像比厄密码这样丰富多彩的故事是我们大多数人对密码学的印象。然而，现代密码学至少在四个重要方面不同于这些历史典范。

首先，密码学历来只关注**秘密**（或保密性）。[3] 密码文本的创建是为了确保只有特定方能获知明文中的信息，如 Beale 密码。为了使加密方案很好地实现这一目的，只有在拥有密钥的情况下才能解密密文。

现代密码学关注的主题比保密性更广泛。这些主题主要包括：(1) **信息完整性**--即确保信息未被更改；(2) **信息真实性**--即确保信息确实来自某个特定的发送者；以及 (3) **不可抵赖性**--即确保发送者事后无法虚假地否认她发送了信息。[4]

因此，需要牢记的一个重要区别是**加密方案**和**加密方案**。加密方案只涉及保密问题。虽然加密方案是一种加密方案，但情况并非如此。加密方案还可以服务于密码学的其他主题，包括完整性、真实性和不可抵赖性。

完整性和真实性与保密性同样重要。如果不能保证通信的完整性和真实性，我们的现代通信系统就无法正常运行。不可抵赖性也是一个重要问题，例如数字合约，但在密码应用中，对不可抵赖性的需求不如保密性、完整性和真实性那么普遍。

其次，经典加密方案（如比厄密码）总是涉及一个密钥，由所有相关方共享。然而，许多现代加密方案不仅涉及一把密钥，而且涉及两把密钥：一把**私钥**和一把**公钥**。前者在任何应用中都应保持私密，而后者通常是公共知识（因此，它们各自的名称）。在加密领域，公钥可用于加密信息，而私钥可用于解密。

密码学的一个分支涉及各方共享一个密钥的方案，称为**对称密码学**。这种方案中的单一密钥通常称为**私人密钥**（或秘密密钥）。密码学的另一个分支是**非对称密码学**，它处理需要一对私人-公开密钥的方案。这两个分支有时也分别称为**私钥密码学**和**公钥密码学**（不过这可能会引起混淆，因为公钥密码方案也有私钥）。

20 世纪 70 年代末非对称密码学的出现是密码学历史上最重要的事件之一。没有它，我们的大多数现代通信系统，包括比特币，都不可能实现，或者至少是非常不切实际。

重要的是，现代密码学并不只研究对称和非对称密钥密码方案（尽管这涵盖了该领域的大部分内容）。例如，密码学还涉及散列函数和伪随机数生成器，你可以在这些基元上构建与对称或非对称密钥密码学无关的应用。

第三，经典加密方案，如 Beale 密码中使用的方案，与其说是科学，不如说是艺术。人们对其安全性的认识主要基于对其复杂性的直觉。当发现新的攻击时，通常会对其进行修补，如果攻击特别严重，则会完全放弃。然而，现代密码学是一门严谨的科学，它采用正规的数学方法来开发和分析密码方案。[5]

具体来说，现代密码学的核心是形式上的**安全证明**。任何加密方案的安全性证明都分为三个步骤：

1.	安全的**加密定义**，即一组安全目标和攻击者构成的威胁。

2.	关于方案计算复杂性的数学假设声明。例如，密码方案可能包含一个伪随机数生成器。虽然我们无法证明它们的存在，但可以假设它们确实存在。

3.	在安全的形式概念和任何数学假设的基础上，对方案的安全**进行数学**证明的阐述。

第四，密码学在历史上主要用于军事领域，而在数字时代，它已经渗透到我们的日常活动中。无论是网上银行、在社交媒体上发帖、用信用卡从亚马逊购买商品，还是给朋友比特币小费，密码学都是我们数字时代的必要条件。

鉴于现代密码学的上述四个方面，我们可以将现代**密码学**描述为一门科学，它涉及密码方案的正式开发和分析，以确保数字信息免受对抗性攻击。[6] 这里的安全性应广义地理解为防止破坏通信的保密性、完整性、认证性和/或不可否认性的攻击。

密码学最好被视为**网络安全**的一个分支学科，它关注的是防止计算机系统被盗、破坏和滥用。请注意，许多网络安全问题与密码学几乎没有联系或仅有部分联系。

例如，如果一家公司在本地安装了昂贵的服务器，他们可能会担心如何保护这些硬件免遭盗窃和损坏。虽然这是一个网络安全问题，但与密码学关系不大。

再比如，**网络钓鱼攻击**是当今时代的一个常见问题。这些攻击试图通过电子邮件或其他信息媒介欺骗人们，让他们放弃密码或信用卡号等敏感信息。虽然密码学可以在一定程度上帮助解决网络钓鱼攻击问题，但一个全面的方法不仅仅需要使用一些密码学。

**注：**

[3] 确切地说，加密方案的重要应用一直与保密有关。例如，孩子们经常使用简单的加密算法来 "消遣"。在这种情况下，保密性其实并不重要。

[4] Bruce Schneier, *Applied Cryptography*, 2nd edn, 2015 (Indianapolis, IN: John Wiley & Sons), p. 2.

[5] 参见 Jonathan Katz 和 Yehuda Lindell，《现代密码学入门》*，CRC Press（佛罗里达州博卡拉顿：2015 年），特别是第 16-23 页的精彩描述。

[6] 参阅 Katz 和 Lindell，同上，第 3 页。 我认为他们的描述有一些问题，因此在此提出与他们的说法略有不同的版本。

## 开放式通信

<chapterId>cb23d0a6-ba9a-5dc6-a55a-258405ae4117</chapterId>

现代密码学旨在为**开放的通信**环境提供安全保证。如果我们的通信渠道保护得非常好，窃听者没有机会篡改甚至只是观察我们的信息，那么密码学就是多余的。然而，我们的大多数通信渠道都很难得到如此周密的保护。

现代世界的通信骨干是一个庞大的光缆网络。在现代家庭中，打电话、看电视和浏览网页一般都要依靠这个光缆网络（一小部分可能纯粹依靠卫星）。诚然，您家中可能有不同的数据连接，如同轴电缆、（非对称）数字用户线路和光纤电缆。但是，至少在发达国家，这些不同的数据媒介很快就会在你家外面连接到连接全球的庞大光缆网络中的一个节点。美国和澳大利亚等发达国家的一些偏远地区除外，在这些地区，数据通信仍可能通过传统的铜质电话线进行长距离传输。

要防止潜在的攻击者通过物理方式访问这个电缆网络及其支持性基础设施是不可能的。事实上，我们已经知道，我们的大部分数据都被各种国家情报机构在互联网的关键路口截获。

大规模的数据监控需要强大的对手（如国家情报机构），而仅有少量资源的攻击者却可以轻易地尝试在更小的范围内进行窥探。虽然这可能发生在窃听电线的层面上，但仅仅截获无线通信要容易得多。

无论是在家里、办公室还是在咖啡馆，我们的大部分本地网络数据现在都是通过无线电波传输到一体式路由器上的无线接入点，而不是通过物理电缆。因此，攻击者只需要很少的资源就能拦截你的任何本地流量。这一点尤其令人担忧，因为大多数人都很少保护本地网络中传输的数据。此外，潜在攻击者还可以瞄准我们的移动宽带连接，如 3G、4G 和 5G。所有这些无线通信都很容易成为攻击者的目标。

因此，通过保护通信渠道来保守通信秘密的想法，对于现代世界的许多人来说，是一种无可救药的妄想。我们所知道的一切都让我们产生了严重的偏执：你应该永远假定有人在监听。而密码学是我们在现代环境中获得任何安全保障的主要工具。

**注：**

[7] 例如，见 Olga Khazan，"The creepy, long-standing practice of undersea cable tapping"，*The Atlantic*，2013 年 7 月 16 日（见 [The Atlantic](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/)）。

# 密码学数学基础 1

<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

## 随机变量

<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

密码学依赖于数学。如果你想对密码学有更深入的了解，你就必须对数学运用自如。

本章介绍了学习密码学过程中会遇到的大部分基本数学知识。主题包括随机变量、模运算、XOR 运算和伪随机性。要想不肤浅地理解密码学，就必须掌握这些章节的内容。

下一节讨论的是数论，它更具挑战性。

### 随机变量

随机变量通常用非粗体大写字母表示。例如，我们可以谈论随机变量 $X$、随机变量 $Y$ 或随机变量 $Z$。从现在起，我也将使用这种符号。

一个**随机变量**可以有两个或多个可能值，每个值都有一定的正概率。可能的值列在**结果集**中。

每次对随机变量进行***取样时，都会根据定义的概率从其结果集中抽取一个特定值。

让我们来看一个简单的例子。假设变量 X 的定义如下：


- X 的结果集为 $\{1,2\}$

$$
Pr[X = 1] = 0.5
$$

$$
Pr[X = 2] = 0.5
$$

很容易看出，$X$ 是一个随机变量。首先，$X$ 有两个或两个以上的可能值，即$1$和$2$。其次，无论何时对 $X$ 进行取样，每个可能值都有一个正概率，即 0.5$。

随机变量只需要一个具有两种或两种以上可能性的结果集，其中每种可能性在抽样时都有一个正概率。因此，原则上，随机变量可以抽象地定义，不需要任何上下文。在这种情况下，你可以把 "取样 "看作是进行某种自然实验，以确定随机变量的值。

上面的变量 $X$ 是抽象定义的。因此，您可以把上述变量 $X$ 的取样看作是掷一枚公平的硬币，正面取 "2"，反面取 "1"。对于 $X$ 的每个样本，您都要再次掷硬币。

另外，您也可以把 $X$ 的抽样看作是掷一个公平的骰子，如果骰子上出现 1$、3$ 或 4$，则赋值为 "2"；如果骰子上出现 2$、5$ 或 6$，则赋值为 "1"。每次取样 $X$，都要再次掷骰子。

实际上，任何自然实验都可以让你定义上述 $X$ 可能值的概率，都可以根据图纸来想象。

然而，随机变量往往不只是抽象地引入。相反，可能的结果值集合具有明确的现实意义（而不仅仅是数字）。此外，这些结果值可能是根据某种特定类型的实验（而不是使用这些值的任何自然实验）来定义的。

现在让我们举一个变量 $X$ 的例子，它并没有被抽象定义。X 的定义如下，以确定两支球队中哪支球队开始一场足球比赛：


- $X$ 的结果集为 { 红球开出，蓝球开出}。
- 掷一枚特定的硬币 $C$：反面 = "红色开球"；正面 = "蓝色开球"。

$$
Pr [X = \text{red kicks off}] = 0.5
$$

$$
Pr [X = \text{blue kicks off}] = 0.5
$$

在这种情况下，X 的结果集具有具体的含义，即哪支球队在足球比赛中首发。此外，可能的结果及其相关概率是由一个具体的实验决定的，即掷一枚特定的硬币 $C$。

在密码学的讨论中，随机变量通常是针对具有现实意义的结果集引入的。它可能是所有可加密信息的集合（称为信息空间），也可能是使用加密的各方可选择的所有密钥的集合（称为密钥空间）。

不过，在有关密码学的讨论中，随机变量的定义通常不是针对某些特定的自然实验，而是针对任何可能产生正确概率分布的实验。

随机变量的概率分布可以是离散的，也可以是连续的。概率分布***离散的随机变量，即离散随机变量，其可能的结果数量是有限的。目前所举的两个例子中的随机变量 $X$ 都是离散的。

**连续随机变量**可以在一个或多个区间取值。例如，你可以说，随机变量在取样时，会取值 0 到 1 之间的任何实数，而且这个区间内的每个实数都有同样的可能性。在这个区间内，有无限种可能的取值。

在密码学讨论中，您只需要了解离散随机变量。因此，除非另有特别说明，从现在起对随机变量的任何讨论都应理解为指离散随机变量。

### 绘制随机变量图

随机变量的可能值和相关概率可以很容易地通过图形直观显示出来。例如，考虑上一节中的随机变量 $X$，其结果集为 $\{1，2\}$，且 $Pr [X = 1] = 0.5$ 和 $Pr [X = 2] = 0.5$。我们通常会以条形图的形式显示这样一个随机变量，如*图 1*。

*图 1：随机变量 X*

![Figure 1: Random variable X.](assets/Figure2-1.webp)

图 1*中的宽条形显然并不意味着随机变量 $X$ 实际上是连续的。相反，把条形图做得宽一些是为了在视觉上更吸引人（只用一条直线直上，视觉效果不那么直观）。

### 统一变量

在 "随机变量 "这一表述中，"随机 "一词只是指 "概率"。换句话说，它只是指变量的两个或多个可能结果以一定的概率出现。不过，这些结果并不一定**具有相同的可能性（尽管在其他语境中，"随机 "一词确实有这样的含义）。

均匀变量是随机变量的一种特例。它可以以相等的概率取两个或多个值。图 1*中描述的随机变量 $X$ 显然是一个均匀变量，因为两种可能结果出现的概率都是 $0.5$。然而，有许多随机变量并不是均匀变量的实例。

例如，考虑随机变量 $Y$。它有一个结果集 $\{1, 2, 3, 8, 10\}$ 和以下概率分布：

$$
\Pr[Y = 1] = 0.25
$$

$$
\Pr[Y = 2] = 0.35
$$

$$
\Pr[Y = 3] = 0.1
$$

$$
\Pr[Y = 8] = 0.25
$$

$$
\Pr[Y = 10] = 0.05
$$

虽然两种可能的结果（即 1 美元和 8 美元）出现的概率确实相等，但在抽样时，$Y$ 也可以取某些概率不同于 0.25 美元的值。因此，虽然 $Y$ 确实是一个随机变量，但它并不是一个均匀变量。

图 2*提供了 $Y$ 的图形描述。

*图 2：随机变量 Y*

![Figure 2: Random variable Y.](assets/Figure2-2.webp "Figure 2: Random variable Y")

最后一个例子是随机变量 Z，它的结果集为 {1,3,7,11,12}，概率分布如下：

$$
\Pr[Z = 2] = 0.2
$$

$$
\Pr[Z = 3] = 0.2
$$

$$
\Pr[Z = 9] = 0.2
$$

$$
\Pr[Z = 11] = 0.2
$$

$$
\Pr[Z = 12] = 0.2
$$

您可以在*图 3* 中看到它的描述。与 Y 相反，随机变量 Z 是一个均匀变量，因为取样时所有可能值的概率都相等。

*图 3：随机变量 Z*

![Figure 3: Random variable Z.](assets/Figure2-3.webp "Figure 3: Random variable Z")

### 条件概率

假设鲍勃打算从上一日历年中均匀地选择一天。我们应该得出所选日期是夏季的概率是多少？

只要我们认为鲍勃的过程确实是均匀的，我们就应该得出结论，鲍勃选择夏天的一天的概率是 1/4 。这就是随机选择的这一天是夏天的**无条件概率**。

假设鲍勃不是均匀地抽取一个日历日，而是只均匀地从水晶湖（新泽西州）正午温度为 21 摄氏度或更高的日子中进行选择。考虑到这一额外信息，我们可以得出鲍勃选择夏季某一天的概率是多少？

即使没有更多的具体信息（如上一日历年每天中午的气温），我们也确实应该得出与之前不同的结论。

由于水晶湖位于新泽西州，我们肯定不会想到冬天中午的气温会达到 21 摄氏度或更高。相反，它更有可能是春季或秋季的一个温暖的日子，或者是夏季的某一天。因此，如果知道所选日期水晶湖的正午温度为 21 摄氏度或更高，那么鲍勃所选日期是夏天的概率就会高得多。这就是在水晶湖正午温度为 21 摄氏度或更高的条件下，随机选择的这一天是夏天的**条件概率**。

与前面的例子不同，两个事件的概率也可以完全不相关。在这种情况下，我们说它们是**独立的**。

例如，假设一枚公平的硬币正面朝下。那么，明天下雨的概率是多少呢？在这种情况下，条件概率应该与明天下雨的无条件概率相同，因为掷硬币一般不会对天气产生任何影响。

我们用"|"符号来表示条件概率语句。例如，在事件 $B$ 已发生的情况下，事件 $A$ 发生的概率可以写成下面这样：

$$
Pr[A|B]
$$

因此，当两个事件 $A$ 和 $B$ 相互独立时，那么

$$
Pr[A|B] = Pr[A] \text{ and } Pr[B|A] = Pr[B]
$$

独立性条件可简化如下

$$
Pr[A, B] = Pr[A] \cdot Pr[B]
$$

概率论中的一个关键结果被称为**贝叶斯定理**。它的基本原理是：$Pr[A|B]$ 可以重写如下：

$$
Pr[A|B] = \frac{Pr[B|A] \cdot Pr[A]}{Pr[B]}
$$

与其使用特定事件的条件概率，我们还可以查看两个或多个随机变量在一组可能事件中的条件概率。假设有两个随机变量 $X$ 和 $Y$。我们可以用 $x$ 表示 $X$ 的任何可能值，用 $y$ 表示 $Y$ 的任何可能值。那么，如果以下声明成立，我们可以说两个随机变量是独立的：

$$
Pr[X = x, Y = y] = Pr[X = x] \cdot Pr[Y = y]
$$

对于所有 $x$ 和 $y$。

让我们更明确地了解一下这句话的意思。

假设 $X$ 和 $Y$ 的结果集定义如下： **X** = $\{x_1, x_2, \ldots, x_i, \ldots, x_n\}$ 和 **Y** = $\{y_1, y_2, \ldots, y_i, \ldots, y_m\}$。(通常用粗体大写字母来表示值集）。

现在假设您对 $Y$ 进行了取样，并观察到了 $y_1$。上面的陈述告诉我们，现在从 $X$ 抽样中得到 $x_1$ 的概率与我们从未观察到 $y_1$ 完全相同。这对于我们从最初的 $Y$ 取样中得出的任何 $y_i$ 都是正确的。最后，这不仅对 $x_1$ 适用。对于任何 $x_i$，出现的概率都不受 $Y$ 抽样结果的影响。所有这些也适用于先对 $X$ 取样的情况。

最后，让我们从一个略带哲学意味的角度来结束我们的讨论。在现实世界的任何情况下，某些事件的概率总是根据一组特定的信息来评估的。没有任何严格意义上的 "无条件概率"。

例如，假设我问你 2030 年猪会飞的概率。虽然我没有给你进一步的信息，但你显然对这个世界有很多了解，这些都会影响你的判断。你从未见过猪会飞。你知道大多数人都不会指望它们飞起来。你知道它们并不是真的能飞。等等。

因此，当我们在现实世界中谈论某个事件的 "无条件概率 "时，只有当我们把它理解为 "没有任何进一步明确信息的概率 "时，这个词才真正具有意义。因此，任何对 "有条件概率 "的理解，都应该是针对某些特定信息的。

例如，我可能会问你，到 2030 年猪会飞的概率有多大，而在此之前，我已经向你提供了证据，证明新西兰的一些山羊经过几年的训练已经学会了飞行。在这种情况下，你可能会调整你对 2030 年猪会飞的概率的判断。因此，猪到 2030 年会飞的概率是以新西兰山羊的这一证据为条件的。

## 模运算

<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

### 模数

使用**modulo运算**的最基本表达式如下：$x \mod y$。

变量 $x$ 称为股息，变量 $y$ 称为除数。要对正红分和正除数进行模运算，只需确定除数的余数即可。

例如，考虑 $25 \mod 4$ 这个表达式。数字 4 进入数字 25 共 6 次，余数是 1。因此，$25 \mod 4$ 等于 1。用类似的方法，我们可以计算下面的表达式：


- $29 （mod 30 = 29$）（因为 30 进入 29 共 0 次，余数是 29
- $42\mod 2 = 0$（因为 2 进入 42 共 21 次，余数为 0）
- $12\mod 5 = 2$（因为 5 进入 12 共 2 次，余数是 2）
- $20\mod 8 = 4$（因为 8 进入 20 共 2 次，余数是 4）

当被除数或除数为负数时，编程语言会以不同的方式处理模运算。

你肯定会遇到密码学出现负红利的情况。在这种情况下，典型的方法如下：


- 首先确定一个*小于或等于*被除数除以余数为零的最接近的值。称这个值为 $p$。
- 如果红利为 $x$，那么模乘运算的结果就是 $x - p$ 的值。

例如，假设股息为 $-20$，除数为 3。小于或等于 $-20$ 的最接近 3 平分的值是 $21$。在这种情况下，$x - p$ 的值为 $-20 - (-21)$。这等于 1，因此，$-20 \mod 3$ 等于 1。用类似的方法，我们可以求出下面的表达式：


- $-8\mod 5 = 2$
- $-19\mod 16 = 13$
- $-14\mod 6 = 4$

关于符号，你通常会看到以下类型的表达式：$x = [y \mod z]$。由于使用了括号，这种情况下的模运算只适用于表达式的右边。例如，如果 $y$ 等于 25，$z$ 等于 4，那么 $x$ 的值为 1。

在没有括号的情况下，模运算作用于表达式的*两边*。例如，假设表达式如下：$x = y \mod z$。如果$y$等于25，$z$等于4，那么我们只知道$x \mod 4$的值为1。这与集合$\{ldots,-7, -3, 1, 5, 9,\ldots\}$中$x$的任何值都是一致的。

涉及数字和表达式的模运算的数学分支被称为**模运算**。你可以把这一分支看作是数列并非无限长的情况下的算术。虽然我们通常会在密码学中遇到（正）整数的模运算，但也可以使用任何实数进行模运算。

### 移位密码

模运算在密码学中经常出现。为了说明这一点，让我们来看看历史上最著名的加密方案之一：移位密码。

让我们先给它下个定义。假设有一本字典 *D*，它将所有英文字母按顺序等同于一组数字 $/{0,1,2,\ldots,25\}$。假设有一个信息空间**M**。那么，**移位密码**就是一个定义如下的加密方案：


- 从密钥空间 **K** 中均匀选择一个密钥 $k$，其中 **K** = $\{0, 1, 2, \ldots, 25\}$ [1]
- 对 $m \in \mathbf{M}$ 中的信息加密如下
    - 将 $m$ 分离成各个字母 $m_0, m_1, \ldots, m_i, \ldots, m_l$
    - 根据 *D* 将每个 $m_i$ 转换成数字
    - 对于每个 $m_i$，$c_i = [(m_i + k)\mod 26]$
    - 根据 *D* 将每个 $c_i$ 转换成字母
    - 然后将 $c_0、c_1、\ldots、c_l$ 合并，得到密码文本 $c$
- 解密密文 $c$ 的方法如下
    - 根据 *D* 将每个 $c_i$ 转换成数字
    - 对于每个 $c_i$，$m_i = [(c_i - k)\mod 26]$
    - 根据 *D* 将每个 $m_i$ 转换成字母
    - 然后合并 $m_0、m_1、\ldots、m_l$，得到原始信息 $m$

移位密码中的模运算符可确保字母环绕，从而定义所有密码文本字母。为了说明这一点，请考虑在单词 "DOG "上应用移位密码。

假设你统一选择了一个键值为 17 的键。字母 "O "等于 15。如果不进行模运算，将这个明文数字与密钥相加就会得到 32 的密文数字。但是，由于英语字母表只有 26 个字母，因此该密码文数字无法转化为密码文字母。模运算确保了密文数字实际上是 6（$32 \mod 26$ 的结果），相当于密文字母 "G"。

密钥值为 17 的单词 "DOG "的整个加密过程如下：


- 信息 = DOG = D,O,G = 3,15,6
- $c_0 = [(3 + 17) \mod 26] = [(20) \mod 26] = 20 = U$
- $c_1 = [(15 + 17) \mod 26] = [(32) \mod 26] = 6 = G$
- $c_2 = [(6 + 17) \mod 26] = [(23) \mod 26] = 23 = X$
- c = UGX$

每个人都能直观地理解移位密码的工作原理，并可能自己使用它。不过，要想提高密码学知识水平，就必须开始更加适应形式化，因为方案会变得更加困难。因此，移位密码的步骤被形式化了。

**注：**

[1] 我们可以用上一节的术语来准确定义这一说法。让统一变量 $K$ 的可能结果集为 $K$。那么

$$
Pr[K = 0] = \frac{1}{26}
$$

$$
Pr[K = 1] = \frac{1}{26}
$$

......等等。对统一变量 $K$ 取样一次，得出一个特定的密钥。

## XOR 运算

<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

所有计算机数据都是以比特为单位在网络上处理、存储和发送的。任何应用于计算机数据的加密方案也都是在比特级上运行的。

例如，假设您在电子邮件应用程序中输入了一封电子邮件。您应用的任何加密都不会直接应用于电子邮件的 ASCII 字符。而是对电子邮件中字母和其他符号的比特表示进行加密。

对于现代密码学来说，除了模运算之外，还需要了解的一个关键数学运算是 **XOR运算**，即 "排他或 "运算。该运算输入两个比特，输出另一个比特。XOR 运算简称为 "XOR"。如果两个位相同，则输出 0；如果两个位不同，则输出 1。你可以看到下面的四种可能性。符号 $\oplus$ 表示 "XOR"：


- $0 \oplus 0 = 0$
- $0 \oplus 1 = 1$
- $1 \oplus 0 = 1$
- $1 \oplus 1 = 0$

举例说明，假设有一条信息 $m_1$ (01111001) 和一条信息 $m_2$ (01011001)。这两条信息的 XOR 运算如下所示。


- $m_1 \oplus m_2 = 01111001 \oplus 01011001 = 00100000$

过程非常简单。首先，将 $m_1$ 和 $m_2$ 的最左边位进行 XOR。在这种情况下，就是 $0 \oplus 0 = 0$。然后，对左边的第二对位进行 XOR。在这种情况下，就是 $1 \oplus 1 = 0$。继续这个过程，直到对最右边的比特进行了 XOR 运算。

不难看出，XOR 运算是交换运算，即 $m_1 \oplus m_2 = m_2 \oplus m_1$。此外，XOR 运算还是联立运算。也就是说，$(m_1 \oplus m_2) \oplus m_3 = m_1 \oplus (m_2 \oplus m_3)$ 。

根据上下文的不同，对两个不同长度字符串的 XOR 运算可以有不同的解释。在此，我们将不考虑对不同长度的字符串进行任何 XOR 运算。

当被除数为 2 时，XOR 运算等价于对比特加法进行模运算的特殊情况：


- $(0 + 0) \mod 2 = 0 \oplus 0 = 0$
- $(1 + 0) \mod 2 = 1 \oplus 0 = 1$
- $(0 + 1) \mod 2 = 0 \oplus 1 = 1$
- $(1 + 1) \mod 2 = 1 \oplus 1 = 0$

## 伪随机性

<chapterId>20463fc5-3e92-581f-a1b7-3151279bd95e</chapterId>

在讨论随机变量和均匀变量时，我们对 "随机 "和 "均匀 "作了具体区分。在描述随机变量时，这种区分通常会保留下来。不过，在我们目前的语境中，这种区分需要取消，"随机 "和 "均匀 "可以作为同义词使用。我将在本节末尾解释原因。

首先，如果一个长度为 $n$ 的二进制字符串是均匀变量 $S$ 取样的结果，而均匀变量 $S$ 给每个长度为 $n$ 的二进制字符串提供了相等的选择概率，那么我们就可以把这个长度为 $n$ 的二进制字符串称为 **随机**（或 **均匀**）。

例如，假设所有长度为 8 的二进制字符串的集合为：$\{000000\ 0000, 0000\ 0001, \ldots, 1111\ 1111\}$ 。(典型的写法是将一个 8 位字符串写成两个四元组，每个四元组称为一个**nibble**）。我们称这组字符串为 **$S_8$**。

根据上述定义，如果长度为 8 的特定二进制字符串是对均匀变量 $S$ 取样的结果，而 $S$ 给 **$S_8$** 中的每个字符串提供了相等的选择概率，那么我们就可以称这个字符串为随机字符串（或均匀字符串）。鉴于集合 **$S_8$** 包含 2^8$ 元素，那么集合中每个字符串的抽样选择概率必须是 1/2^8$。

二进制字符串随机性的一个关键方面是，它是根据其选择过程来定义的。因此，任何特定二进制字符串的形式本身并不能揭示其选择的随机性。

例如，许多人凭直觉认为，像 $1111\ 1111$ 这样的字符串不可能是随机选择的。但这显然是错误的。

在所有长度为 8 的二进制字符串上定义一个均匀变量 $S$，从集合 **$S_8$** 中选择 $1111\ 1111$ 的可能性与选择 $0111\ 0100$ 这样的字符串的可能性相同。因此，仅仅分析字符串本身并不能说明字符串的随机性。

我们也可以谈论随机字符串，而不特指二进制字符串。例如，我们可以说一个随机十六进制字符串 $AF\ 02\ 82$。在这种情况下，这个字符串是从所有长度为 6 的十六进制字符串集合中随机选择的。 这相当于随机选择了一个长度为 24 的二进制字符串，因为每个十六进制数字代表 4 个比特。

通常情况下，"随机字符串 "这一表述指的是从所有长度相同的字符串集合中随机抽取的字符串。我在上面就是这样描述的。当然，长度为 $n$ 的字符串也可以从不同的集合中随机抽取。例如，它只是所有长度为 $n$ 的字符串的一个子集，或者是一个包含不同长度字符串的集合。不过，在这种情况下，我们不会把它称为 "随机字符串"，而是 "从某个集合**S**中随机抽取的字符串"。

密码学的一个关键概念是伪随机性。长度为 $n$ 的**伪随机字符串**看起来**好像是对均匀变量 $S$ 取样的结果，该变量给 **$S_n$**中的每个字符串提供了相等的选择概率。但事实上，这个字符串是均匀变量$S'$的取样结果，它只定义了**$S_n$**子集上的概率分布--不一定是所有可能结果的概率都相等的分布。这里最关键的一点是，没有人能真正区分$S$和$S'$的样本，即使你取了很多样本。

例如，假设有一个随机变量 $S$。其结果集为 **$S_{256}$**，这是长度为 256 的所有二进制字符串的集合。这个集合有 2^{256}$ 个元素。每个元素在抽样时都有相等的选择概率 1/2^{256}$。

此外，假设有一个随机变量 $S'$。它的结果集只包括长度为 256 的二进制字符串 $2^{128}$。它在这些字符串上有某种概率分布，但这种分布不一定是均匀的。

假设我现在从 $S$ 中抽取了 1000 个样本，又从 $S'$ 中抽取了 1000 个样本，并把这两组结果交给你。我告诉你哪一组结果与哪个随机变量相关。接下来，我从这两个随机变量中抽取一个样本。但这次我没有告诉你我抽取的是哪个随机变量。如果 $S'$ 是伪随机的，那么我们的想法是，你猜对我抽取的随机变量的概率实际上不超过 1/2$。

通常，长度为 $n$ 的伪随机字符串是通过随机选择一个大小为 $n - x$ 的字符串（其中 $x$ 为正整数），并将其作为扩展算法的输入而生成的。这个大小为 $n - x$ 的随机字符串被称为**种子**。

伪随机字符串是使密码学实用化的一个关键概念。以流密码为例。在流密码中，将随机选择的密钥插入扩展算法，生成一个更大的伪随机字符串。然后，通过 XOR 运算将该伪随机字符串与明文结合，生成密码文。

如果我们无法为流密码生成这种类型的伪随机字符串，那么我们就需要一个和信息一样长的密钥来保证其安全性。这在大多数情况下并不实用。

本节讨论的伪随机性概念可以得到更正式的定义。它还可以扩展到其他语境。但我们不必在此深入探讨。对于密码学的大部分内容来说，真正需要直观理解的是随机字符串和伪随机字符串之间的区别。[2]

在我们的讨论中放弃区分 "随机 "和 "均匀 "的原因现在也应该清楚了。在实践中，大家都用 "伪随机 "一词来表示一个字符串，它看起来***好像是均匀变量 $S$ 取样的结果。严格地说，我们应该把这样的字符串称为 "伪均匀"，采用我们前面的语言。由于 "伪均匀 "一词既笨拙又没有人使用，为了清楚起见，我们在此不作介绍。相反，在当前上下文中，我们只需放弃 "随机 "和 "均匀 "的区别。

**注**

[2] 如果对这些问题更正式的阐述感兴趣，可以参阅卡茨和林德尔的《现代密码学入门》*，尤其是第 3 章。

# 密码学数学基础 2

<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>

## 什么是数论？

<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>

本章介绍密码学数学基础的高级课题：数论。虽然数论对对称密码学（如 Rijndael 密码）很重要，但在公钥密码学中尤为重要。

如果您觉得数论的细节繁琐，我建议您第一遍先阅读高水平的内容。您可以在以后再回头读。

___

你可以把**数论**描述为研究整数的性质和与整数有关的数学函数。

例如，任何两个数 $a$ 和 $N$ 如果它们的最大公约数等于 1，那么这两个数就是 **互素**（或 **相对素数**）。现在假设一个特定的整数 $N$。有多少个比 $N$ 小的整数是 $N$ 的共素数？我们能否对这一问题的答案做出一般性说明？这些都是数论试图回答的典型问题。

现代数论依赖于抽象代数的工具。抽象代数**是数学的一个分支学科，其主要分析对象是被称为代数结构的抽象对象。一个**代数结构**是一组元素与一个或多个运算的组合，它符合某些公理。通过代数结构，数学家可以抽象出具体数学问题的细节，从而深入了解这些问题。

抽象代数领域有时也被称为近世代数。您可能还会遇到**抽象数学**（或**纯数学**）的概念。后一个术语并非指抽象代数，而是指为数学本身而研究数学，而不仅仅着眼于潜在的应用。

抽象代数中的集合可以处理多种类型的对象，从等边三角形的保形变换到壁纸图案。对于数论，我们只考虑包含整数的元素集或处理整数的函数集。

## 组别

<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

数学中的一个基本概念是元素集合。集合通常用符号表示，元素之间用逗号隔开。

例如，所有整数的集合是 $\{..., -2, -1, 0, 1, 2, ...\}$。这里的省略号意味着某种模式会沿着特定的方向继续下去。因此，所有整数的集合还包括 $3、4、5、6$ 等，以及 $3、-4、-5、-6$ 等。这个所有整数的集合通常用 $\mathbb{Z}$ 表示。

集合的另一个例子是$\mathbb{Z}.\mod 11$，即所有整数 modulo 11 的集合。与整个集合 $\mathbb{Z}$ 相反，这个集合只包含有限个元素，即 $\{0, 1, \ldots, 9, 10\}$ 。

一个常见的错误是认为集合 $\mathbb{Z}\mod 11$ 实际上是 $\{-10, -9, \ldots, 0, \ldots, 9, 10\}$ 。但根据我们前面对模操作的定义，情况并非如此。任何负整数通过 modulo 11 都会包到 $\{0, 1, \ldots, 9, 10\}$ 上。例如，表达式 $-2 \mod 11$ 包围到 $9$，而表达式 $-27 \mod 11$ 包围到 $5$。

数学的另一个基本概念是二元运算。二进制运算是指用两个元素产生第三个元素的任何运算。例如，从基本的算术和代数中，你会熟悉四种基本的二进制运算：加法、减法、乘法和除法。

集合和二元运算这两个基本数学概念被用来定义群的概念，而群是抽象代数中最基本的结构。

具体来说，假设有一些二元运算 $/circ$。此外，假设某个元素集合**S**配备了该操作。这里的 "配备 "指的是$\circ$操作可以在集合**S**中的任意两个元素之间进行。

那么，$langle \mathbf{S}, \circ \rangle$ 组合如果满足四个特定条件，即所谓的群公理，就是一个**群**。

1.对于任何 $a$ 和 $b$ 都是 $\mathbf{S}$ 的元素，$a \circ b$ 也是 $\mathbf{S}$ 的元素。这就是所谓的**封闭条件**。

2.对于$mathbf{S}$中的任何$a$、$b$和$c$元素来说，情况是$(a \circ b) \circ c = a \circ (b \circ c)$。这就是所谓的**关联性条件**。

3.在 $mathbf{S}$ 中有一个唯一的元素 $e$，这样对于 $mathbf{S}$ 中的每个元素 $a$，下面的等式都成立：$e \circ a = a \circ e = a$。由于只有一个这样的元素 $e$，所以它被称为**同元素**。这个条件被称为**同一性条件**。

4.对于 $\mathbf{S}$ 中的每个元素 $a$，在 $\mathbf{S}$ 中都存在一个元素 $b$，使得下面的等式成立：$a \circ b = b \circ a = e$，其中 $e$ 是同元素。这里的元素 $b$ 被称为 ** 逆元素**，通常表示为 $a^{-1}$。这个条件被称为**逆条件**或**可逆条件**。

让我们进一步探索群。用 $\mathbb{Z}$ 表示所有整数的集合。这个集合结合标准加法，即 $\langle \mathbb{Z}, + \rangle$，显然符合群的定义，因为它满足上述四条公理。

1.对于任何 $x$ 和 $y$ 都是 $\mathbb{Z}$ 的元素，$x + y$ 也是 $\mathbb{Z}$ 的元素。所以 $langle \mathbb{Z}, + \rangle$ 满足闭包条件。

2.对于任何 $x$、$y$ 和 $z$ 都是 $\mathbb{Z}$ 的元素，$(x + y) + z = x + (y + z)$ 。因此 $\langle \mathbb{Z}, + \rangle$ 满足关联性条件。

3.在 $\langle \mathbb{Z}, + \rangle$ 中有一个同元素，即 0，对于 $\mathbb{Z}$ 中的任意 $x$，即成立：$0 + x = x + 0 = x$。所以 $langle \mathbb{Z}, + \rangle$ 满足同一性条件。

4.最后，对于 $\mathbb{Z}$ 中的每个元素 $x$，都有一个 $y$，使得 $x + y = y + x = 0$。例如，如果 $x$ 是 10，那么 $y$ 就是 $-10$（在 $x$ 是 0 的情况下，$y$ 也是 0）。所以 $\langle \mathbb{Z}, + \rangle$ 满足逆条件。

重要的是，有加法的整数集合构成一个群并不意味着它构成一个有乘法的群。你可以通过检验 $\langle \mathbb{Z}, \cdot \rangle$ 与四个群公理（其中 $\cdot$ 表示标准乘法）来验证这一点。

前两条公理显然成立。此外，在乘法运算中，元素 1 可以作为标识元素。任何整数$x$乘以1，即得到$x$。然而，$langle \mathbb{Z}, \cdot \rangle$并不满足逆条件。也就是说，对于 $mathbb{Z}$ 中的每一个 $x$ 来说，$\mathbb{Z}$ 中并不存在一个唯一的元素 $y$，因此 $x \cdot y = 1$。

例如，假设 $x = 22$。集合 $\mathbb{Z}$ 中的什么值 $y$ 与 $x$ 相乘会产生同一元素 1？$1/22$这个值是可行的，但它不在集合$\mathbb{Z}$中。事实上，除了 1 和 -1（$y$ 必须分别为 1 和 -1）之外，任何整数$x$ 都会遇到这个问题。

如果我们的集合允许使用实数，那么我们的问题基本上就不存在了。对于集合中的任何元素 x$，乘以 1/x$ 都得 1。由于分数包含在实数集合中，因此每个实数都可以找到一个倒数。零是个例外，因为与零相乘永远不会得到同元素 1。因此，具有乘法的非零实数集确实是一个群。

有些群满足第五个一般条件，即**交换性条件**。该条件如下


- 假设一个群 $G$ 有一个集合 **S** 和一个二元运算符 $\circ$。假设 $a$ 和 $b$ 是 **S** 的元素。如果对 **S** 中的任意两个元素 $a$ 和 $b$ 来说，$a \circ b = b \circ a$，那么 $G$ 满足交换性条件。

任何满足交换性条件的群都称为**交换群**，或**阿贝尔群**（以尼尔斯-亨里克-阿贝尔命名）。很容易验证，加法实数集和加法整数集都是阿贝尔群。乘法的整数集合根本不是一个群，因此事实上也不可能是阿贝尔群。相比之下，乘法的非零实数集也是一个阿贝尔群。

您应该注意两个重要的符号约定。首先，符号 "+"或"×"经常被用来表示分组运算，即使元素实际上不是数字。在这种情况下，不应将这些符号理解为标准的算术加法或乘法。相反，它们只是与这些算术运算具有抽象相似性的运算。

除非您特指算术加法或乘法，否则使用 $\circ$ 和 $\diamond$ 等符号进行分组运算会更简单，因为这些符号没有非常根深蒂固的文化内涵。

其次，与 "+"和"×"常用于表示非算术运算的原因相同，群的同元素也经常用 "0 "和 "1 "来表示，即使这些群中的元素不是数字。除非您指的是带有数字的群中的标识元素，否则使用"$e$"等更中性的符号来表示标识元素会更方便。

在数学中，许多不同的、非常重要的数值集合都配备了某些二进制运算，这些数值集合就是组。然而，加密应用只适用于整数集或至少是整数描述的元素集，也就是数论领域。因此，密码应用中不使用整数以外的实数集。

最后，让我们举例说明一些元素虽然不是整数，却可以 "用整数来描述"。椭圆曲线上的点就是一个很好的例子。虽然椭圆曲线上的任何一点显然都不是整数，但这样的点确实可以用两个整数来描述。

例如，椭圆曲线对比特币至关重要。任何标准的比特币私钥和公钥对都是从以下椭圆曲线定义的点集中选出的：

$$
x^3 + 7 = y^2 \mod 2^{256} – 2^{32} – 29 – 28 – 27 – 26 - 24 - 1
$$

(小于 2^{256}$ 的最大质数）。x$ 坐标是私钥，y$ 坐标是公钥。

比特币中的交易通常以某种方式将输出锁定在一个或多个公钥上。这些交易的价值可以通过相应私钥的数字签名解锁。

## 环状群

<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

我们可以将**无限**和**无限群**加以区分。前者的元素数目是有限的，而后者的元素数目是无限的。有限群中元素的数量称为群的**阶。所有涉及使用群的实用密码学都依赖于有限（数论）群。

在公开密钥密码学中，有一类被称为循环群的有限阿贝尔群尤为重要。要了解循环群，我们首先需要了解群元指数化的概念。

假设一个具有群运算 $\circ$ 的群 $G$，而 $a$ 是 $G$ 的一个元素。那么，表达式 $a^n$ 应被解释为元素 $a$ 与其自身共结合了 $n - 1$ 次。例如，$a^2$ 表示 $a \circ a$，$a^3$ 表示 $a \circ a \circ a$，以此类推。(注意，这里的指数化不一定是标准算术意义上的指数化）。

让我们来看一个例子。假设 $G = \langle \mathbb{Z}\mod 7, + \rangle$，而我们的 $a$ 值等于 4.在这种情况下，$a^2 = [4 + 4 \mod 7] = [8 \mod 7] = 1 \mod 7$。或者，$a^4$表示$[4 + 4 + 4 + 4 \mod 7] = [16 \mod 7] = 2 \mod 7$。

有些阿贝尔群有一个或多个元素，可以通过续幂运算产生所有其他群元素。这些元素被称为**生成元素**或**原始元素**。

这类群的一个重要类别是 $langle \mathbb{Z}^* \mod N, \cdot \rangle$，其中 $N$ 是一个素数。这里的符号 $\mathbb{Z}^*$ 表示这个群包含所有小于 $N$ 的非零、正整数。因此，这样一个群总是有 $N - 1$ 个元素。

例如，考虑 $G = \langle \mathbb{Z}^* \mod 11, \cdot \rangle$。这个群有以下元素$\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}$.这个群的阶数是 10（实际上等于 $11 - 1$）。

让我们来探索一下这个组中元素 2 的指数化运算。直至 2^{12}$ 的计算结果如下。请注意，等式左边的指数指的是组元指数化。在我们这个特殊的例子中，等式右边确实涉及算术幂级数（但也可能涉及加法）。为了说明问题，我写出了重复运算，而不是右边的指数形式。


- $2^1 = 2\mod 11$
- $2^2 = 2 \cdot 2 \mod 11 = 4 \mod 11$
- $2^3 = 2 \cdot 2 \cdot 2 \mod 11 = 8 \mod 11$
- $2^4 = 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 16 \mod 11 = 5 \mod 11$
- 2^5 = 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 32 \mod 11 = 10 \mod 11$
- 2^6 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 64 \mod 11 = 9 \mod 11$
- 2^7 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 128 \mod 11 = 7 \mod 11$
- $2^8 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 256 \mod 11 = 3 \mod 11$
- 2^9 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 512 \mod 11 = 6 \mod 11$
- 2^{10} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 1024 \mod 11 = 1 \mod 11$
- 2^{11} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 2048 \mod 11 = 2 \mod 11$
- 2^{12} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 4096 \mod 11 = 4 \mod 11$

如果你仔细观察，就会发现对元素 2 进行指数运算时，$langle \mathbb{Z}^* \mod 11, \cdot \rangle$的所有元素都会按如下顺序循环：在 $2^{10}$之后，元素 2 的继续指数化又以相同的顺序循环了所有元素。因此，元素 2 是 $langle \mathbb{Z}^* \mod 11, \cdot \rangle$ 中的一个生成器。

虽然 $langle \mathbb{Z}^* \mod 11, \cdot \rangle$ 有多个生成器，但并不是这个群的所有元素都是生成器。例如，考虑一下元素 3。在不显示繁琐计算的情况下，通过前 10 次指数运算，可以得到以下结果：


- $3^1 = 3\mod 11$
- $3^2 = 9\mod 11$
- $3^3 = 5\mod 11$
- $3^4 = 4\mod 11$
- $3^5 = 1\mod 11$
- $3^6 = 3\mod 11$
- $3^7 = 9\mod 11$
- $3^8 = 5\mod 11$
- $3^9 = 4\mod 11$
- $3^{10} = 1 （模 11$

对元素 3 进行指数运算只会得到这些值的一个子集，而不会循环运算 $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ 中的所有值：在第五次指数化之后，这些值开始重复出现。

现在我们可以把**循环群**定义为至少有一个生成器的群。也就是说，至少有一个群元素，从这个群元素可以通过幂级数产生所有其他群元素。

你可能已经注意到，在我们上面的例子中，2^{10}$ 和 3^{10}$ 都等于 $1 \mod 11$。事实上，虽然我们不会进行计算，但是在组 $langle \mathbb{Z}^* \mod 11, \cdot \rangle$ 中，任何元素的指数乘以 10 都会得到 $1 \mod 11$。为什么会这样呢？

这是一个重要的问题，但要回答这个问题还需要一些努力。

首先，假设有两个正整数 $a$ 和 $N$。数论中的一个重要定理指出，当且仅当 $a$ 和 $N$ 之间的最大公约数等于 1 时，$a$ 有一个模为 $N$ 的乘法逆（即一个整数 $b$，使得 $a \cdot b = 1 \mod N$）。也就是说，如果 $a$ 和 $N$ 是共素数。

因此，对于任何具有模乘 $N$ 的整数组来说，只有与 $N$ 相乘的较小的共乘数才包含在这个集合中。我们可以用 $\mathbb{Z}^c \mod N$ 表示这个集合。

例如，假设 $N$ 是 10。只有整数 1、3、7 和 9 与 10 互为共素数。所以集合 $\mathbb{Z}^c \mod 10$ 只包括 $\{1, 3, 7, 9\}$ 。你不能用 1 和 10 之间的任何其他整数来创建一个具有整数乘法 modulo 10 的组。对于这个特殊的组，反比例是成对的 1 和 9 以及 3 和 7。

在 $N$ 本身是素数的情况下，从 1 到 $N - 1$ 的所有整数都是 $N$ 的共素数。因此，这样一个群的阶为 $N -1$。使用我们之前的符号，当 $N$ 是素数时，$\mathbb{Z}^c \mod N$ 等于 $\mathbb{Z}^* \mod N$。我们在前面的例子中选择的群，$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$，就是这一类群的一个特殊例子。

接下来，函数$\phi(N)$计算直到一个数$N$为止的共素数，被称为**欧拉的Phi函数**。[1] 根据**欧拉定理**，只要两个整数 $a$ 和 $N$ 是共素数，下面的条件就成立：


- $a^{\phi(N)} \mod N = 1 \mod N$

这对 $N$ 为素数的 $langle \mathbb{Z}^* \mod N, \cdot \rangle$ 类群具有重要意义。对于这些群，群元指数化代表算术指数化。也就是说，$a^{\phi(N)} \mod N$ 表示算术运算 $a^{\phi(N)}\mod N$。由于这些乘法群中的任何元素 $a$ 都与 $N$ 共素，这意味着 $a^{\phi(N)} \mod N = a^{N - 1} 。\mod N = 1 \mod N$.

欧拉定理是一个非常重要的结果。首先，它意味着 $langle \mathbb{Z}^* \mod N, \cdot \rangle$ 中的所有元素都只能在除以 $N - 1$ 的指数值中循环。在 $langle \mathbb{Z}^* \mod 11, \cdot \rangle$ 的情况下，这意味着每个元素只能循环经过 2、5 或 10 个元素。任何元素在指数化时循环通过的组值被称为元素的**阶**。一个元素的阶相当于一个群的阶，它就是一个生成器。

此外，欧拉定理意味着我们总是可以知道 $a^{N - 1} 的结果。\mod N$ 的结果。无论实际计算有多复杂，情况都是如此。

例如，假设我们的组是 $\mathbb{Z}^* \mod 160,481,182$（其中 160,481,182 确实是一个素数）。我们知道，所有从 1 到 160,481,181 的整数都必须是这个组的元素，而且 $\phi(n) = 160,481,181$。虽然我们无法完成所有的计算步骤，但我们知道诸如 $514^{160,481,181}$、$2,005^{160,481,181}$ 和 $256,212^{160,481,181}$ 等表达式的值都必须是 $1 \mod 160,481,182$。

**注：**

[1] 该函数的工作原理如下。任何整数 $N$ 都可以分解成素数乘积。假设某个特定的 $N$ 被析取如下：$p_1^{e1}\cdot p_2^{e2}\cdot \ldots \cdot p_m^{em}$ 其中所有的 $p$ 都是质数，所有的 $e$ 都是大于或等于 1 的整数：

$$
\phi(N) = \sum_{i=1}^m \left[p_i^{e_i} - p_i^{e_i - 1}\right]
$$

欧拉的 Phi 函数公式，用于 $N$ 的质因式分解。

## 字段

<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

群是抽象代数中的基本代数结构，但还有更多的代数结构。你唯一需要熟悉的代数结构是**场**，特别是**无穷场**。这种代数结构经常用于密码学，例如高级加密标准。后者是你在实践中会遇到的主要对称加密方案。

场源于群的概念。具体来说，一个**场**是一个元素集合**S**，配有两个二元运算符$\circ$和$\diamond$，它满足以下条件：

1.配有 $\circ$ 的集合 **S** 是一个阿贝尔群。

2.配有 $\diamond$ 的集合 **S** 是一个 "非零 "元素的阿贝尔群。

3.集合**S**包含两个运算符，符合所谓的分配条件：假设 $a$、$b$ 和 $c$ 都是**S**的元素。那么，当 $a \circ (b \diamond c) = (a \circ b) \diamond (a \circ c)$ 时，配有两个算子的**S**满足分配性质。

请注意，与群一样，域的定义也是非常抽象的。它没有对**S**中元素的类型或操作 $\circ$ 和 $\diamond$ 做出任何声明。它只是指出，场是上述三个条件成立的任何具有两种运算的元素集合。(第二个阿贝尔群中的 "零 "元素可以抽象地解释）。

那么，什么是字段的例子呢？一个很好的例子就是$\mathbb{Z}集\mod 7$，或者说$\{0, 1, \ldots, 7\}$ 定义于标准加法（代替上面的$\circ$）和标准乘法（代替上面的$\diamond$）。

首先， $\mathbb{Z}\mod 7$ 满足作为加法无差别群的条件，如果只考虑非零元素，它也满足作为乘法无差别群的条件。其次，集合与两个算子的组合符合分配条件。

通过使用一些特定的值来探索这些说法在教学上是值得的。让我们从$\mathbb{Z}集合中随机选取一些元素，实验值分别是5, 2, 和3。\mod 7$, 来考察一下 $langle \mathbb{Z} 的场\mod 7, +, \cdot \rangle$。我们将根据探索特定条件的需要，依次使用这三个值。

让我们先来探讨一下 $\mathbb{Z} 是否是一个阿贝尔群。\是否是一个阿贝尔群？

1. **关闭条件**：让我们把 5 和 2 作为我们的值。在这种情况下，$[5 + 2] \mod 7 = 7 \mod 7 = 0$。这确实是 $\mathbb{Z} 的元素\mod 7$ 所以结果符合闭包条件

2. **关联条件**：让我们把 5、2 和 3 作为我们的值。这样的话，$[(5 + 2) + 3] \mod 7 = [5 + (2 + 3)] \mod 7 = 10 \mod 7 = 3$。这符合关联性条件。

3. **身份条件**：让我们把 5 作为我们的值。这样的话，$[5 + 0] \mod 7 = [0 + 5] \mod 7 = 5$。所以 0 看起来是加法的同元素。

4. **逆条件**：考虑 5 的倒数。对于某个 $d$ 值，必须是 $[5 + d] \mod 7 = 0$。在这种情况下，来自 $\mathbb{Z} 的唯一值是\mod 7$ 中满足这一条件的唯一值是 2.

5. **通约条件**：让我们把 5 和 3 作为我们的值。在这种情况下，$[5 + 3] \mod 7 = [3 + 5] \mod 7 = 1$。这符合交换性条件。

集合 $\mathbb{Z}\mod 7$ 显然是一个阿贝尔群。现在让我们来探讨一下$\mathbb{Z} \mod 7$是否是一个阿贝尔群。\mod 7$ 是否是一个包含所有非零元素的阿贝尔群？

1. **关闭条件**：让我们把 5 和 2 作为我们的值。这样的话，$[5 \cdot 2] \mod 7 = 10 \mod 7 = 3$。这也是 $\mathbb{Z} 的元素\mod 7$ 所以结果与封闭条件是一致的。

2. **关联条件**：让我们把 5、2 和 3 作为我们的值。这样的话，$[ (5 \cdot 2) \cdot 3] \mod 7 = [5 \cdot (2 \cdot 3)] \mod 7 = 30 \mod 7 = 2$。这符合关联性条件。

3. **身份条件**：让我们把 5 作为我们的值。这样的话，$[5 \cdot 1] \mod 7 = [1 \cdot 5] \mod 7 = 5$。所以 1 看起来是乘法的同元素。

4. **逆条件**：考虑 5 的倒数。对于某个 $d$ 值，必须是 $[5 \cdot d] \mod 7 = 1$。来自 $\mathbb{Z} 的唯一值\这与逆条件是一致的。

5. **通约条件**：让我们把 5 和 3 作为我们的值。这样的话，$[5 \cdot 3] \mod 7 = [3 \cdot 5] \mod 7 = 15 \mod 7 = 1$。这符合交换性条件。

集合 $\mathbb{Z}\与非零元素的加法或乘法结合在一起时，显然符合阿贝尔群的规则。

最后，这个集合与两个运算符相结合，似乎满足了分配条件。让我们把 5、2 和 3 作为我们的值。我们可以看到 $[5 \cdot (2 + 3)] \mod 7 = [5 \cdot 2 + 5 \cdot 3] \mod 7 = 25 \mod 7 = 4$。

我们现在看到 $\mathbb{Z}配备加法和乘法的 $\mod 7$ 在测试特定值时符合有限域的公理。当然，我们也可以一般性地证明这一点，但在此不做赘述。

一个关键的区别在于两类场：有限场和无限场。

无限域**涉及集合**S**无限大的域。具有加法和乘法的实数集 $\mathbb{R}$ 就是无限域的一个例子。无限域**，又称**伽罗瓦域**，是指集合**S**是有限的域。我们上面的例子是 $langle \mathbb{Z}\mod 7, +, \cdot \rangle$ 是一个有限域。

在密码学中，我们主要关注有限域。一般来说，当且仅当**S**具有$p^m$元素，其中$p$为质数，$m$为大于或等于1的正整数时，就可以证明某个元素集合**S**存在有限域。换句话说，如果某个集合**S**的阶数是质数（$p^m$，其中$m = 1$）或某个质幂（$p^m$，其中$m > 1$），那么就可以找到两个算子$\circ$和$\diamond$，从而满足场的条件。

如果某个有限域的元素个数是质数，那么它就叫做**质域**。如果有限域中的元素个数是素数的幂次，那么这个域就叫做**扩展域**。在密码学中，我们对质数域和扩展域都很感兴趣。[2]

密码学所关注的主要素数域是指所有整数的集合被某个素数调制，运算符是标准的加法和乘法。这类有限域包括 $\mathbb{Z}, $\mathbb{Z}, $\mathbb{Z}, $\mathbb{Z}\mod 2$, $\mathbb{Z}\mod 3$, $\mathbb{Z}\mod 5$, $\mathbb{Z}\7$, $\mathbb{Z}\mod 11$, $\mathbb{Z}\mod 13$ 等等。对于任何素域 $\mathbb{Z}\mod p$，这个域的整数集合如下：$\{0, 1, \ldots, p - 2, p - 1\}$.

在密码学中，我们对扩展域也很感兴趣，特别是任何具有 2^m$ 元素（其中 $m > 1$）的域。例如，Rijndael 密码中就使用了这种有限域，它是高级加密标准的基础。虽然质数域相对直观，但对于不熟悉抽象代数的人来说，这些基 2 扩展域可能并不适合。

首先，任何具有 2^m$ 元素的整数集合都可以分配两个运算符，使它们的组合成为一个场（只要 $m$ 是正整数），这确实是事实。然而，场的存在并不一定意味着它很容易被发现或在某些应用中特别实用。

事实证明，在密码学中特别适用的 2^m$ 扩展域是那些定义在多项式表达式的特定集合上的扩展域，而不是某个整数集合。

例如，假设我们想要一个扩展域，集合中包含 2^3$（即 8 个）元素。虽然可能有许多不同的集合可以用于这种大小的字段，但其中一个集合包括形式为 $a_2x^2 + a_1x + a_0$ 的所有唯一多项式，其中每个系数 $a_i$ 要么是 0，要么是 1。因此，这个集合 **S** 包括以下元素：

1. $0$:a_2 = 0$、a_1 = 0$、a_0 = 0$ 的情况。

2. $1$:a_2 = 0$、a_1 = 0$、a_0 = 1$ 的情况。

3. $x$:a_2 = 0$、a_1 = 1$、a_0 = 0$ 的情况。

4.$x + 1$:a_2 = 0$、a_1 = 1$、a_0 = 1$ 的情况。

5.$x^2$:a_2 = 1$、a_1 = 0$、a_0 = 0$ 的情况。

6.$x^2 + 1$:a_2 = 1$、a_1 = 0$、a_0 = 1$ 的情况。

7.$x^2 + x$：a_2 = 1$、a_1 = 1$、a_0 = 0$ 的情况。

8.$x^2 + x + 1$：a_2 = 1$、a_1 = 1$、a_0 = 1$ 的情况。

那么**S**就是$\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1}$的集合。在这个元素集合上可以定义哪两种运算来确保它们的组合是一个域？

集合 **S** ($\circ$) 的第一个运算可以定义为标准的多项式加法 modulo 2。您所要做的就是像通常那样将多项式相加，然后对所得多项式的每个系数应用模 2。下面是一些例子：


- $[(x^2) + (x^2 + x + 1)] \mod 2 = [2x^2 + x + 1] \mod 2 = x + 1$
- $[(x^2 + x) + (x)] \mod 2 = [x^2 + 2x] \mod 2 = x^2$
- $[(x + 1) + (x^2 + x + 1)] \mod 2 = [x^2 + 2x + 2] \mod 2 = x^2 + 1$

创建字段所需的集合 **S** （$\diamond$）上的第二个运算更为复杂。这是一种乘法，但不是算术中的标准乘法。相反，你必须把每个元素看作一个向量，并把这个运算理解为这两个向量模乘一个不可约多项式的乘法运算。

让我们先来了解一下不可还原多项式的概念。不可还原多项式**是指不能被因子化的多项式（就像质数不能被因子化成 1 和质数本身以外的成分一样）。就我们的目的而言，我们感兴趣的是相对于所有整数集合而言不可还原的多项式。(注意，即使你不能用整数对某些多项式进行因式分解，你也可以用实数或复数对它们进行因式分解）。

例如，多项式 $x^2 - 3x + 2$。可以改写为 $(x-1)(x-2)$。因此，这不是不可约数。现在考虑多项式 $x^2+1$。如果只使用整数，就无法进一步分解这个表达式。因此，这是一个关于整数的不可约多项式。

接下来，让我们谈谈向量乘法的概念。我们不会深入探讨这个话题，但你只需了解一条基本规则：只要被除数的阶数大于或等于除数的阶数，就可以进行任何矢量除法。如果被除数的阶数小于除数的阶数，那么被除数就不能再被除数整除。

例如，考虑表达式 $x^6 + x + 1 \mod x^5 + x^2$。这显然会进一步减少，因为被除数 6 的阶数高于除数 5 的阶数。由于被除数 5 和除数 5 的度数相等，这个表达式也会进一步缩小。

然而，现在考虑表达式 $x^4+x+1\mod x^5 +x^2$。由于被除数 4 的阶数小于除数 5 的阶数，这个表达式不会进一步缩小。

根据这些信息，我们现在可以为集合 $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1}$ 找到第二个运算。

我已经说过，第二运算应理解为矢量乘法 modulo 某个不可还原多项式。这个不可还原多项式应该确保第二运算定义了一个**S**上的阿贝尔群，并且符合分配条件。那么，这个不可还原多项式应该是什么呢？

由于集合中所有向量的度数都是 2 或更低，因此不可还原多项式的度数应该是 3。如果集合中的两个向量相乘得到的多项式的度数都是 3 或更高，我们就知道度数为 3 的多项式的模总是得到度数为 2 或更低的多项式。此外，作为被除数的多项式必须是不可还原的。

事实证明，有几个度数为 3 的不可约多项式可以用作我们的除数。结合我们的集合 **S** 和加法模 2，这些多项式中的每一个都定义了一个不同的域。这意味着，在密码学中使用扩展域 2^m$ 时，你有多种选择。

在我们的例子中，假设我们选择多项式 $x^3+x+1$。这确实是不可还原的，因为你无法用整数对它进行因式分解。此外，它还能确保任何两个元素相乘都能得到一个度数为 2 或更小的多项式。

让我们以多项式 $x^3 + x + 1$ 为被除数，举例说明第二种运算是如何进行的。假设将集合 **S** 中的元素 $x^2 + 1$ 与 $x^2 + x$ 相乘。那么，我们需要计算表达式 $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1$。这可以简化如下


- $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1 =$
- $[x^2 \cdot x^2 + x^2 \cdot x + 1 \cdot x^2 + 1 \cdot x] \mod x^3 + x + 1 =$
- $[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$

我们知道，$[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$ 可以被还原，因为被除数（4）的度数比除数（3）的度数高。

首先，您可以看到表达式 $x^3 + x + 1$ 进入 $x^4 + x^3 + x^2 + x$ 的次数为 $x$。您可以用 $x^3 + x + 1$ 乘以 $x$，得到 $x^4 + x^2 + x$，从而验证这一点。由于后一项的度数与红利相同，即 4，因此我们知道这样做是可行的。您可以按如下方法计算除以 $x$ 的余数：


- $[(x^4 + x^3 + x^2 + x) - (x^4 + x^2 + x)] \mod x^3 + x + 1 =$
- $[x^3] （mod x^3 + x + 1 =$
- $x^3$

因此，将 $x^4 + x^3 + x^2 + x$ 除以 $x^3 + x + 1$ 共除以 $x$ 后，余数为 $x^3$。这个余数还能再除以 $x^3 + x + 1$吗？

直观地说，$x^3$ 不能再被$x^3 + x + 1$整除，因为后一项似乎更大。但是，请记住我们前面关于向量除法的讨论。只要被除数的阶数大于或等于除数，表达式就可以进一步缩小。具体地说，表达式 $x^3 + x + 1$ 恰好可以进入 $x^3$一次。余数的计算方法如下

$$
[(x^3) - (x^3 + x + 1)] \mod x^3 + x + 1 = [x + 1] \mod x^3 + x + 1 = x + 1
$$

你可能想知道为什么 $(x^3) - (x^3 + x + 1)$ 的值是 $x + 1$，而不是 $-x - 1$。请记住，我们字段的第一个运算是以 2 为模来定义的。因此，两个向量相减的结果与两个向量相加的结果完全相同。

总结一下 $x^2 + 1$ 和 $x^2 + x$ 的乘法：将这两个项相乘，可以得到一个四度多项式，即 $x^4 + x^3 + x^2 + x$，需要对 $x^3 + x + 1$ 进行化简。该 4 级多项式可被 $x^3 + x + 1$ 整除 x + 1$次。$x^4 + x^3 + x^2 + x$ 除以 $x^3 + x + 1$ 恰好 $x + 1$ 次后的余数是 $x+1$。这确实是我们的集合 $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$ 中的一个元素。

为什么基数为 2 的多项式集扩展域（如上面的例子）对密码学有用？原因在于你可以把多项式集合中的系数（0 或 1）看作具有特定长度的二进制字符串的元素。例如，上面例子中的集合 **S**，可以看作是包含所有长度为 3（000 到 111）的二进制字符串的集合 **S**。那么，对 **S** 的运算也可用于对这些二进制字符串进行运算，并产生相同长度的二进制字符串。

**注：**

[2] 扩展域变得非常反直觉。它们的元素不是整数，而是多项式集。此外，任何运算都是以某个不可还原多项式为模来进行的。

## 抽象代数实践

<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>

尽管讨论的语言很正式，也很抽象，但组群的概念应该不难理解。它只是一组元素和一个二元运算，对这些元素进行二元运算需要满足四个一般条件。无差别群只是多了一个称为交换性的条件。而循环群则是一种特殊的阿贝尔群，即有一个生成器的群。场只是基本群概念的一种更复杂的构造。

但是，如果你是一个有实践倾向的人，你可能会在这一点上产生疑问：谁在乎呢？知道某个带有算子的元素集合是一个群，甚至是一个阿贝尔群或循环群，在现实世界中有任何意义吗？知道某个东西是一个场吗？

无需赘述，答案是 "是"。19 世纪，法国数学家埃瓦里斯特-伽罗瓦（Evariste Galois）首次创建了数组。他利用它们得出了求解五级以上多项式方程的结论。

此后，群的概念帮助人们揭示了数学和其他领域的许多问题。例如，物理学家默里-盖尔曼（Murray-Gellman）根据群论，在实验中实际观测到粒子之前，就能预测粒子的存在。[3] 另一个例子是，化学家利用群论对分子的形状进行分类。数学家甚至利用群的概念对墙纸这样的具体事物得出结论！

从根本上说，表明具有某种算子的元素集合是一个群，意味着你所描述的东西具有特定的对称性。这不是普通意义上的对称，而是一种更抽象的形式。这可以为特定系统和问题提供实质性的见解。抽象代数中更复杂的概念只是为我们提供了额外的信息。

最重要的是，通过数论群和场在密码学，特别是公钥密码学中的应用，您将看到数论群和场在实践中的重要性。例如，我们在讨论字段时已经看到了扩展字段是如何应用于 Rijndael 密码中的。我们将在第5*章中演算这个例子。

如需进一步讨论抽象代数，我推荐您观看由 Socratica 制作的关于抽象代数的优秀系列视频。[4] 我特别推荐以下视频："什么是抽象代数？"、"群定义（扩展）"、"环定义（扩展）"和 "场定义（扩展）"。这四段视频会让你对上述讨论的大部分内容有更深入的了解。(我们没有讨论环，但场只是环的一种特殊类型）。

关于现代数论的进一步讨论，您可以参考许多关于密码学的高级讨论。我推荐乔纳森-卡茨（Jonathan Katz）和耶胡达-林德尔（Yehuda Lindell）的《现代密码学导论》（Introduction to Modern Cryptography）或克里斯托夫-帕尔（Christof Paar）和扬-佩尔兹尔（Jan Pelzl）的《密码学的理解》（Understanding Cryptography）。[5]

**注：**

[3] 参见 [YouTube 视频](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be)

[4] Socratica，[抽象代数](https://www.socratica.com/subject/abstract-algebra)

[5] Katz and Lindell, *Introduction to Modern Cryptography*, 2nd edn, 2015 (CRC Press: Boca Raton, FL)。Paar and Pelzl, *Understanding Cryptography*, 2010 (Springer-Verlag: Berlin).

# 对称加密

<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

## 爱丽丝和鲍勃

<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

对称密码学是密码学的两大分支之一。它包括加密方案以及与身份验证和完整性有关的方案。在 20 世纪 70 年代之前，所有密码学都由对称加密方案组成。

主要讨论从对称加密方案开始，并对流密码和块密码进行重要区分。然后，我们转向信息验证码，这是一种确保信息完整性和真实性的方案。最后，我们探讨如何将对称加密算法和信息验证码结合起来，确保通信安全。

本章顺带讨论了实践中的各种对称加密方案。下一章将从实践出发，分别详细阐述使用流密码和块密码（即 RC4 和 AES）进行加密的方法。

在开始讨论对称密码学之前，我想简要地谈谈本章和后续章节中的爱丽丝和鲍勃插图。

___

在说明密码学原理时，人们通常会以爱丽丝和鲍勃为例。我也会这样做。

尤其是初学密码学的人，一定要认识到这些爱丽丝和鲍勃的例子只是为了在简化的环境中说明密码学原理和构造。但是，这些原理和结构适用于现实生活中更广泛的环境。

关于密码学中涉及 Alice 和 Bob 的例子，需要牢记以下五个要点：

1.它们可以很容易地转化为其他类型行为者（如公司或政府组织）的例子。

2.它们可以很容易地扩展到包括三个或更多演员。

3.在这些例子中，鲍勃和爱丽丝通常会积极参与创建每条信息以及对该信息应用加密方案。但实际上，电子通信在很大程度上是自动化的。例如，当你访问一个使用传输层安全技术的网站时，加密技术通常全部由你的计算机和网络服务器处理。

4.在电子通信中，通过通信信道发送的 "信息 "通常是 TCP/IP 数据包。它们可以属于电子邮件、Facebook 消息、电话交谈、文件传输、网站、软件上传等。它们不是传统意义上的信息。尽管如此，密码学家通常会简化这一现实，例如将信息称为电子邮件。

5.这些例子通常以电子通信为重点，但也可扩展到信函等传统通信形式。

## 对称加密方案

<chapterId>41bfdbe1-6d41-5272-98bb-81f24b2fd6af</chapterId>

我们可以将**对称加密方案**宽泛地定义为任何包含三种算法的加密方案：

1.一种**密钥生成算法**，用于生成私人密钥。

2.一种**加密算法**，将私人密钥和明文作为输入，然后输出密文。

3.一种**解密算法**，它将私人密钥和密文作为输入，并输出原始明文。

通常情况下，加密方案--无论是对称还是非对称--都是基于核心算法的加密模板，而不是精确的规范。

例如，考虑一下对称加密方案 Salsa20。它既可以使用 128 位密钥长度，也可以使用 256 位密钥长度。密钥长度的选择会影响算法的一些小细节（确切地说是算法的轮数）。

但不能说使用 128 位密钥的 Salsa20 与使用 256 位密钥的 Salsa20 是不同的加密方案。核心算法是不变的。只有当核心算法发生变化时，我们才会说这是两种不同的加密方案。

对称加密方案通常在两种情况下有用：(1) 两个或多个代理进行远距离通信，并希望对通信内容保密；(2) 一个代理希望对信息内容进行跨时间保密。

您可以在下面的*图 1*中看到情况(1)的描述。鲍勃想向爱丽丝发送一条远距离信息 $M$，但不想让其他人读到这条信息。

鲍勃首先用私人密钥 $K$ 加密信息 $M$。然后，他将密文 $C$ 发送给爱丽丝。爱丽丝收到密文后，可以使用 $K$ 密钥解密并读取明文。有了一个好的加密方案，任何截获密文 $C$ 的攻击者应该都无法得知关于信息 $M$ 的任何重要信息。

您可以在下面的*图 2*中看到情况（2）的描述。鲍勃希望防止他人查看某些信息。典型的情况可能是，鲍勃是一名员工，他在自己的电脑上存储了敏感数据，外人和同事都不应该阅读这些数据。

鲍勃在时间 $T_0$ 时用密钥 $K$ 对信息 $M$ 进行加密，生成密文 $C$。在时间 $T_1$ 时，他再次需要该信息，并用密钥 $K$ 解密出密文 $C$。在此期间，任何可能接触到密文 $C$ 的攻击者都无法从中推断出有关 $M$ 的任何重要信息。

*图 1：跨空间保密*

![Figure 1: Secrecy across space](assets/Figure4-1.webp "Figure 1: Secrecy across space")

*图 2：跨时空保密*

![Figure 2: Secrecy across time](assets/Figure4-2.webp "Figure 2: Secrecy across time")

## 举个例子移位密码

<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

在第 2 章中，我们介绍了移位密码，它是一种非常简单的对称加密方案。让我们在这里再看一遍。

假设有一本字典 *D*，它将所有英文字母按顺序等同于一组数字 $/{0,1,2,\dots,25\}$。假设有一组可能的信息**M**。那么，移位密码是一种定义如下的加密方案：


- 从可能的密钥集合 **K** 中随机选择一个密钥 $k$，其中 **K** = $\{0,1,2,\dots,25\}$
- 对**M**中的 $m 信息加密如下
    - 将 $m$ 分离成各个字母 $m_0, m_1,\dots, m_i, \dots, m_l$
    - 根据 *D* 将每个 $m_i$ 转换成数字
    - 对于每个 $m_i$，$c_i = [(m_i + k)\mod 26]$
    - 根据 *D* 将每个 $c_i$ 转换成字母
    - 然后将 $c_0、c_1、\dots、c_l$ 合并，得到密码文本 $c$
- 解密密文 $c$ 的方法如下
    - 根据 *D* 将每个 $c_i$ 转换成数字
    - 对于每个 $c_i$，$m_i = [(c_i - k)\mod 26]$
    - 根据 *D* 将每个 $m_i$ 转换成字母
    - 然后合并 $m_0、m_1、\dots、m_l$，得到原始信息 $m$

移位密码之所以是一种对称加密方案，是因为在加密和解密过程中使用的是同一个密钥。例如，假设你想用移位密码加密信息 "DOG"，并随机选择 "24 "作为密钥。用这个密钥对信息进行加密就会得到 "BME"。要找回原始信息的唯一方法就是在解密过程中使用相同的密钥 "24"。

这种移位密码是**单字母替换密码**的一个例子：一种密文字母固定的加密方案（即只使用一种字母）。假设解密算法是确定的，那么替换密码中的每个符号最多只能与明文中的一个符号相关。

直到 1700 年代，许多加密应用都在很大程度上依赖于单字母替换密码，尽管这些密码往往比移位密码复杂得多。例如，您可以从字母表中随机选择一个字母来替换原文中的每个字母，但前提是每个字母只能在密文字母表中出现一次。这意味着你将有 26 个可能的私人密钥，这在前计算机时代是非常庞大的。

请注意，在密码学中你会经常遇到**密码**一词。请注意，这个术语有多种含义。事实上，据我所知，该词在密码学中至少有五种不同的含义。

在某些情况下，它指的是一种加密方案，如移位密码和单字母替换密码。不过，该术语也可以特指加密算法、私人密钥或任何此类加密方案的密文。

最后，"密码 "一词也可以指一种核心算法，你可以用它来构建密码方案。这些算法可以包括各种加密算法，也可以包括其他类型的加密方案。这种意义上的术语与块密码相关（见下文 "块密码 "部分）。

您可能还会遇到 "**加密**"或 "**解密**"等术语。这些术语只是加密和解密的同义词。

## 蛮力攻击和 Kerckhoff 原理

<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

至少在现代世界，移位密码是一种非常不安全的对称加密方案。[1] 攻击者可以尝试用所有 26 个可能的密钥对任何密文进行解密，看看哪个结果有意义。这种攻击方式被称为**蛮力攻击**或**穷举密钥搜索**。

任何加密方案要达到最基本的安全概念，都必须有一组可能的密钥，或称**密钥空间**，其规模之大，以至于暴力攻击是不可行的。所有现代加密方案都符合这一标准。这就是所谓的**足够密钥空间原则**。类似的原则通常适用于不同类型的加密方案。

为了了解现代加密方案中庞大的密钥空间大小，假设一个文件使用高级加密标准的 128 位密钥加密。这意味着攻击者有一组 2^{128}$ 的密钥，她需要循环使用这些密钥进行暴力攻击。如果这一策略的成功率为 0.78%，那么攻击者需要循环使用大约 2.65 美元乘以 10^{36}$ 的密钥。

假设我们乐观地假设攻击者每秒可以尝试 10^{16}$ 个密钥（即每秒 10 夸脱亿个密钥）。为了测试密钥空间中所有密钥的 0.78%，她的攻击必须持续 2.65 美元乘以 10^{20}$ 秒。这大约是 8.4 万亿年。因此，对于现代的 128 位加密方案来说，即使是一个强大到令人发指的对手进行暴力攻击也是不现实的。这就是充分密钥空间原理的作用。

如果攻击者不知道加密算法，移位密码是否更安全？也许吧，但不会太安全。

无论如何，现代密码学总是假定任何对称加密方案的安全性只依赖于私钥的保密。攻击者总是被假定知道所有其他细节，包括信息空间、密钥空间、密文空间、密钥选择算法、加密算法和解密算法。

对称加密方案的安全性只能依赖于私人密钥的保密性，这一观点被称为**克霍夫原理**。

按照 Kerckhoffs 的原意，该原则只适用于对称加密方案。不过，该原则的更一般版本也适用于现代所有其他类型的加密方案：任何加密方案的设计都不需要保密才能保证其安全性；保密性只能延伸到某些信息字符串，通常是私人密钥。

柯克霍夫斯原理是现代密码学的核心，原因有四。[2] 首先，只有数量有限的加密方案可用于特定类型的应用。例如，大多数现代对称加密应用都使用 Rijndael 密码。因此，你对方案设计的保密性非常有限。但是，对 Rijndael 密码的私人密钥进行保密的灵活性要大得多。

其次，替换某些信息字符串比替换整个加密方案更容易。假设一家公司的所有员工都拥有相同的加密软件，每两名员工都有一把私人密钥，可以进行保密通信。在这种情况下，密钥泄露是一件麻烦事，但至少公司可以在出现这种安全漏洞的情况下保留软件。如果公司依赖于该计划的保密性，那么任何对保密性的破坏都需要更换所有软件。

第三，Kerckhoffs 原则允许加密方案用户之间实现标准化和兼容性。这对提高效率大有裨益。例如，如果要保证安全就必须对加密方案保密，那么很难想象每天有几百万人如何安全地连接到谷歌的网络服务器。

第四，Kerckhoff 原则允许对加密方案进行公开审查。要实现安全的加密方案，这种审查是绝对必要的。举例来说，对称密码学的主要核心算法 Rijndael 密码就是美国国家标准与技术研究院在 1997 年至 2000 年间组织的一次竞赛的成果。

任何试图通过隐蔽实现**安全**的系统，都是一种依赖于对其设计和/或实施细节保密的系统。在密码学中，这具体是指依赖于对密码方案的设计细节保密的系统。因此，"隐蔽安全 "与 "凯尔克霍夫原理 "形成了直接对比。

开放性提高质量和安全性的能力在数字世界中的应用也比密码学更为广泛。例如，Debian 等自由开放源码 Linux 发行版在隐私、稳定性、安全性和灵活性方面通常比 Windows 和 MacOS 同类发行版更具优势。虽然这可能有多种原因，但最重要的原则可能就是埃里克-雷蒙德（Eric Raymond）在其著名的《大教堂与集市》一文中所说的："只要有足够多的眼球，所有的漏洞都是浅层次的"。[3] 正是这种 "群众智慧 "式的原则让 Linux 取得了最大的成功。

我们永远无法明确指出一个加密方案是 "安全的 "还是 "不安全的"。相反，密码方案有各种安全概念。每个密码安全性的**定义**都必须明确（1）安全目标，以及（2）攻击者的能力。根据一个或多个特定的安全概念来分析加密方案，可以深入了解其应用和局限性。

虽然我们不会深入探讨各种密码安全概念的所有细节，但你应该知道，有两个假设在所有现代密码安全概念中无处不在，它们涉及对称和非对称方案（以及某种形式的其他密码基元）：


- 攻击者对计划的了解符合凯克霍夫斯原理。
- 攻击者不可能对方案进行暴力破解。具体来说，密码安全概念的威胁模型通常甚至不允许暴力攻击，因为它们假定暴力攻击不是相关的考虑因素。

**注：**

[1] 根据 Seutonius 的说法，凯撒大帝在军事通信中使用了密钥值恒定为 3 的移位密码。因此，A 总是变成 D，B 总是变成 E，C 总是变成 F，以此类推。因此，这种特殊版本的移位密码被称为**凯撒密码**（尽管它并不是现代意义上的密码，因为密钥值是恒定的）。在公元前一世纪，如果罗马的敌人不熟悉加密技术，恺撒密码也许是安全的。但在现代，这显然不是一个非常安全的方案。

[2] Jonathan Katz 和 Yehuda Lindell，《现代密码学入门》，CRC Press（佛罗里达州博卡拉顿：2015 年），第 7 页以下。

[3] Eric Raymond，"The Cathedral and the Bazaar"，论文发表于德国维尔茨堡 Linux 大会（1997 年 5 月 27 日）。该论文在德国维尔茨堡 Linux Kongress 上发表（1997 年 5 月 27 日），随后有多个版本和一本书面世。我引用的是该书第 30 页的内容：Eric Raymond，_The Cathedral and the Bazaar：一个意外的革命者对 Linux 和开源的思考》，修订版（2001 年），O'Reilly 出版社。(2001), O'Reilly：加利福尼亚州塞巴斯托波尔。

## 流密码

<chapterId>479aa6f4-45c4-59ca-8616-8cf8e61fc871</chapterId>

对称加密方案按标准可细分为两种类型： **流密码**和块密码**。不过，这种区分有点麻烦，因为人们使用这些术语的方式并不一致。在接下来的几节中，我将以我认为最合适的方式阐述这种区别。不过，你应该意识到，许多人使用这些术语的方式与我所阐述的有些不同。

我们先来看看流密码。流密码**是一种对称加密方案，加密包括两个步骤。

首先，通过私人密钥生成一个长度与明文相同的字符串。这个字符串被称为**密钥流**。

接下来，密钥流与明文进行数学组合，生成密码文。这种组合通常是 XOR 运算。解密时，只需反向操作即可。(请注意，在 $A$ 和 $B$ 都是位串的情况下，$A \oplus B = B \oplus A$。因此，流密码中 XOR 运算的顺序对结果并不重要。这一特性被称为**交换性（**commutativity**)。

典型的 XOR 流密码如*图 3*所示。首先需要一个私人密钥 $K$ 并用它生成密钥流。然后，通过 XOR 运算将密钥流与明文结合，生成密文。任何收到密文的代理，只要拥有 $K$ 密钥，就能轻松解密。她所需要做的就是根据方案的指定程序创建一个与密文一样长的密钥流，并将其与密文进行 XOR 运算。

*图 3：XOR 流密码*

![Figure 3: An XOR stream cipher](assets/Figure4-3.webp "Figure 3: An XOR stream cipher")

请注意，加密方案通常是采用相同核心算法的加密模板，而不是精确的规范。推而广之，流密码通常是一种加密模板，可以使用不同长度的密钥。虽然密钥长度会影响方案的一些小细节，但不会影响其基本形式。

移位密码是一种非常简单且不安全的流密码。使用一个字母（私人密钥），就可以产生一串与信息长度相同的字母（密钥流）。然后，通过模运算将密钥流与明文结合，生成密文。(当字母以比特表示时，这种调制运算可简化为 XOR 运算）。

流密码的另一个有名的例子是**维基纳尔密码**，它是以布莱斯-德-维基纳尔（Blaise de Vigenere）的名字命名的。它是**多字母替换密码**的一个例子：在这种加密方案中，明文符号的密文字母会根据其在文本中的位置发生变化。与单字母替换密码不同的是，密文符号可以与多个明文符号相关联。

随着加密技术在文艺复兴时期的欧洲逐渐普及，**加密分析**--即破解密码文本--尤其是使用**频率分析**--也随之兴起。后者利用我们语言中的统计规律性来破解密码文本，早在 9 世纪就被阿拉伯学者发现。这种技术对较长的文本尤其有效。到了 1700 年代，在欧洲，尤其是在军事和安全领域，即使是最复杂的单字母置换密码也不足以对抗频率分析。由于维基解密在安全性方面取得了重大进步，它在这一时期开始流行，并在 17 世纪晚期得到广泛应用。

非正式地讲，加密方案的工作原理如下：

1.选择一个多字母单词作为私人密钥。

2.对于任何信息，使用关键词中的相应字母作为移位，对信息中的每个字母应用移位密码。

3.如果您已经循环使用了关键词，但仍未完全破译明文，则再次将关键词的字母作为移位密码应用于剩余文本中的相应字母。

4.继续这一过程，直到整个信息被加密。

举例说明，假设您的私人密钥是 "GOLD"，您想加密信息 "CRYPTOGRAPHY"。在这种情况下，您可以按照维尼哲密码进行如下操作：


- $c_0 = [(2 + 6)\mod 26] = 8 = I$
- $c_1 = [(17 + 14)\mod 26] = 5 = F$
- $c_2 = [(24 + 11)\mod 26] = 9 = J$
- $c_3 = [(15 + 3)\mod 26] = 18 = S$
- $c_4 = [(19 + 6)\mod 26] = 25 = Z$
- $c_5 = [(14 + 14)\mod 26] = 2 = C$
- $c_6 = [(6 + 11)\mod 26] = 17 = R$
- $c_7 = [(17 + 3)\mod 26] = 20 = U$
- $c_8 = [(0 + 6)\mod 26] = 6 = G$
- $c_9 = [(15 + 14)\mod 26] = 3 = D$
- $c_{10} = [(7 + 11)\mod 26] = 18 = S$
- $c_{11} = [(24 + 3) \mod 26] = 1 = B$

因此，密文 $c$ = "IFJSZCRUGDSB"。

流密码的另一个著名例子是**一次性密码本**。使用一次性密码本，只需创建一串与明文信息一样长的随机比特，然后通过 XOR 运算产生密文。因此，私钥和密钥流与一次性密码匙是等价的。

在现代，Shift 密码和 Vigenere 密码非常不安全，而一次性密码键盘如果使用得当，则非常安全。至少在 20 世纪 80 年代之前，一次性密码垫最著名的应用可能是**华盛顿-莫斯科热线**。[4]

该热线是古巴导弹危机后在华盛顿和莫斯科之间建立的直接通信联系，用于处理紧急事务。多年来，热线的技术已经发生了变化。目前，它包括一条直通光缆和两条卫星链路（用于冗余），可以发送电子邮件和短信。链接的终点位于美国的不同地方。已知的端点包括五角大楼、白宫和乌鸦岩山。与流行观点相反，该热线从未涉及电话。

从本质上讲，一次性密码垫计划的工作原理如下。华盛顿和莫斯科都有两组随机数。一组随机数由俄罗斯人创建，用于加密和解密俄语信息。一组随机数由美国人创建，用于加密和解密任何英语信息。更多的随机数将不时由可信赖的信使送到对方手中。

这样，华盛顿和莫斯科就可以利用这些随机数创建一次性密码，进行秘密通信。每次需要通信时，都会使用下一部分随机数来发送信息。

一次性密码键盘虽然安全性很高，但在实际应用中却面临着很大的限制：密钥的长度必须和信息的长度一样长，而且一次性密码键盘的任何部分都不能重复使用。这就意味着，你需要跟踪自己在一次性密码板中的位置，存储大量比特，并不时与对方交换随机比特。因此，一次性密码板在实际中并不常用。

取而代之的是，实际使用的主要流密码是**伪随机流密码**。Salsa20 和与之密切相关的变种 ChaCha 就是常用的伪随机流密码。

使用这些伪随机流密码时，首先要随机选择一个比明文长度短的密钥 K。这种随机密钥 K 通常是由计算机根据其长期收集的不可预测数据（如网络信息之间的时间间隔、鼠标移动等）创建的。

然后将随机密钥 $K$ 插入扩展算法中，该算法会创建一个与信息等长的伪随机密钥流。您可以精确指定密钥流的长度（如 500 位、1000 位、1200 位、29117 位等）。

伪随机密钥流看起来就好像是从所有长度相同的字符串集合中完全随机选择出来的一样。因此，使用伪随机密钥流加密看起来就像使用一次性密码垫加密一样。但事实当然并非如此。

由于我们的私人密钥比密钥流短，而我们的扩展算法必须是确定性的，这样加密/解密过程才能正常进行，因此并非每个特定长度的密钥流都能成为我们扩展操作的输出结果。

举例来说，假设我们的私人密钥长度为 128 比特，我们可以将其插入扩展算法，创建一个更长的密钥流，比如 2500 比特。由于我们的扩展算法需要确定性，因此我们的算法最多只能选择长度为 2,500 比特的 1/2^{128}$ 字符串。因此，这样的密钥流不可能从所有相同长度的字符串中完全随机选出。

我们对流密码的定义包括两个方面：(1) 借助私人密钥生成与明文一样长的密钥流；(2) 通常通过 XOR 运算将密钥流与明文结合，生成密文。

有时，人们对条件（1）的定义更为严格，认为密钥流必须特别是伪随机的。这意味着，移位密码和一次性密码匙都不属于流密码。

在我看来，更宽泛地定义条件(1)可以更容易地组织加密方案。此外，这还意味着我们不必因为了解到某个加密算法实际上并不依赖于伪随机密钥流，就不再把它称为流密码。

**注：**

[4] Crypto Museum，"华盛顿-莫斯科热线"，2013 年，见 [https://www.cryptomuseum.com/crypto/hotline/index.htm](https://www.cryptomuseum.com/crypto/hotline/index.htm)。

## 块密码

<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

**块密码**通常被理解为比流密码更原始的密码：它是一种核心算法，借助密钥对具有适当长度的字符串进行保长变换。这种算法可用于创建加密方案，也可用于创建其他类型的加密方案。

通常，区块密码可以接受 64、128 或 256 比特等不同长度的输入字符串，以及 128、192 或 256 比特等不同长度的密钥。虽然算法的某些细节可能会根据这些变量发生变化，但核心算法不会改变。如果核心算法改变了，我们就会谈论两种不同的块密码。请注意，这里使用的核心算法术语与加密方案相同。

下面的*图 4*描述了区块密码的工作原理。长度为 $L$ 的信息 $M$ 和密钥 $K$ 是块状密码的输入。它输出长度为 $L$ 的信息 $M'$。对于大多数块状密码来说，密钥的长度不一定要与 $M$ 和 $M'$ 相同。

*图 4：区块密码*

![Figure 4: A block cipher](assets/Figure4-4.webp "Figure 4: A block cipher")

区块密码本身并不是一种加密方案。但是，区块密码可以与各种**操作模式一起使用，从而产生不同的加密方案。操作模式只是在区块密码之外增加了一些额外的操作。

为说明其工作原理，假设有一个需要 128 位输入字符串和 128 位私人密钥的区块密码 (BC)。下图 5 显示了如何将该块状密码与**电子密码本模式**（**ECB 模式**）配合使用，创建加密方案。(右边的省略号表示你可以根据需要重复这种模式）。

*图 5：采用 ECB 模式*的分块密码

![Figure 5: A block cipher with ECB mode](assets/Figure4-5.webp "Figure 5: A block cipher with ECB mode")

使用块密码进行电子密码本加密的过程如下。看看能否将明文信息分成 128 位的块。如果不能，则在信息中添加 ** 填充**，使结果能被 128 位的块大小平均分割。这就是加密过程中使用的数据。

现在把数据分成 128 位字符串（$M_1$、$M_2$、$M_3$ 等）。用 128 位密钥对每个 128 位字符串进行分块密码运算，生成 128 位的密码文本块（$C_1$, $C_2$, $C_3$ 等）。这些区块重新组合后，就形成了完整的密码文本。

解密只是一个相反的过程，不过接收者确实需要一些可识别的方法来从解密数据中剥离任何填充，以生成原始的明文信息。

虽然相对简单，但采用电子密码本模式的分块密码缺乏安全性。这是因为它会导致**确定性加密**。任何两个相同的 128 位数据字符串的加密方式都完全相同。这一信息可以被利用。

相反，任何由块密码构建的加密方案都应该是**概率**的：也就是说，对任何信息 $M$或 $M$ 的任何特定块进行加密，通常每次都会产生不同的结果。[5]

**密码块链模式**（**CBC 模式**）可能是最常用的块密码模式。如果组合得当，就能产生一种概率加密方案。你可以在下面的*图 6*中看到这种操作模式的描述。

*图 6：采用 CBC 模式*的分块密码

![Figure 6: A block cipher with CBC mode](assets/Figure4-6.webp "Figure 6: A block cipher with CBC mode")

假设区块大小也是 128 比特。因此，开始时，您需要再次确保原始明文信息得到必要的填充。

然后，将明文的第一个 128 位部分与一个 128 位的**初始化向量**进行 XOR。将结果放入块密码，生成第一个块的密码密文。对于 128 位的第二个区块，首先将明文与第一个区块的密码文进行 XOR，然后再将其插入到区块密码中。这个过程一直持续到整个明文信息加密完毕。

完成后，将加密信息和未加密的初始化向量一起发送给收件人。收件人需要知道初始化向量，否则无法解密密文。

如果使用得当，这种结构比电子密码本模式安全得多。首先，应确保初始化向量是随机或伪随机字符串。此外，每次使用这种加密方案时，都应使用不同的初始化向量。

换句话说，你的初始化向量应该是随机或伪随机的非ce，其中**nonce**代表 "只使用一次的数字"。如果保持这种做法，那么使用块密码的 CBC 模式就能确保任何两个相同的明文块每次加密的方式都不同。

最后，让我们来看看**输出反馈模式**（**OFB 模式**）。您可以在*图 7*中看到这种模式的描述。

*图 7：采用 OFB 模式的块密码* 图 8：采用 OFB 模式的块密码

![Figure 7: A block cipher with OFB mode](assets/Figure4-7.webp "Figure 7: A block cipher with OFB mode")

在 OFB 模式下，你也可以选择一个初始化向量。但在这里，对于第一个区块，初始化向量会与密钥一起直接插入到区块密码中。由此产生的 128 位密钥将被视为密钥流。该密钥流与明文进行 XOR，生成该加密块的密文。对于后续区块，则使用前一个区块的密钥流作为输入到区块密码中，然后重复上述步骤。

如果你仔细观察，就会发现这里使用 OFB 模式的分块密码实际上是一种流密码。你可以生成 128 位的密钥流部分，直到得到明文长度（从最后 128 位的密钥流部分丢弃不需要的位）。然后，将密钥流与明文信息进行 XOR 运算，得到密文。

在上一节关于流密码的内容中，我提到过借助私钥来生成密钥流。确切地说，并不是只有私钥才能生成密钥流。正如你在 OFB 模式中看到的那样，密钥流是在私钥和初始化向量的支持下产生的。

请注意，与 CBC 模式一样，每次在 OFB 模式下使用区块密码时，都必须为初始化向量选择一个伪随机或随机的 nonce。否则，在不同通信中发送的相同 128 位信息字符串将以相同方式加密。这就是使用流密码创建概率加密的一种方法。

有些流密码只使用私钥创建密钥流。对于这些流密码，重要的是每次通信都要使用随机非ce 来选择私钥。否则，使用这些流密码进行加密的结果也将是确定的，从而导致安全问题。

最流行的现代区块密码是**Rijndael密码**。它是美国国家标准与技术研究院（NIST）在 1997 年至 2000 年间为取代旧的加密标准--**数据加密标准**（**DES**）而举办的竞赛中 15 个参赛者中的优胜者。

Rijndael 密码可以在不同的密钥长度和区块大小规格以及不同的运行模式下使用。作为**高级加密标准**（**AES**）的一部分，NIST 竞赛委员会采用了 Rijndael 密码的限制版本，即要求 128 位的数据块大小和 128 位、192 位或 256 位的密钥长度。这确实是对称加密应用的主要标准。它非常安全，甚至美国国家安全局显然也愿意使用它的 256 位密钥来处理绝密文件。[6]

第 5* 章将详细解释 AES 区块密码。

**注：**

[5] Shafi Goldwasser 和 Silvio Micali 首次强调了概率加密的重要性，"概率加密"，_Journal of Computer and System Sciences_，28 (1984)，270-99。

[6] 见美国国家安全局，"商业国家安全算法套件"，[https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm](https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm)。

## 消除混淆

<chapterId>121c1858-27e3-5862-b0ce-4ff2f70f9f0f</chapterId>

之所以会混淆块密码和流密码的区别，是因为有时人们会把块密码理解为专门指具有块加密模式的*块密码*。

请看上一节中的 ECB 和 CBC 模式。这些模式特别要求用于加密的数据必须能被区块大小整除（这意味着可能需要为原始信息使用填充）。此外，在这些模式中，数据还直接由块密码操作（而不是像在 OFB 模式中那样，只是与块密码操作的结果相结合）。

因此，你也可以将**块密码**定义为任何加密方案，它每次对固定长度的信息块进行操作（其中任何信息块的长度都必须大于一个字节，否则就会坍缩为流密码）。用于加密的数据和密文都必须平均分配到这个块大小中。通常情况下，加密块的长度为 64、128、192 或 256 比特。相比之下，流密码可以每次加密一个比特或字节的信息块。

有了对块状密码的这种更具体的理解，你确实可以说现代加密方案要么是流密码，要么是块状密码。从现在起，除非另有说明，我将在更广泛的意义上使用 "区块密码 "一词。

上一节关于 OFB 模式的讨论还提出了另一个有趣的问题。有些流密码由块密码创建，如带有 OFB 的 Rijndael。有些流密码（如 Salsa20 和 ChaCha）并不是由块密码创建的。你可以称后者为**原始流密码**。(目前还没有一个真正标准化的术语来指代此类流密码）。

当人们谈论流密码和块状密码的优缺点时，通常是将原始的流密码与基于块状密码的加密方案进行比较。

虽然你总是可以很容易地从一个区块密码中构造出一个流密码，但要从一个原始的流密码中构造出某种具有区块加密模式（如 CBC 模式）的密码通常是非常困难的。

通过以上讨论，你现在应该了解*图 8*。它概述了对称加密方案。我们使用三种加密方案：原始流密码、块密码流密码和块模式的块密码（图中也称为 "块密码"）。

*图 8：对称加密方案概述*

![Figure 8: Overview of symmetric encryption schemes](assets/Figure4-8.webp "Figure 8: Overview of symmetric encryption schemes")

## 信息验证码

<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>

加密与保密有关。但密码学还涉及更广泛的主题，如信息完整性、真实性和不可否认性。所谓的**信息验证码**（MAC）是一种对称密钥加密方案，支持通信的真实性和完整性。

为什么在通信中只需要保密？假设鲍勃使用几乎无法破解的加密技术向爱丽丝发送了一条信息。任何截获该信息的攻击者都无法确定信息内容的任何重要信息。但是，攻击者至少还可以利用另外两个攻击向量：

1.她可以截获密文，更改密文内容，并将更改后的密文发送给爱丽丝。

2.她可以完全屏蔽鲍勃的信息，然后发送自己创建的密文。

在这两种情况下，攻击者可能无法从密文（1）和（2）中了解到任何内容。但她仍然可以通过这种方式造成重大损失。这就是信息验证码的重要性所在。

信息验证码被宽泛地定义为具有三种算法的对称加密方案：密钥生成算法、标签生成算法和验证算法。安全的 MAC 可确保标签对任何攻击者来说都是**存在的不可伪造**，也就是说，除非攻击者拥有私人密钥，否则他们无法在验证的信息上成功创建标签。

鲍勃和爱丽丝可以使用 MAC 对付对特定信息的篡改。假设他们暂时不关心保密问题。他们只想确保 Alice 收到的信息确实来自 Bob，并且没有以任何方式更改。

过程如*图 9*所示。要使用**MAC**（信息验证码），他们首先要生成一个两人共享的私人密钥 $K$。鲍勃使用私人密钥 $K$ 为信息创建一个标签 $T$。然后，他将信息和信息标签发送给爱丽丝。然后，爱丽丝可以通过验证算法运行私人密钥、信息和标签，验证鲍勃确实制作了标签。

*图 9：对称加密方案概览*

![Figure 9: Overview of symmetric encryption schemes](assets/Figure4-9.webp "Figure 9: Overview of symmetric encryption schemes")

由于**存在的不可伪造性**，攻击者无法以任何方式更改信息 $M$，也无法用有效标记创建自己的信息。即使攻击者观察到鲍勃和爱丽丝之间使用相同私人密钥的许多信息的标记，情况也是如此。攻击者最多只能阻止爱丽丝接收信息 $M$（这是密码学无法解决的问题）。

MAC 可保证信息确实是由鲍勃创建的。这种真实性自动意味着信息的完整性--也就是说，如果鲍勃创建了某条信息，那么它当然不会被攻击者以任何方式篡改。因此，从这里开始，任何对认证的关注都应自动理解为对完整性的关注。

虽然我在讨论中对信息的真实性和完整性进行了区分，但将这两个词作为同义词使用也很常见。它们指的是信息既是由某个特定发送者创建的，又没有被以任何方式篡改过。本着这种精神，信息验证码通常也被称为**信息完整性码**。

## 认证加密

<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>

通常情况下，您希望同时保证通信的保密性和真实性，因此加密方案和 MAC 方案通常会一起使用。

**验证加密方案**是一种以高度安全的方式将加密与 MAC 结合在一起的方案。具体来说，它必须符合存在不可伪造性标准以及非常强的保密概念，即能够抵御**选密文攻击**。[7]

为了使加密方案能够抵御选择密文攻击，它必须符合**非可变性**的标准：即攻击者对密文的任何修改要么产生无效密文，要么解密出与原始密文毫无关系的明文。[8]

由于经过验证的加密方案能确保攻击者创建的密文总是无效的（因为标签不会被验证），因此它符合抵御选择密文攻击的标准。有趣的是，你可以证明，从存在不可伪造的 MAC 和符合较弱安全概念的加密算法（即**选择明文攻击安全**）的组合中，总能创建一个经过验证的加密算法。

我们不会深入探讨构建验证加密方案的所有细节。但了解其构造的两个细节很重要。

首先，验证加密方案首先处理加密，然后在密文上创建信息标签。事实证明，其他方法--例如将密文与明文上的标签相结合，或首先创建一个标签，然后对明文和标签进行加密--都是不安全的。此外，这两种操作都有各自随机选择的私钥，否则会严重影响安全性。

上述原则适用于更广泛的情况： *在组合基本加密方案时，应始终使用不同的密钥*。

图 10* 描述了一个经过验证的加密方案。鲍勃首先使用随机选择的密钥 $K_C$，从信息 $M$ 中创建密文 $C$。然后，他通过标签生成算法运行密文和另一个随机选择的密钥 $K_T$，创建信息标签 $T$。密码文本和信息标签都发送给爱丽丝。

现在，爱丽丝首先根据密文 $C$ 和密钥 $K_T$ 检查标签是否有效。如果有效，她就可以使用 $K_C$ 密钥解密信息。这样，爱丽丝不仅可以确保他们之间的通信具有很强的保密性，而且还知道信息是由鲍勃创建的。

*图 10：验证加密方案*

![Figure 10: An authenticated encryption scheme](assets/Figure4-10.webp "Figure 10: An authenticated encryption scheme")

如何创建 MAC？虽然可以通过多种方法创建 MAC，但创建 MAC 的常用高效方法是**加密散列函数**。

我们将在第 6*章中更深入地介绍加密哈希函数。现在，我们只需知道**散列函数**是一种可高效计算的函数，它接受任意大小的输入，并产生固定长度的输出。例如，流行的散列函数**SHA-256**（安全散列算法 256）无论输入的大小如何，总是生成 256 位的输出。一些散列函数，如 SHA-256，在密码学中有着有用的应用。

使用加密散列函数生成的最常见标签类型是基于散列的消息验证码**（HMAC）。其过程如*图 11*所示。一方用私人密钥 $K$ 生成两个不同的密钥，即内密钥 $K_1$ 和外密钥 $K_2$。然后将明文 $M$ 或密码文 $C$ 与内密钥一起散列。然后将结果 $T'$ 与外钥散列，生成信息标签 $T$。

有多种散列函数可用于创建 HMAC。最常用的散列函数是 SHA-256。

*图 11：HMAC*

![Figure 11: HMAC](assets/Figure4-11.webp "Figure 11: HMAC")

**注：**

[7] 本节讨论的具体结果来自 Katz 和 Lindell，第 131-47 页。

[8] 从技术上讲，选择密码文本攻击的定义与不可并行性的概念不同。但你可以证明这两个安全概念是等价的。

## 安全通信会话

<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

假设双方正在进行通信会话，因此他们来回发送多条信息。

经过验证的加密方案允许信息接收者验证信息是由通信会话中的伙伴创建的（只要私人密钥没有泄露）。这对于单条信息来说已经足够有效。但通常情况下，双方会在通信会话中来回发送信息。在这种情况下，上一节所述的普通验证加密方案就无法提供安全性。

主要原因是认证加密方案无法保证信息确实也是由在通信会话中创建信息的代理发送的。请考虑以下三种攻击向量：

1. **重放攻击**：攻击者重新发送她在较早时候在双方之间截获的密文和标记。

2. **重新排序攻击**：攻击者在不同时间截获两条信息，并以相反的顺序发送给收件人。

3. **反射攻击**：攻击者观察到从 A 发送到 B 的信息，同时也将该信息发送到 A。

虽然攻击者不知道密码文本，也无法创建欺骗密码文本，但上述攻击仍可对通信造成重大破坏。

例如，假设双方之间的某条信息涉及金融资金的转移。重放攻击可能会第二次转移资金。普通的验证加密方案无法抵御这种攻击。

幸运的是，在通信会话中使用**标识符**和**相对时间指示器**，可以轻松缓解这类攻击。

可以在加密前在明文信息中添加标识符。这将阻止任何反射攻击。例如，相对时间标识符可以是特定通信会话中的序列号。每一方在加密前都会在信息中添加一个序列号，这样收件人就知道信息是按什么顺序发送的。这就消除了重新排序攻击的可能性。这也消除了重放攻击。攻击者向下发送的任何信息都会有一个旧的序列号，收件人就会知道不能再处理该信息。

为了说明安全通信会话是如何工作的，再假设 Alice 和 Bob。他们一共来回发送四条信息。你可以在*图 11* 中看到带有标识符和序列号的验证加密方案是如何工作的。

通信会话开始时，鲍勃向爱丽丝发送带有信息标记 $T_{0,B}$ 的密码文 $C_{0,B}$。密文包含信息、标识符（BOB）和序列号（0）。标签 $T_{0,B}$ 是在整个密文中生成的。在随后的通信中，爱丽丝和鲍勃会保持这一协议，并在必要时更新字段。

*图 12：安全通信会话*

![Figure 12: A secure communication session](assets/Figure4-12.webp "Figure 12: A secure communication sessesion")

# RC4 和 AES

<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

## RC4 流密码

<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>

在本章中，我们将讨论使用现代原始流密码 RC4（或 "Rivest cipher 4"）和现代块密码 AES 的加密方案的细节。RC4 作为一种加密方法已不受欢迎，而 AES 则是现代对称加密的标准。通过这两个例子，我们可以更好地了解对称加密的工作原理。

___

为了了解现代伪随机流密码的工作原理，我将重点介绍 RC4 流密码。这是一种伪随机流密码，曾用于 WEP 和 WAP 无线接入点安全协议以及 TLS。由于 RC4 有许多已被证实的弱点，它已不受欢迎。事实上，互联网工程任务组现在禁止客户端和服务器应用程序在所有 TLS 实例中使用 RC4 套件。尽管如此，RC4 仍能很好地举例说明原始流密码的工作原理。

首先，我将演示如何使用婴儿 RC4 密码加密明文信息。假设我们的明文信息是 "SOUP"。那么，使用我们的 RC4 小密码进行加密需要四个步骤。

### 步骤 1

首先，定义一个数组 **S**，其中$S[0] = 0$ 至$S[7] = 7$。这里的数组是指一个由索引组织的可变值集合，在某些编程语言（如 Python）中也称为列表。在本例中，索引从 0 到 7，值也从 0 到 7。 因此，**S** 如下：


- $S = [0, 1, 2, 3, 4, 5, 6, 7]$

这里的值不是 ASCII 数字，而是 1 字节字符串的十进制值。因此，值 2 等于 $0000 \ 0011$。因此，数组 **S** 的长度为 8 字节。

### 步骤 2

其次，定义一个长度为 8 字节的密钥数组 **K**，在 1 到 8 字节之间选择一个密钥（不允许小数字节）。由于每个字节都是 8 位，您可以为密钥的每个字节选择 0 到 255 之间的任意数字。

假设我们将键 **k** 选为 $[14,48,9]$，这样它的长度就是 3 个字节。那么，键数组的每个索引都将按照键元素的十进制值依次设置。如果你运行了整个键，就从头开始，直到填满键数组的 8 个插槽。因此，我们的键数组如下


- $K = [14, 48, 9, 14, 48, 9, 14, 48]$

### 步骤 3

第三，我们将使用键数组**K**对数组**S**进行转换，这一过程称为**键调度**。该过程的伪代码如下：


- 创建变量 **j** 和 **i**
- 设置变量 $j = 0$
- 从 0 到 7 的每个 $i$：
    - 设 $j = (j + S[i] + K[i])\mod 8$
    - 交换 $S[i]$ 和 $S[j]$

表 1**记录了数组**S**的变换。

首先，可以看到 **S** 的初始状态为 $[0,1,2,3,4,5,6,7]$，**j** 的初始值为 0。这将通过键数组 $[14, 48, 9, 14, 48, 9, 14, 48]$ 进行转换。

for 循环从 $i = 0$ 开始。根据我们上面的伪代码，**j** 的新值变为 6（$j = (j + S[0] + K[0]) \mod 8 = (0 + 0 + 14) \mod 8 = 6 \mod 8$）。交换$S[0]$和$S[6]$，一轮后**S**的状态变为$[6, 1, 2, 3, 4, 5, 0, 7]$。

在下一行中，$i = 1$。再次通过 for 循环，**j** 的值为 7（$j = (j + S[1] + K[1]) \mod 8 = (6 + 1 + 48) \mod 8 = 55 \mod 8 = 7 \mod 8$）。从**S**的当前状态$[6, 1, 2, 3, 4, 5, 0, 7]$交换$S[1]$和$S[7]$，第二轮后得到$[6, 7, 2, 3, 4, 5, 0, 1]$。

我们继续这个过程，直到产生数组**S**底部的最后一行，$[6, 4, 1, 0, 3, 7, 5, 2]$。

*表 1：关键日程表*

| Round | i | j | | S[0] | S[1] | S[2] | S[3] | S[4] | S[5] | S[6] | S[7] |

| ------- | --- | --- | --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

| | | | | | | | | | | | |

| 初始 | | 0 | | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |

| 1 | 0 | 6 | | 6 | 1 | 2 | 3 | 4 | 5 | 0 | 7 |

| 2 | 1 | 7 | | 6 | 7 | 2 | 3 | 4 | 5 | 0 | 1 |

| 3 | 2 | 2 | | 6 | 7 | 2 | 3 | 4 | 5 | 0 | 1 |

| 4 | 3 | 3 | | 6 | 7 | 2 | 3 | 4 | 5 | 0 | 1 |

| 5 | 4 | 3 | | 6 | 7 | 2 | 0 | 3 | 5 | 4 | 1 |

| 6 | 5 | 6 | | 6 | 4 | 2 | 0 | 3 | 7 | 5 | 1 |

| 7 | 6 | 1 | | 6 | 4 | 2 | 0 | 3 | 7 | 5 | 2 |

| 8 | 7 | 2 | | 6 | 4 | 1 | 0 | 3 | 7 | 5 | 2 |

### 步骤 4

第四步，我们生成**关键流**。这是与我们要发送的信息长度相等的伪随机字符串。它将用于加密原始信息 "SOUP"。由于密钥流需要与信息一样长，我们需要一个 4 字节的密钥流。

密钥流由以下伪代码产生：


- 创建变量 **j**、**i** 和 **t**。
- 设置 $j = 0$。
- 对于明文中的每一个 $i$，从 $i = 1$开始，直到 $i = 4$为止，密钥流的每个字节都按如下方式生成：
    - $j = (j + S[i]) \mod 8$
    - 交换 $S[i]$ 和 $S[j]$。
    - $t = (S[i] + S[j])\mod 8$
    - 密钥流的 $i^{th}$ 字节 = $S[t]$

计算结果见表 2*。

**S** 的初始状态为 $S = [6, 4, 1, 0, 3, 7, 5, 2]$ 。设置 $i = 1$，**j**的值变为 4（$j = (j + S[i]) \mod 8 = (0 + 4) \mod 8 = 4$）。然后我们交换 $S[1]$ 和 $S[4]$，得出第二行中**S**的变换，即 $[6, 3, 1, 0, 4, 7, 5, 2]$。这样，**t** 的值就是 7（$t = (S[i] + S[j]) \mod 8 = (3 + 4) \mod 8 = 7$）。最后，密钥流的字节为 $S[7]$，即 2。

然后，我们继续生成其他字节，直到得到以下四个字节：2、6、3 和 7。然后，这些字节都可以用来加密明文 "SOUP "的每个字母。

首先，使用 ASCII 表格，我们可以看到 "SOUP "由底层字节串的十进制值编码为 "83 79 85 80"。与密钥流 "2 6 3 7 "组合后得到 "85 85 88 87"，经过 256 模运算后保持不变。在 ASCII 码中，密码文本 "85 85 88 87 "等于 "UUXW"。

如果要加密的单词比**S**数组长，会发生什么情况？在这种情况下，数组**S**就会按照上面显示的方式对明文中的每一个字节**i**进行变换，直到密钥流中的字节数与明文中的字母数相等为止。

*表 2：关键流程生成*

| i | j | t | 键流 | S[0] | S[1] | S[2] | S[3] | S[4] | S[5] | S[6] | S[7] | 键流

| --- | --- | --- | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

| | | | | | | | | | | | |

| | 0 | | | 6 | 4 | 1 | 0 | 3 | 7 | 5 | 2 |

| 1 | 4 | 7 | 2 | 6 | 3 | 1 | 0 | 4 | 7 | 5 | 2 |

| 2 | 5 | 0 | 6 | 6 | 3 | 7 | 0 | 4 | 1 | 5 | 2 |

| 3 | 5 | 1 | 3 | 6 | 3 | 7 | 1 | 4 | 0 | 5 | 2 |

| 4 | 1 | 7 | 2 | 6 | 4 | 7 | 1 | 3 | 0 | 5 | 2 |

我们刚才讨论的例子只是**RC4 流密码**的缩水版。实际的 RC4 流密码的**S**数组长度为 256 字节，而不是 8 字节，密钥长度为 1 到 256 字节，而不是 1 到 8 字节。密钥数组和密钥流的产生都要考虑到 **S** 数组的 256 字节长度。计算变得复杂得多，但原理保持不变。使用相同的密钥 [14,48,9]，并使用标准 RC4 密码，明文信息 "SOUP "将以十六进制格式加密为 67 02 ed df。

密钥流的更新与明文信息或密文无关的流密码是**同步流密码**。密钥流只取决于密钥。显然，RC4 就是同步流密码的一个例子，因为密钥流与明文或密文没有任何关系。上一章提到的所有原始流密码，包括移位密码、维吉涅尔密码和一次性密码笺，也都属于同步流密码。

相比之下，**异步流密码**的密钥流是由密钥和密文的前一个元素共同产生的。这类密码也被称为**自同步密码**。

重要的是，使用 RC4 生成的密钥流应被视为一次性密码垫，下次不能以完全相同的方式生成密钥流。与其每次都改变密钥，不如将密钥与**nonce**结合起来，生成字节流。

## 128 位密钥的 AES

<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

如前一章所述，美国国家标准与技术研究院（NIST）在 1997 年至 2000 年期间举行了一次竞赛，以确定新的对称加密标准。最终，**Rijndael 密码**胜出。这个名字是比利时创造者文森特-瑞门（Vincent Rijmen）和琼-戴门（Joan Daemen）名字的文字游戏。

Rijndael 密码是一种**块密码**，这意味着它有一个核心算法，可用于不同规格的密钥长度和块大小。这样，你就可以用不同的操作模式来构建加密方案。

作为**高级加密标准（AES）**的一部分，NIST 竞赛委员会采用了 Rijndael 密码的限制版本--即要求 128 位的数据块大小和 128 位、192 位或 256 位的密钥长度。这种受限版本的 Rijndael 密码也可以在多种操作模式下使用。该标准的规范就是所谓的**高级加密标准（AES）**。

为了展示 AES 的核心 Rijndael 密码是如何工作的，我将说明使用 128 位密钥进行加密的过程。密钥大小会影响每个加密块的轮数。128 位密钥需要 10 轮加密。如果是 192 位和 256 位，则分别需要 12 轮和 14 轮。

此外，我将假设 AES 在 **ECB-模式下使用。这使得论述稍微简单一些，对 Rijndael 算法来说并不重要。可以肯定的是，ECB 模式在实践中并不安全，因为它会导致确定性加密。AES 最常用的安全模式是 **CBC**（加密块链路）。

我们把密钥称为 $K_0$。那么，使用上述参数的结构如*图 1*所示，其中 $M_i$ 代表 128 比特明文信息的一部分，$C_i$ 代表 128 比特密码文本的一部分。如果明文无法被加密块大小平均分割，则在最后一个加密块的明文中加入填充。

*图 1：使用 128 位密钥的 AES-ECB*

![Figure 1: AES-ECB with a 128-bit key](assets/Figure5-1.webp "Figure 1: AES-ECB with a 128-bit key")

在 Rijndael 加密算法中，每个 128 位的文本块都要经过十轮加密。这就要求每一轮（$K_1$ 到 $K_{10}$）都有一个单独的轮次密钥。这些密钥是使用**密钥扩展算法**，从最初的 128 位密钥 $K_0$ 生成的。因此，对于要加密的每个文本块，我们将使用原始密钥 $K_0$ 和 10 个独立的轮次密钥。请注意，这 11 个密钥同样用于需要加密的每个 128 位明文块。

密钥扩展算法冗长而复杂。研究它对教学没有什么好处。如果你愿意，可以自己研究一下密钥扩展算法。如*图 2*所示，一旦产生了圆密钥，Rijndael 密码就会处理第一个 128 位的明文块 $M_1$。现在我们就来完成这些步骤。

*图 2：使用 Rijndael 密码操作 $M_1$*

**第 0 轮：**


- XOR $M_1$ 和 $K_0$ 生成 $S_0$

---
**n={1，......，9}时的第 n 轮：**


- XOR $S_{n-1}$ 和 $K_n$
- 字节替换
- 移位行
- 混合栏
- XOR $S$ 和 $K_n$ 产生 $S_n$

---
**第 10 轮：**


- XOR $S_9$ 和 $K_{10}$
- 字节替换
- 移位行
- XOR $S$ 和 $K_{10}$ 生成 $S_{10}$
- $s_{10}$ = $c_1$

### 第 0 轮

Rijndael 密码的第 0 轮运算非常简单。128 位明文和私人密钥通过 XOR 运算产生一个数组 $S_0$。也就是说


- $S_0 = M_1 \oplus K_0$

### 第一轮

在第 1 轮中，首先使用 XOR 运算将数组 $S_0$ 与回合密钥 $K_1$ 结合起来。这样就产生了一个新的状态 $S$。

其次，**字节替换**操作是对$S$的当前状态执行的。它的工作原理是从 16 字节的 $S$ 数组中提取每个字节，然后用一个名为**Rijndael's S-box** 的数组中的字节进行替换。每个字节都有一个独特的变换，并由此产生 $S$ 的新状态。图 3**显示了 Rijndael 的 S-box。

*图 3：Rijndael 的 S-Box*

| | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 0a | 0b | 0c | 0d | 0e | 0f | 0a | 0b | 0c | 0d | 0e | 0f | 0d | 0e | 0f | 0f

| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

| 00 | 63 | 7c | 77 | 7b | f2 | 6b | 6f | c5 | 30 | 01 | 67 | 2b | fe | d7 | ab | 76 |

| 10 | ca | 82 | c9 | 7d | fa | 59 | 47 | f0 | ad | d4 | a2 | af | 9c | a4 | 72 | c0 |

| 20 | B7 | FD | 93 | 26 | 36 | 3F | F7 | CC | 34 | A5 | E5 | F1 | 71 | D8 | 31 | 15 |

| 30 | 04 | c7 | 23 | c3 | 18 | 96 | 05 | 9a | 07 | 12 | 80 | e2 | eb | 27 | b2 | 75 |

| 40 | 09 | 83 | 2c | 1a | 1b | 6e | 5a | a0 | 52 | 3b | d6 | b3 | 29 | e3 | 2f | 84 |

| 50 | 53 | d1 | 00 | ed | 20 | fc | b1 | 5b | 6a | cb | be | 39 | 4a | 4c | 58 | cf |

| 60 | D0 | EF | AA | FB | 43 | 4D | 33 | 85 | 45 | F9 | 02 | 7F | 50 | 3C | 9F | A8 |

| 70 | 51 | a3 | 40 | 8f | 92 | 9d | 38 | f5 | bc | b6 | da | 21 | 10 | ff | f3 | d2 |

| 80 | cd | 0c | 13 | ec | 5f | 97 | 44 | 17 | c4 | a7 | 7e | 3d | 64 | 5d | 19 | 73 |

| 90 | 60 | 81 | 4f | DC | 22 | 2a | 90 | 88 | 46 | ee | b8 | 14 | de | 5e | 0b | DB |

| a0 | e0 | 32 | 3a | 0a | 49 | 06 | 24 | 5c | c2 | d3 | ac | 62 | 91 | 95 | e4 | 79 |

| B0 | E7 | C8 | 37 | 6D | 8D | D5 | 4E | A9 | 6C | 56 | F4 | EA | 65 | 7A | AE | 08 |

| c0 | ba | 78 | 25 | 2e | 1c | a6 | b4 | c6 | e8 | dd | 74 | 1f | 4b | bd | 8b | 8a |

| D0 | 70 | 3E | B5 | 66 | 48 | 03 | F6 | 0E | 61 | 35 | 57 | B9 | 86 | C1 | 1D | 9E |

| e0 | e1 | f8 | 98 | 11 | 69 | d9 | 8e | 94 | 9b | 1e | 87 | e9 | ce | 55 | 28 | df |

| f0 | 8c | a1 | 89 | 0d | bf | e6 | 42 | 68 | 41 | 99 | 2d | 0f | b0 | 54 | bb | 16 |

S-Box 是抽象代数在 Rijndael 密码中发挥作用的一个地方，特别是**伽罗瓦字段**。

首先，将 00 至 FF 每个可能的字节元素定义为一个 8 位向量。每个这样的向量都是**伽罗瓦场 GF(2^8)** 的一个元素，其中模运算的不可约多项式是 $x^8+x^4+x^3+x+1$。具有这些规格的伽罗瓦域也被称为**里恩戴尔有限域**。

接下来，对于字段中的每一个可能元素，我们都要创建所谓的 "尼伯格 S 框"（**Nyberg S-Box）。在这个框中，每个字节都被映射到其**乘法逆**上（即它们的乘积等于 1）。然后，我们使用**affine 变换**将这些值从 Nyberg S-box 映射到 Rijndael 的 S-Box。

对**S**数组的第三个操作是**移行**操作。它利用 **S** 的状态，将所有 16 个字节列成一个矩阵。矩阵的填充从左上角开始，从上到下依次进行，每填充一列，就向右移动一列到顶部。

构建**S**矩阵后，对四行进行移位。第一行保持不变。第二行向左移动一行。第三行向左移动两行。第四行向左移动三行。图 4*提供了这一过程的示例。上方显示的是**S**的原始状态，下方显示的是移行操作后的结果状态。

*图 4：移位行操作*

| f1 | a0 | b1 | 23 |

|------|------|------|------|

| 59 | EF | 09 | 82 |

| 97 | 01 | b0 | cc | 97 | 01 | b0 | cc | cc

| D4 | 72 | 04 | 21 |

| f1 | a0 | b1 | 23 |

|------|------|------|------|

| EF | 09 | 82 | 59 |

| B0 | CC | 97 | 01 |

| 21 | D4 | 72 | 04 |

第四步，**伽罗瓦场**再次出现。首先，**S**矩阵的每一列与*图 5*中的 4 x 4 矩阵的每一列相乘。但这不是普通的矩阵乘法，而是矢量乘法，**模为不可约多项式**，$x^8 + x^4 + x^3 + x + 1$。由此产生的矢量系数代表一个字节的各个比特。

*图 5：混合列矩阵*

| 02 | 03 | 01 | 01 |

|------|------|------|------|

| 01 | 02 | 03 | 01 |

| 01 | 01 | 02 | 03 |

| 03 | 01 | 01 | 02 |

将**S**矩阵的第一列与上述 4 x 4 矩阵相乘，结果如*图 6*所示。

*图 6：第一列的乘法：*

$$
\begin{matrix}
02 \cdot F1 + 03 \cdot EF + 01 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 02 \cdot EF + 03 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 01 \cdot EF + 02 \cdot B0 + 03 \cdot 21 \\
03 \cdot F1 + 01 \cdot EF + 01 \cdot B0 + 02 \cdot 21
\end{matrix}
$$

下一步，必须将矩阵中的所有项转化为多项式。例如，F1 代表 1 个字节，将变为 $x^7+x^6+x^5+x^4+1$，03 代表 1 个字节，将变为 $x+1$。

然后，所有的乘法运算**模**为 x^8 + x^4 + x^3 + x + 1$。这样，在这一列的四个单元格中，每个单元格都有四个多项式的加法。进行这些加法 **模 2**后，最终会得到四个多项式。每个多项式代表一个 8 位字符串，即 1 个字节的 **S**。图 6*中的矩阵计算量很大，我们就不在这里进行所有这些计算了。

处理完第一列后，**S** 矩阵的其他三列也将以同样的方式处理。最终，将得到一个包含 16 个字节的矩阵，并将其转换为数组。

最后，在**XOR**操作中再次将数组**S**与圆键结合起来。这样就产生了状态 $S_1$。也就是说


- $S_1 = S \oplus K_0$

### 第 2 轮至第 10 轮

第 2 到第 9 轮只是第 1 轮的重复，*比照第 1 轮。最后一轮与前几轮非常相似，只是取消了**混合列**的步骤。也就是说，第 10 轮的执行过程如下：


- $S_9 \oplus K_{10}$
- 字节替换
- 移位行
- $S_{10} = S \oplus K_{10}$

现在状态 $S_{10}$ 设置为 $C_1$，即密码文本的前 128 位。继续处理剩余的 128 位明文块，即可得到完整的密码文 **C**。

### Rijndael 密码的运算

Rijndael 密码中不同操作背后的原因是什么？

在不涉及细节的情况下，加密方案是根据其造成混乱和扩散的程度来评估的。如果加密方案的**混淆**程度很高，这意味着密文看起来与明文大相径庭。如果加密方案的**扩散**程度很高，则意味着对明文的任何微小改动都会产生截然不同的密文。

Rijndael 密码背后的操作原理是，这些操作会产生高度混淆和扩散。混淆由字节替换操作产生，而扩散则由移行和混列操作产生。

# 非对称密码学

<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

## 密钥分配和管理问题

<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

与对称加密技术一样，非对称方案也可用于确保保密和身份验证。不过，相比之下，这些方案采用的是两个密钥而不是一个：一个私人密钥和一个公共密钥。

我们将从非对称密码学的发现，特别是促使非对称密码学发展的问题开始探究。接下来，我们将讨论非对称加密和验证方案如何在高层次上发挥作用。然后，我们将介绍散列函数，它是理解非对称验证方案的关键，也与其他加密环境相关，例如我们在第 4 章中讨论的基于散列的消息验证码。

___

Jim's Sporting Goods 是一家在线体育用品零售商，在北美拥有数百万客户。这将是他第一次购物，他想使用自己的信用卡。因此，Bob 首先需要在 Jim's Sporting Goods 创建一个账户，这需要发送他的地址和信用卡信息等个人信息。然后，他就可以按步骤购买雨衣了。

考虑到互联网是一个开放的通信系统，Bob 和 Jim's Sporting Goods 希望在整个过程中确保通信安全。例如，他们要确保任何潜在的攻击者都无法确定鲍勃的信用卡和地址信息，确保任何潜在的攻击者都无法重复他的购物行为或以他的名义制造虚假购物行为。

上一章讨论过的高级认证加密方案当然可以确保鲍勃和吉姆体育用品公司之间的通信安全。但是，实施这种方案显然存在实际障碍。

为了说明这些实际障碍，假设我们生活在一个只有对称密码学工具的世界。那么，吉姆体育用品公司和鲍勃该如何确保通信安全呢？

在这种情况下，他们将面临巨大的安全通信成本。由于互联网是一个开放的通信系统，他们无法通过互联网交换一组密钥。因此，鲍勃和吉姆体育用品公司的代表需要当面交换密钥。

一种可能性是，吉姆体育用品公司设立专门的密钥交换点，鲍勃和其他新客户可以在那里获取一套密钥，用于安全通信。这显然需要大量的组织成本，而且会大大降低新客户的购买效率。

另外，吉姆体育用品公司也可以通过高度可信赖的快递公司给鲍勃寄一对钥匙。这可能比组织钥匙交换地点更有效率。但这样做的成本仍然很高，尤其是在许多客户只购买一次或几次的情况下。

其次，用于验证加密的对称方案还迫使吉姆体育用品公司为所有客户存储不同的密钥集。这对成千上万的客户来说都是一个巨大的实际挑战，更不用说数百万客户了。

为了理解后一点，假设吉姆体育用品公司为每位客户提供了一对相同的密钥。这样，每位客户或任何其他可以获得这对密钥的人都可以读取甚至操纵吉姆体育用品公司与其客户之间的所有通信。这样一来，你还不如在通信中根本不使用加密技术。

即使只对某些客户重复使用一组密钥，也是一种糟糕的安全做法。任何潜在的攻击者都可以试图利用方案的这一特点（请记住，根据克尔克霍夫斯原则，攻击者被假定知道方案的一切，但不包括密钥）。

因此，Jim's Sporting Goods 必须为每位顾客存储一对密钥，无论这些密钥对是如何分配的。这显然会带来一些实际问题。


- 吉姆体育用品公司必须存储数百万对密钥，每位顾客一套。
- 这些密钥必须妥善保管，因为它们肯定会成为黑客的攻击目标。任何安全漏洞都需要在专门的密钥交换地点或通过信使重复进行代价高昂的密钥交换。
- 任何一位吉姆体育用品公司的顾客都必须在家中安全地存放一对钥匙。丢失和被盗的情况时有发生，因此需要重复交换钥匙。对于任何其他在线商店或其他类型的实体，如果客户希望通过互联网进行通信和交易，也必须经历这一过程。

在 20 世纪 70 年代末之前，上述两大挑战一直是非常基本的问题。它们分别被称为**密钥分配问题**和**密钥管理问题**。

当然，这些问题一直存在，而且在过去常常令人头疼。例如，军事部队不得不冒着极大的风险和代价，不断向实地人员分发带有安全通信密钥的书籍。但是，随着世界越来越多地进入远程数字通信时代，这些问题变得越来越严重，尤其是对非政府实体而言。

如果这些问题没有在 20 世纪 70 年代得到解决，那么在吉姆体育用品公司进行高效安全的购物很可能就不会出现。事实上，我们现代世界的大部分实用和安全的电子邮件、网上银行和购物可能只是一个遥远的幻想。任何与比特币相似的东西都不可能存在。

那么，20 世纪 70 年代发生了什么？我们怎么可能立即在网上购物并安全地浏览万维网？我们怎么可能通过智能手机向世界各地即时发送比特币？

## 密码学的新方向

<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

到 20 世纪 70 年代，密钥分配和密钥管理问题引起了一群美国学术密码学家的关注：惠特菲尔德-迪菲（Whitfield Diffie）、马丁-赫尔曼（Martin Hellman）和拉尔夫-默克尔（Ralph Merkle）。面对大多数同行的强烈质疑，他们大胆地提出了解决方案。

他们创业的至少一个主要动机是预见到开放式计算机通信将深刻影响我们的世界。正如 Diffie 和 Helmann 在 1976 年指出的那样

> 计算机控制的通信网络的发展为世界另一端的人或计算机之间的联系提供了方便和廉价的条件，用电信取代了大部分邮件和许多旅行。在许多应用中，必须确保这些联系的安全，防止窃听和非法信息的输入。然而，目前安全问题的解决远远落后于其他通信技术领域。 *当代的加密技术无法满足这些要求，因为它的使用会给系统用户带来严重的不便，从而消除了远程处理的许多好处* [1] 。
Diffie、Hellman 和 Merkle 的顽强精神得到了回报。1976 年，迪菲和赫尔曼发表了题为 "密码学的新方向 "的论文，首次公布了他们的成果。在这篇论文中，他们提出了解决密钥分配和密钥管理问题的两种独创方法。

他们提出的第一个解决方案是远程*密钥交换协议*，即通过不安全的通信信道交换一个或多个对称密钥的一套规则。这个协议现在被称为 *Diffie-Helmann 密钥交换* 或 *Diffie-Helmann-Merkle 密钥交换*。[2]

通过 Diffie-Helmann 密钥交换，双方首先在不安全的渠道（如互联网）上公开交换一些信息。然后，在这些信息的基础上，双方独立创建一个对称密钥（或一对对称密钥），以实现安全通信。虽然双方都是独立创建密钥，但他们公开共享的信息确保了双方在创建密钥的过程中得到相同的结果。

重要的是，虽然每个人都能观察到双方通过不安全通道公开交换的信息，但只有参与信息交换的双方才能从中创建对称密钥。

当然，这听起来完全违背直觉。双方怎么可能公开交换一些信息，而只有他们才能从中创建对称密钥呢？为什么其他观察信息交换的人就不能创建相同的密钥呢？

当然，它依赖于一些美丽的数学。Diffie-Helmann 密钥交换通过单向函数和陷阱门进行。让我们依次讨论这两个术语的含义。

假设给你某个函数 $f(x)$，结果是 $f(a) = y$，其中 $a$ 是 $x$ 的一个特定值。如果给定$a$和$f(x)$时，计算值$y$很容易，但给定$y$和$f(x)$时，计算值$a$在计算上不可行，我们就说$f(x)$是**单向函数**。当然，"单向函数 "**的名称源于这样一个事实，即这种函数只适用于单向计算。

有些单向函数有所谓的**陷阱门**。虽然仅凭$y$和$f(x)$计算$a$实际上是不可能的，但有一定的信息$Z$使得从$y$计算$a$变得可行。这部分信息 $Z$ 被称为**陷阱门**。具有陷阱门的单向函数被称为**陷阱门函数**。

我们在此不深入探讨 Diffie-Helmann 密钥交换的细节。但从本质上讲，每个参与者都会创建一些信息，其中一部分公开共享，另一部分保密。然后，每一方利用自己的秘密信息和另一方共享的公开信息来创建私钥。神奇的是，双方最终会得到相同的私人密钥。

任何一方只观察到 Diffie Helmann 密钥交换中双方公开共享的信息，都无法复制这些计算。他们需要其中一方的私人信息才能做到这一点。

尽管 1976 年论文中提出的基本版本的 Diffie-Helmann 密钥交换并不十分安全，但该基本协议的复杂版本如今肯定仍在使用。最重要的是，最新版本的传输层安全协议（1.3 版）中的每个密钥交换协议基本上都是 Diffie 和 Hellman 1976 年提出的协议的增强版。传输层安全协议是按照超文本传输协议（http）（交换网络内容的标准）格式安全交换信息的主要协议。

重要的是，Diffie-Helmann 密钥交换不是一种非对称方案。严格来说，它可以说属于对称密钥加密的范畴。但由于 Diffie-Helmann 密钥交换和非对称密码学都依赖于带有陷阱门的单向数论函数，因此通常将它们放在一起讨论。

Diffie 和 Helmann 在 1976 年的论文中提出的解决密钥分发和管理问题的第二种方法当然是非对称加密。

与他们对 Diffie-Hellman 密钥交换的介绍不同，他们只提供了非对称加密方案的大致轮廓。他们并没有提供任何单向函数来具体满足此类方案合理安全性所需的条件。

然而，一年后，三位不同的学术密码学家和数学家找到了非对称方案的实际应用：罗纳德-里维斯特、阿迪-沙米尔和伦纳德-阿德尔曼。[3] 他们推出的密码系统后来被称为**RSA 密码系统**（以他们的姓氏命名）。

非对称密码学（和 Diffie Helmann 密钥交换）中使用的陷阱门函数都与两个主要的**计算难题**有关：质因数分解和离散对数计算。

**质因式**顾名思义就是将整数分解为质因数。RSA 问题是迄今为止与质因数分解相关的密码系统中最著名的例子。

离散对数问题**是出现在循环群中的一个问题。给定特定循环群中的一个生成数，需要计算从生成数生成群中另一个元素所需的唯一指数。

基于离散对数的方案主要依赖两种循环群：整数乘法群和包含椭圆曲线上的点的群。密码学的新方向》一书中介绍的最初的 Diffie Helmann 密钥交换使用的是循环整数乘法组。比特币的数字签名算法和最近推出的 Schnorr 签名方案（2021 年）都是基于特定椭圆曲线循环群的离散对数问题。

接下来，我们将对非对称环境下的保密和认证进行高层次的概述。不过，在此之前，我们需要做一个简短的历史说明。

现在看来，一组为政府通信总部（GCHQ）工作的英国密码学家和数学家在几年前独立完成了上述发现是可信的。这群人包括詹姆斯-埃利斯（James Ellis）、克利福德-考克斯（Clifford Cocks）和马尔科姆-威廉姆森（Malcolm Williamson）。

根据他们自己和 GCHQ 的说法，是詹姆斯-埃利斯于 1969 年首次提出了公钥加密的概念。据说，克利福德-考克斯（Clifford Cocks）随后在 1973 年发现了 RSA 密码系统，马尔科姆-威廉姆森（Malcolm Williamson）则在 1974 年提出了 Diffie Helmann 密钥交换的概念。[4] 不过，由于 GCHQ 工作的机密性，他们的发现据称直到 1997 年才被披露。

**注：**

[1] Whitfield Diffie 和 Martin Hellman，"密码学的新方向"，_IEEE Transactions on Information Theory_ IT-22 (1976)，第 644-654 页，第 644 页。

[2] 拉尔夫-默克尔还在《不安全信道上的安全通信》（Secure communications over insecure channels）一文中讨论了一种密钥交换协议，_Communications of the Association for Computing Machinery_，21 (1978)，294-99。虽然 Merkle 提交这篇论文的时间早于 Diffie 和 Hellman 的论文，但发表时间却晚于 Diffie 和 Hellman。与 Diffie-Hellman 的解决方案不同，Merkle 的解决方案不是指数级安全的。

[3] Ron Rivest、Adi Shamir 和 Leonard Adleman，"获取数字签名和公钥密码系统的方法"，_Communications of the Association for Computing Machinery_，21 (1978)，第 120-26 页。

[4] Simon Singh 著，_The Code Book_，Fourth Estate（伦敦，1999 年），第 6 章对这些发现的历史作了很好的介绍。

## 非对称加密和验证

<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

图 1**提供了在鲍勃和爱丽丝的帮助下**非对称加密**的概况。

爱丽丝首先创建一对密钥，包括一个公开密钥（$K_P$）和一个私人密钥（$K_S$），其中$K_P$中的 "P "代表 "公开"，$K_S$中的 "S "代表 "秘密"。然后，她将这把公开密钥自由地分发给其他人。我们稍后再讨论这个分发过程的细节。但现在，假设包括鲍勃在内的任何人都可以安全地获得爱丽丝的公开密钥 $K_P$。

后来，鲍勃想给爱丽丝写一条 $M$ 信息。由于信息中包含敏感信息，他希望信息内容对除爱丽丝以外的所有人保密。因此，鲍勃首先使用 $K_P$ 对信息 $M$ 进行加密。然后，他将得到的密文 $C$ 发送给爱丽丝，爱丽丝用 $K_S$ 对 $C$ 进行解密，得到原始信息 $M$。

*图 1：非对称加密 *

![Figure 1: Asymmetric encryption](assets/Figure6-1.webp "Figure 1: Asymmetric encryption")

任何监听鲍勃和爱丽丝通信的对手都可以观察到 $C$。她还知道 $K_P$ 和加密算法 $E(\cdot)$。但重要的是，这些信息并不能让攻击者解密密文 $C$。解密特别需要 $K_S$，而攻击者并不掌握这些信息。

对称加密算法通常需要确保安全，以防止攻击者对明文信息进行有效加密（称为 "选择密文攻击安全"）。然而，对称加密算法的设计目的并不是允许攻击者或其他任何人创建这种有效的密码文本。

这与非对称加密方案形成了鲜明对比，后者的全部目的就是让包括攻击者在内的任何人都能生成有效的密码文本。因此，非对称加密方案可以被称为**多重访问密码**。

为了更好地理解所发生的事情，想象一下，鲍勃想秘密地发送一封实体信件，而不是以电子方式发送信息。确保保密的一种方法是，爱丽丝向鲍勃发送一把安全挂锁，但保留开锁的钥匙。写完信后，鲍勃可以把信放在一个盒子里，然后用爱丽丝的挂锁把它锁上。然后，他可以将上锁的盒子连同信息一起寄给爱丽丝，而爱丽丝则拥有开锁的钥匙。

虽然鲍勃能够锁上挂锁，但如果挂锁确实是安全的，那么他和其他截获盒子的人都无法解开挂锁。只有爱丽丝能打开挂锁，看到鲍勃信中的内容，因为她有钥匙。

粗略地说，非对称加密方案就是这一过程的数字版本。挂锁类似于公钥，挂锁密钥类似于私钥。不过，由于挂锁是数字的，爱丽丝要把它分发给任何可能想向她发送秘密信息的人，就容易得多，成本也不高。

在非对称环境中，我们使用**数字签名**进行身份验证。因此，数字签名与对称环境中的信息验证码具有相同的功能。数字签名概览见*图 2*。

鲍勃首先创建一对密钥，包括公钥（$K_P$）和私钥（$K_S$），并分发他的公钥。当他要向爱丽丝发送经过验证的信息时，他首先用自己的信息 $M$ 和私人密钥创建一个**数字签名** $D$。然后，鲍勃将信息连同数字签名一起发送给爱丽丝。

爱丽丝将信息、公钥和数字签名插入一个**验证算法**。如果签名有效，该算法就会产生**真**；如果签名无效，该算法就会产生**假**。

数字签名，顾名思义，就是信件、合同等书面签名的数字等价物。事实上，数字签名通常要安全得多。只要稍加努力，你就可以伪造书面签名；由于书面签名通常不会被仔细核实，所以伪造过程变得更加容易。然而，安全数字签名与安全信息验证码一样，**存在不可伪造性**：也就是说，使用安全数字签名方案，除非拥有私人密钥，否则任何人都无法为通过验证程序的信息创建签名。

*图 2：非对称身份验证 *

![Figure 2: Asymmetric authentication](assets/Figure6-2.webp "Figure 2: Asymmetric authentication")

与非对称加密一样，我们可以看到数字签名与信息验证码之间的有趣对比。就后者而言，验证算法只能由参与安全通信的其中一方使用。这是因为它需要私人密钥。然而，在非对称设置中，任何人都可以验证鲍勃所做的数字签名 $S$。

所有这些都使数字签名成为一个极其强大的工具。例如，数字签名是创建合同签名的基础，而合同签名可以为法律目的进行验证。如果鲍勃在上述交换中对合同进行了签名，爱丽丝就可以向法庭出示信息 $M$、合同和签名 $S$。法院就可以使用鲍勃的公开密钥验证签名。[5]

再比如，数字签名是安全软件和软件更新发布的一个重要方面。这种公共可验证性绝不是仅仅使用信息验证码就能实现的。

最后一个数字签名功能的例子是比特币。关于比特币最常见的误解之一，尤其是媒体上的误解，就是交易是加密的：其实不然。相反，比特币交易使用数字签名来确保安全。

比特币成批存在，称为未用交易输出（或 **UTXO's**）。假设你在某个比特币地址上收到三笔付款，每笔 2 个比特币。严格来说，您现在在该地址上并没有 6 个比特币。相反，你有三批 2 个比特币，这些比特币被与该地址相关的加密问题锁定。对于您的任何支付，您可以使用其中一批、两批或全部三批比特币，这取决于您的交易需要多少比特币。

未用交易输出的所有权证明通常通过一个或多个数字签名来显示。比特币之所以行得通，正是因为对未使用的交易输出进行有效的数字签名在计算上是不可行的，除非你掌握了制作数字签名所需的秘密信息。

目前，比特币交易透明地包含了需要网络参与者验证的所有信息，例如交易中使用的未消耗交易输出的来源。虽然有可能隐藏部分信息，但仍然可以进行验证（如 Monero 等一些替代加密货币所做的），但这也会带来特殊的安全风险。

数字签名和以数字方式获取的书面签名有时会引起混淆。在后一种情况下，你会捕捉到书面签名的图像，并将其粘贴到电子文档（如雇用合同）上。但这不是密码学意义上的数字签名。后者只是一个长数字，只有拥有私钥才能生成。

与对称密钥设置一样，您也可以同时使用非对称加密和身份验证方案。类似的原则也适用。首先，应使用不同的私人-公开密钥对进行加密和数字签名。此外，应先加密信息，然后再进行身份验证。

重要的是，在许多应用中，非对称加密技术并不会在整个通信过程中使用。相反，非对称加密技术通常只用于*交换双方之间的对称密钥*，他们将通过对称密钥进行实际通信。

例如，当你在网上购买商品时就是这种情况。知道了供应商的公开密钥，她就可以向你发送经过数字签名的信息，而你可以验证这些信息的真实性。在此基础上，您可以使用多种交换对称密钥的协议之一进行安全通信。

上述方法频频出现的主要原因是，非对称加密法在产生特定安全级别方面的效率远远低于对称加密法。这就是为什么我们仍然需要对称密钥加密法和公开密钥加密法的原因之一。此外，对称密钥加密法在特定应用中更为自然，如计算机用户加密自己的数据。

那么，数字签名和公开密钥加密究竟是如何解决密钥分发和密钥管理问题的呢？

这里没有唯一的答案。非对称加密技术是一种工具，而使用这种工具的方法并不单一。不过，让我们以吉姆体育用品公司为例，说明在这个例子中通常会如何解决这些问题。

首先，Jim's Sporting Goods 可能会与**证书颁发机构**联系，该机构支持公钥分发。证书颁发机构会登记有关吉姆体育用品公司的一些详细信息，并授予它一个公钥。然后，证书颁发机构会向吉姆体育用品公司发送一份证书，即**TLS/SSL 证书**，其中吉姆体育用品公司的公钥是用证书颁发机构自己的公钥数字签名的。这样，证书颁发机构就确认了某个公钥确实属于吉姆体育用品公司。

理解 TLS/SSL 证书的这一过程的关键在于，虽然你的计算机上一般不会存储 Jim's Sporting Goods 的公钥，但公认的证书颁发机构的公钥确实存储在你的浏览器或操作系统中。这些密钥存储在所谓的**根证书**中。

因此，当 Jim's Sporting Goods 向你提供其 TLS/SSL 证书时，你可以通过浏览器或操作系统中的根证书验证证书颁发机构的数字签名。如果签名有效，就可以相对确定证书上的公钥确实属于吉姆体育用品公司。在此基础上，就可以很容易地与吉姆体育用品公司建立安全通信协议。

现在，Jim's Sporting Goods 公司的钥匙分发工作变得非常简单。不难看出，密钥管理也大大简化了。Jim's Sporting Goods 不再需要存储成千上万的密钥，而只需要存储一个私钥，就可以对 SSL 证书上的公钥进行签名。客户每次访问 Jim's Sporting Goods 网站时，都可以使用该公开密钥建立安全通信会话。客户也不需要存储任何信息（除了操作系统和浏览器中公认的证书颁发机构的公开密钥）。

**注：**

[5] 任何试图实现不可抵赖性（我们在第一章中讨论的另一个主题）的方案，其基础都需要涉及数字签名。

## 哈希函数

<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

哈希函数在密码学中无处不在。它们既不是对称方案，也不是非对称方案，而是属于密码学的一个独立类别。

我们在第 4 章创建基于散列的验证信息时已经接触过散列函数。它们在数字签名中也很重要，不过原因略有不同：数字签名通常是通过某些（加密）信息的哈希值，而不是实际的（加密）信息来完成的。在本节中，我将对散列函数进行更全面的介绍。

让我们从定义哈希函数开始。散列函数**是任何可有效计算的函数，它接受任意大小的输入，并产生固定长度的输出。

密码散列函数**只是一种散列函数，在密码学应用中非常有用。密码散列函数的输出通常称为**散列**、**散列值**或**信息摘要**。

在密码学中，"散列函数 "通常是指密码散列函数。从现在起，我将采用这种做法。

例如，**SHA-256**（安全散列算法 256）就是一个常用的散列函数。无论输入的大小（如 15 位、100 位或 10,000 位）如何，该函数都会产生一个 256 位的散列值。下面是 SHA-256 函数的几个输出示例。

"你好"：`185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969`

"52398":`a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90`

"密码学很有趣"：`3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c`

所有输出都是以十六进制格式写出的 256 位（每个十六进制数字可以用四个二进制数字表示）。因此，即使将托尔金的《魔戒*》一书插入 SHA-256 函数，输出仍然是 256 位。

在密码学中，SHA-256 等散列函数被用于各种目的。散列函数需要具备哪些特性取决于特定应用的具体情况。在密码学中，散列函数一般需要两个主要特性：[6]

1.	抗碰撞

2.	隐藏

如果要找到两个值$x$和$y$，使得$x （neq）y$，但$H(x) = H(y)$是不可行的，那么散列函数$H$就被称为**抗碰撞**。

例如，抗碰撞哈希函数在软件验证中就非常重要。假设您想下载 Windows 版本的 Bitcoin Core 0.21.0（处理比特币网络流量的服务器应用程序）。为了验证软件的合法性，您需要采取的主要步骤如下：

1.	您首先需要下载一个或多个 Bitcoin Core 贡献者的公钥，并将其导入可以验证数字签名的软件（如 Kleopetra）。您可以在 [这里](https://github.com/bitcoin/bitcoin/blob/master/contrib/builder-keys/keys.txt) 找到这些公钥。建议您使用多个贡献者的公钥验证 Bitcoin Core 软件。

2.	接下来，你需要验证导入的公开密钥。你至少应该采取的一个步骤是验证你找到的公钥是否与在其他不同地方发布的公钥相同。例如，你可以查阅你导入公钥的人的个人网页、Twitter 网页或 Github 网页。通常，这种公钥对比是通过对比公钥的简短哈希值（称为指纹）来完成的。

3.	接下来，你需要从他们的 [网站](www.bitcoincore.org) 下载 Bitcoin Core 的可执行文件。有适用于 Linux、Windows 和 MAC 操作系统的软件包。

4.	接下来，你必须找到两个发布文件。第一个文件包含你下载的可执行文件的官方 SHA-256 哈希值，以及所有其他已发布软件包的哈希值。另一个发布文件包含不同贡献者对发布文件的签名以及软件包哈希值。这两个发布文件都可以在 Bitcoin Core 网站上找到。

5.	 接下来，您需要在自己的电脑上计算从 Bitcoin Core 网站下载的可执行文件的 SHA-256 哈希值。然后，将此结果与可执行文件的官方软件包哈希值进行比较。它们应该是一样的。

6.	最后，您需要验证发布文件上的一个或多个数字签名与您导入的一个或多个公钥（Bitcoin Core 的发布并不总是由所有人签名）是否一致。您可以使用 Kleopetra 这样的应用程序来进行验证。

这一软件验证过程有两大好处。首先，它可以确保从 Bitcoin Core 网站下载时没有传输错误。其次，它可以确保没有攻击者通过黑客攻击 Bitcoin Core 网站或截获流量，让你下载修改过的恶意代码。

上述软件验证过程究竟是如何防范这些问题的？

如果你认真验证了你导入的公钥，那么你就可以相当肯定这些公钥确实是他们的，而且没有被泄露。鉴于数字签名具有存在的不可伪造性，你就知道只有这些贡献者才能对发布文件上的官方软件包哈希值进行数字签名。

假设你下载的发布文件上的签名通过了检查。现在，您可以将下载的 Windows 可执行文件本地计算的哈希值与正确签名的发布文件中的哈希值进行比较。大家都知道，SHA-256 散列函数具有抗串扰性，如果两者相匹配，则表示您的可执行文件与官方可执行文件完全相同。

现在让我们来看看哈希函数的第二个共同特性： **隐藏**。任何散列函数 $H$ 都具有隐藏特性，如果从一个非常大的范围内随机选择 $x$，只给 $H(x)$ 时要找到 $x$ 是不可行的。

下面是我编写的一条信息的 SHA-256 输出结果。为了确保足够的随机性，信息末尾包含了一个随机生成的字符串。由于 SHA-256 具有隐藏特性，因此没有人能破译这条信息。


- `b194221b37fa4cd1cfce15aaef90351d70de17a98ee6225088b523b586c32ded`

不过，在 SHA-256 变弱之前，我不会给你留下悬念。我写的原始信息如下


- "这是一条非常随机的信息，或者说有点随机。开头部分不是随机的，但我会用一些相对随机的字符结尾，以确保信息的不可预测性。XLWz4dVG3BxUWm7zQ9qS"。

具有隐藏属性的散列函数常用于密码管理（抗碰撞性对这种应用也很重要）。任何像 Facebook 或 Google 这样基于账户的正规在线服务都不会直接存储您的密码来管理您账户的访问权限。相反，它们只会存储密码的哈希值。每次您在浏览器上填写密码时，首先会计算出一个哈希值。只有这个哈希值会被发送到服务提供商的服务器，并与后端数据库中存储的哈希值进行比较。隐藏属性有助于确保攻击者无法从散列值中恢复密码。

当然，通过哈希值进行密码管理只有在用户确实选择了困难密码的情况下才能奏效。隐藏属性假定 x是从一个非常大的范围内随机选择的。选择 "1234"、"mypassword "或您的生日日期等密码并不能提供真正的安全性。如果攻击者获得了你的密码哈希值，他们就可以利用一长串常用密码及其哈希值。这类攻击被称为**字典攻击**。如果攻击者知道你的一些个人信息，他们也可能会尝试一些有根据的猜测。因此，您始终需要安全的长密码（最好是密码管理器中的随机长字符串）。

有时，应用程序可能需要一个既能抗碰撞又能隐藏的哈希函数。但并非总是如此。例如，我们讨论过的软件验证过程只要求哈希函数具有抗碰撞性，隐藏性并不重要。

虽然抗碰撞性和隐藏性是密码学哈希函数所追求的主要特性，但在某些应用中，其他类型的特性也可能是理想的。

**注：**

[6] "隐藏 "一词并非通用语言，而是专门取自 Arvind Narayanan、Joseph Bonneau、Edward Felten、Andrew Miller 和 Steven Goldfeder 的著作《*比特币和加密货币技术*》，普林斯顿大学出版社（普林斯顿，2016 年），第 1 章。

# RSA 密码系统

<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

## 因式分解问题

<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

对大多数人来说，对称密码学通常相当直观，但非对称密码学通常并非如此。虽然你可能已经熟悉了前面章节中的高层次描述，但你可能还想知道单向函数到底是什么，以及它们是如何用于构建非对称方案的。

在本章中，我将通过深入研究一个具体的例子，即 RSA 密码系统，来揭开非对称密码学的一些神秘面纱。在第一节中，我将介绍作为 RSA 问题基础的因式分解问题。然后，我将介绍数论中的一些关键结果。在最后一节中，我们将综合这些信息来解释 RSA 问题，以及如何利用它来创建非对称加密方案。

为我们的讨论增加这种深度并非易事。它需要引入大量的数论定理和命题。但不要因为数学而放弃。通过这一讨论将大大提高你对非对称密码学基础的理解，是一项值得的投资。

现在我们先来看看因式分解问题。

___

每当您将两个数相乘时，例如将 $a$ 和 $b$ 相乘，我们称 $a$ 和 $b$ 为 **因数**，结果为 **乘积**。试图将一个数 $N$ 写成两个或两个以上因数的乘法称为**因式分解**或**因式分解**。[1] 你可以把任何需要这样做的问题称为**因式分解问题**。

大约 2500 年前，希腊数学家亚历山大的欧几里得发现了一个关于整数因式分解的关键定理。它通常被称为**唯一因式分解定理**，其内容如下：

**定理 1**.每个大于 1 的整数 $N$ 要么是质数，要么可以表示为质因数的乘积。

这句话后半部分的意思是，你可以把任何大于 1 的非质数整数 $N$，写成质数的乘法。下面是几个非质数整数写成质因数乘积的例子。


- $18 = 2 \cdot 3 \cdot 3 = 2 \cdot 3^2$
- $84 = 2 \cdot 2 \cdot 3 \cdot 7 = 2^2 \cdot 3 \cdot 7$
- $144 = 2 \cdot 2 \cdot 2 \cdot 3 \cdot 3 = 2^4 \cdot 3^2$

对于上述三个整数，即使只给你 $N$，计算它们的质因数也相对容易。您可以从最小的质数 2 开始，看看整数 $N$ 能被它整除多少次。然后再测试 $N$ 能被 3、5、7 整除，以此类推。这个过程一直持续到整数 $N$ 只被写成质数的乘积为止。

以整数 84 为例。下面是确定其质因数的过程。每一步，我们都要取出剩余的最小质因数（在左边），并确定要因式分解的余项。直到余项也是质数为止。每一步，最右边都会显示 84 的当前因式分解。


- 质因数 = 2：余项 = 42 ($84 = 2 \cdot 42$)
- 质因数 = 2: 余项 = 21 ($84 = 2 \cdot 2 \cdot 21$)
- 质因数 = 3: 余项 = 7 ($84 = 2 \cdot 2 \cdot 3 \cdot 7$)
- 由于 7 是质数，所以结果是 $2 \cdot 2 \cdot 3 \cdot 7$，或 $2^2 \cdot 3 \cdot 7$。

假设 $N$ 非常大。要把 $N$ 分解成质因数有多难？

这实际上取决于 $N$。例如，假设 $N$ 为 50 450 400。虽然这个数字看起来很吓人，但计算起来并不复杂，很容易就能手算出来。和上面一样，你只需从 2 开始，依次计算即可。下面是计算的结果。


- 2: 25 225 200 ($50 450 400 = 2\cdot 25 225 200$)
- 2: 12,612,600 ($50,450,400 = 2^2 \cdot 12,612,600$)
- 2: 6,306,300 ($50,450,400 = 2^3 \cdot 6,306,300$)
- 2: 3,153,150 ($50,450,400 = 2^4 \cdot 3,153,150$)
- 2: 1,576,575 ($50,450,400 = 2^5 \cdot 1,576,575$)
- 3: 525,525 ($50,450,400 = 2^5 \cdot 3 \cdot 525,525$)
- 3: 175,175 ($50,450,400 = 2^5 \cdot 3^2 \cdot 175,175$)
- 5: 35,035 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5 \cdot 35,035$)
- 5: 7,007 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7,007$)
- 7: 1,001 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7 \cdot 1,001$)
- 7: 143 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 143$)
- 11: 13 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$)
- 由于 13 是质数，所以结果是 $2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$。

手工解决这个问题需要一些时间。当然，计算机可以在几分之一秒内完成所有这些工作。事实上，计算机甚至可以在几分之一秒内将极大的整数因式分解。

不过，也有一些例外情况。假设我们首先随机选择两个非常大的素数。通常我们会给这两个数分别贴上 $p$ 和 $q$的标签，在此我也将采用这一惯例。

具体来说，假设 $p$ 和 $q$ 都是 1024 位的素数，而且它们确实至少需要 1024 位才能表示（因此第一位必须是 1）。因此，举例来说，37 不可能是质数之一。你当然可以用 1024 位来表示 37。但显然，*你并不需要*这么多比特来表示它。你可以用任何 6 位或更多的字符串来表示 37。(在 6 位中，37 可以表示为 $100101$）。

重要的是要了解在上述条件下选择的 $p$ 和 $q$ 有多大。举例来说，我选择了一个随机质数，它至少需要 1024 比特来表示。


- 14,752,173,874,503,595,484,930,006,383,670,759,559,764,562,721,397,166,747,289,220,945,457,932,666,751,048,198,854,920,097,085,690,793,755,254,946,188,163,753,506,778,089,706,699,671,722,089,715,624,760,049,594,106,189,662,669,156,149,028,900,805,928,183,585,427,782,974,951,355,515,394,807,209,836,870,484,558,332,897,443,152,653,214,483,870,992,618,171,825,921,582,253,023,974,514,209,142,520,026,807,636,589

假设现在随机选择质数 $p$ 和 $q$，然后将它们相乘，得到一个整数 $N$。因此，后一个整数是一个 2048 位的数字，至少需要 2048 位来表示。它比 $p$ 或 $q$ 都要大很多很多。

假设你只给一台计算机 $N$，并要求它找出 $N$ 的两个 1024 位质因数。计算机发现 $p$ 和 $q$ 的概率极小。可以说，就所有实际目的而言，这都是不可能的。即使使用超级计算机甚至超级计算机网络，情况也是如此。

首先，假设计算机尝试通过循环使用 1024 位数字来解决问题，每次测试这些数字是否是质数以及是否是 $N$ 的因数。那么要测试的素数集大约为 1.265 \cdot 10^{305}$。[2]

即使把地球上所有的计算机都集中起来，让它们尝试用这种方法寻找和测试 1024 位素数，要想有十亿分之一的机会成功找到 $N$ 的素数因子，也需要比宇宙年龄更长的计算时间。

实际上，计算机可以比刚才描述的粗略程序做得更好。有几种算法可以让计算机更快地进行因式分解。但问题是，即使使用了这些更有效的算法，计算机的任务在计算上仍然是不可行的。[3]

重要的是，在上述条件下因式分解的难度是建立在这样的假设之上的，即不存在计算质因数的高效算法。我们实际上无法证明不存在高效算法。尽管如此，这个假设还是非常可信的：尽管经过了数百年的努力，我们仍未找到这样一种计算效率高的算法。

因此，在某些情况下，可以认为因式分解问题是一个难题。具体来说，当 $p$ 和 $q$ 都是非常大的素数时，它们的乘积 $N$ 并不难计算；但只给定 $N$ 的因式分解实际上是不可能的。

**注：**

[1] 因式分解对于处理数字以外的其他数学对象也很重要。例如，多项式表达式（如 $x^2 - 2x + 1$）的因式分解就很有用。在讨论中，我们将只关注数的因式分解，特别是整数的因式分解。

[2] 根据**素数定理**，小于或等于 $N$ 的素数约为 $N/\ln(N)$。这意味着长度为 1024 位的素数的近似数为

$$ \frac{2^{1024}}{\ln(2^{1024})} - \frac{2^{1023}}{\ln(2^{1023})} $$

......约等于 10^{305}$ 的 1.265 倍。

[3] 离散对数问题也是如此。因此，非对称结构使用的密钥要比对称加密结构大得多。

## 数论成果

<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

遗憾的是，因式分解问题不能直接用于非对称加密方案。不过，我们可以利用一个更复杂但与此相关的问题：RSA 问题。

要理解 RSA 问题，我们需要理解数论中的一些定理和命题。本节将分三小节介绍这些定理和命题：(1) N 的阶，(2) N 的可逆性，以及 (3) 欧拉定理。

这三个小节中的部分内容已在第 3*章中作了介绍。但为了方便起见，我将在此重述这些材料。

### N

如果一个整数 $a$ 与一个整数 $N$ 之间的最大公约数是 1，那么这个整数 $a$ 与这个整数 $N$ 是**共素数**或**相对素数**。

例如，考虑 $a = 18$ 和 $N = 37$ 的情况。这显然是共素数。与此相反，考虑 $a = 42$ 和 $N = 16$ 的情况。这显然不是共素数。这两个数都能被大于 1 的 2 整除。

现在我们可以对 $N$ 的阶作如下定义。假设 $N$ 是一个大于 1 的整数。那么，N** 的**阶就是所有与 $N$ 互为同素数的个数，对于每个同素数 $a$，下面的条件都成立：$1 \leq a < N$。

例如，如果 $N = 12$，那么 1、5、7 和 11 是唯一符合上述要求的共素数。因此，12 的阶数等于 4。

假设 $N$ 是一个质数。那么任何小于 $N$ 但大于或等于 1 的整数都与它共素。这包括以下集合中的所有元素：$\{1,2,3,....,N - 1\}$。因此，当 $N$ 是素数时，$N$ 的阶是 $N -1$。命题 1 指出了这一点，其中 $\phi(N)$ 表示 $N$ 的阶。

**命题 1**.当 $N$ 是质数时，$\phi(N) = N - 1$

假设 $N$ 不是质数。那么，您可以使用**欧拉的 Phi 函数**计算它的阶次。虽然计算小整数的阶相对简单，但欧拉的 Phi 函数对较大的整数尤为重要。欧拉 Phi 函数的命题如下。

**定理 2**.让 $N$ 等于 $p_1^{e_1}\cdot p_2^{e_2}\cdot \ldots \cdot p_i^{e_i}\cdot \ldots \cdot p_n^{e_n}$，其中集合$\{p_i\}$由$N$的所有不同质因数组成，每个$e_i$表示质因数$p_i$在$N$中出现的次数。那么

$$\phi(N) = p_1^{e_1 - 1}\cdot (p_1 - 1) \cdot p_2^{e_2 - 1}\cdot (p_2 - 1) \cdot \ldots \cdot p_n^{e_n - 1}\cdot (p_n - 1)$$

**定理 2** 表明，一旦将任何非质数 $N$ 分解为其不同的质因数，就很容易计算出 $N$ 的阶数。

例如，假设 $N = 270$。这显然不是一个质数。将 $N$ 分解成质因数，得到表达式：2 \cdot 3^3 \cdot 5$。根据欧拉腓函数，$N$ 的阶数如下：

$$\phi(N) = 2^{1 - 1}\cdot (2 - 1) + 3^{3 - 1}\cdot (3 - 1) + 5^{1 - 1}\cdot (5 - 1) = 1 \cdot 1 + 9 \cdot 2 + 1 \cdot 4 = 1 + 18 + 4 = 23$$

再假设 $N$ 是两个素数 $p$ 和 $q$ 的乘积。 *那么，上述*定理 2** 指出，$N$ 的阶数如下：

$$p^{1 - 1}\cdot (p - 1) \cdot q^{1 - 1}\cdot (q - 1) = (p - 1) \cdot (q - 1)$$$

这是 RSA 问题的一个关键结果，在下文的**命题 2** 中阐述。

**命题 2**.如果 $N$ 是两个素数 $p$ 和 $q$ 的乘积，那么 $N$ 的阶数就是乘积 $(p - 1)\cdot (q - 1)$.

举例说明，假设 $N = 119$。这个整数可以分解成两个素数，即 7 和 17。因此，欧拉的 Phi 函数表明 119 的阶数如下：

$$\phi(119) = (7 - 1) \cdot (17 - 1) = 6 \cdot 16 = 96$$

换句话说，整数 119 在 1 到 119 的范围内有 96 个共素数。事实上，这个集合包括从 1 到 119 的所有整数，它们都不是 7 或 17 的倍数。

从这里开始，让我们把决定 $N$ 顺序的共素数集表示为 $C_N$。在我们的例子中，$N = 119$，集合$C_{119}$ 太大，无法完全列出。但其中的一些元素如下：

$$C_{119} = \{1, 2, \dots 6, 8 \dots 13, 15, 16, 18, \dots 33, 35 \dots 96\}$$

### N 模的可逆性

如果存在至少一个整数$b$，使得$a \cdot b \mod N = 1 \mod N$，我们就可以说一个整数$a$是**可逆的N**模。任何这样的整数$b$都被称为$a$的**逆**（或**乘逆**），因为它是以$N$为模进行还原的。

例如，假设 $a = 5$，$N = 11$。有很多整数可以与 5 相乘，这样，$5 \cdot b \mod 11 = 1 \mod 11$。例如，可以考虑整数 20 和 31。不难看出，这两个整数都是 5 的反比例，都是以 11 为模进行还原的。


- $5 \cdot 20 \mod 11 = 100 \mod 11 = 1 \mod 11$
- $5 \cdot 31 \mod 11 = 155 \mod 11 = 1 \mod 11$

虽然 5 有许多以 11 为模数的倒数，但你可以证明，5 只存在一个小于 11 的正倒数。事实上，这并不是我们这个例子所独有的，而是一个普遍的结果。

**命题 3**.如果整数 $a$ 是可逆的 modulo $N$，那么必须有一个 $a$ 的正逆值小于 $N$（因此，这个唯一的 $a$ 逆值必须来自集合 $\{1, \dots, N - 1\}$）。

让我们把**命题3**中$a$的唯一倒数表示为$a^{-1}$。对于 $a = 5$ 和 $N = 11$ 的情况，你可以看到 $a^{-1} = 9$，因为 $5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$。

请注意，在我们的例子中，只要将 $a$ 的任何其他倒数减去 11 的模，就可以得到 $a^{-1}$ 的值 9。例如，$20 \mod 11 = 31 \mod 11 = 9 \mod 11$。因此，只要一个整数 $a > N$ 是可逆的，那么 $a \mod N$ 也一定是可逆的。

$a$ 的逆数不一定存在以 $N$ 为模数的还原。例如，假设 $a = 2$，$N = 8$。不存在$b$或任何具体的$a^{-1}$使得$2 \cdot b \mod 8 = 1 \mod 8$。这是因为任何 $b$ 的值都会产生 2 的倍数，所以除以 8 的余数都不会等于 1。

对于给定的 $N$，我们如何知道某个整数 $a$ 是否有一个倒数呢？正如您在上面的例子中注意到的，2 和 8 之间的最大公约数大于 1，即 2：

**命题 4**.当且仅当 $a$ 与 $N$ 之间的最大公约数为 1 时（即当它们是共素数时），存在给定减数 $a$ modulo $N$ 的整数 $a$ 的逆，特别是存在小于 $N$ 的唯一正逆。

对于 $a = 5$ 和 $N = 11$ 的情况，我们的结论是 $a^{-1} = 9$，因为 $5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$。值得注意的是，反之亦然。也就是说，当 $a = 9$ 和 $N = 11$ 时，情况是 $a^{-1} = 5$。

### 欧拉定理

在继续讨论 RSA 问题之前，我们需要了解一个更重要的定理，即**欧拉定理**。该定理说明如下：

**定理 3**.假设两个整数 $a$ 和 $N$ 是共素数.那么，$a^{\phi(N)} \mod N = 1 \mod N$.

这是一个了不起的结果，但一开始有点令人困惑。让我们通过一个例子来理解它。

假设 $a = 5$ 和 $N = 7$。正如欧拉定理所要求的，这两个数确实是共素数。由于 7 是质数，我们知道 7 的阶等于 6（见**命题 1**）。

欧拉定理现在指出，5^6 \mod 7$ 一定等于 1 \mod 7$。下面的计算证明了这一点。


- $5^6 \mod 7 = 15,625 \mod 7 = 1 \mod N$

整数 7 除以 15 624 共有 2 233 次。因此，16 625 除以 7 的余数是 1。

接着，利用欧拉皮函数的**定理 2**，可以推导出下面的**命题 5**。

**命题5**.$\phi(a \cdot b) = \phi(a) \cdot \phi(b)$ 对于任何正整数 $a$ 和 $b$.

我们不会说明为什么会这样。但请注意，正如**命题2**所述，当$p$和$q$都是素数时，$\phi(p \cdot q) = \phi(p) \cdot \phi(q) = (p - 1) \cdot (q - 1)$这一事实已经证明了这一命题。

欧拉定理与**命题 5** 具有重要的意义。例如，看看下面的表达式会发生什么，其中 $a$ 和 $N$ 是共素数。


- $a^{2 \cdot \phi(N)} \mod N = a^{\phi(N)} \cdot a^{\phi(N)} \mod N = 1 \cdot 1 \mod N = 1 \mod N$
- $a^{\phi(N) + 1}\mod N = a^{\phi(N)} \cdot a^1 \mod N = 1 \cdot a^1 \mod N = a \mod N$
- $a^{8 \cdot \phi(N) + 3} \mod N = a^{8 \cdot \phi(N)} \cdot a^3 \mod N = 1 \cdot a^3 \mod N = a^3 \mod N$

因此，结合欧拉定理和**命题 5**，我们可以简单地计算出一些表达式。一般来说，我们可以总结出**命题 6** 中的见解。

**命题 6**.$a^x \mod N = a^{x \mod \phi(N)}$

现在，我们必须在最后一个棘手的步骤中把所有东西组合在一起。

正如 $N$ 有一个阶 $\phi(N)$，其中包括集合 $C_N$ 中的元素，我们知道整数 $\phi(N)$ 也必须有一个阶和一组共素数。我们设 $\phi(N)= R$。那么我们就知道 $\phi(R)$ 也有一个值和一组共素数 $C_R$。

假设我们现在从集合$C_R$中选择一个整数$e$。根据**命题 3**，我们知道这个整数 $e$ 只有一个小于 $R$ 的唯一正倒数。也就是说，$e$ 在集合 $C_R$ 中有一个唯一的逆。我们称这个逆数为 $d$。根据逆的定义，这意味着 $e \cdot d = 1 \mod R$.

我们可以利用这一结果来对原始整数 $N$ 做出说明。这在**命题 7** 中做了总结。

**命题7**.假设 $e \cdot d \mod \phi(N) = 1 \mod \phi(N)$.那么对于集合$C_N$中的任何元素$a$来说，情况一定是$a^{e \cdot d \mod \phi(N)} = a^{1 \mod \phi(N)} = a \mod N$。

现在，我们已经掌握了清晰阐述 RSA 问题所需的所有数论结果。

## RSA 密码系统

<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>

现在，我们准备陈述 RSA 问题。假设你创建了一组变量，包括 $p$、$q$、$N$、$\phi(N)$、$e$、$d$ 和 $y$。称这个集合为 $\Pi$。其创建过程如下：

1.随机生成两个大小相等的素数 $p$ 和 $q$，并计算它们的乘积 $N$。

2.通过以下乘积计算 $N$ 的阶数 $\phi(N)$：$(p - 1) \cdot (q - 1)$.

3.选择一个 $e > 2$，使其小于 $\phi(N)$，并与 $\phi(N)$共素。

4.通过设置 $e \cdot d \mod \phi(N) = 1$ 计算 $d$。

5.选择一个小于 $N$ 且与 $N$ 共素的随机值 $y$。

RSA 问题包括找到一个 $x$，使得 $x^e = y$，同时只给出有关 $\Pi$ 的信息子集，即变量 $N$、$e$ 和 $y$。当 $p$ 和 $q$ 非常大（通常建议为 1024 位）时，RSA 问题被认为很难解决。通过前面的讨论，您现在可以明白为什么会出现这种情况了。

当 $x^e \mod N = y \mod N$ 时，计算 $x$ 的简单方法是计算 $y^d \mod N$。通过下面的计算，我们知道 $y^d \mod N = x \mod N$ ：

$$ y^d \mod N = x^{e \cdot d}\mod N = x^{e \cdot d \mod \phi(N)} \mod N = x^{1 \mod \phi(N)} \mod N = x \mod N. $$$

问题是我们不知道 $d$ 的值，因为问题中没有给出。因此，我们无法直接计算 $y^d \mod N$ 以得出 $x \mod N$。

然而，我们也许可以从 $N$ 的阶数 $\phi(N)$ 间接计算出 $d$，因为我们知道 $e \cdot d \mod \phi(N) = 1 \mod \phi(N)$.但根据假设，这个问题也没有给出 $\phi(N)$ 的值。

最后，阶次可以通过质因数 $p$ 和 $q$ 间接计算出来，这样我们就可以最终计算出 $d$。但根据假设，我们也没有得到 $p$ 和 $q$。

严格来说，即使 RSA 问题中的因式分解问题很难，我们也不能证明 RSA 问题也很难。除了因式分解，可能还有其他方法来解决 RSA 问题。然而，一般认为并假定，如果 RSA 问题中的因式分解问题很难，那么 RSA 问题本身也很难。

如果 RSA 问题确实很难，那么它就会产生一个带有陷阱门的单向函数。这里的函数是 $f(g) = g^e \mod N$。只要知道 $f(g)$，任何人都可以轻松计算出特定 $g = x$ 的值 $y$。然而，仅凭已知值 $y$ 和函数 $f(g)$，实际上不可能计算出特定值 $x$。但有一个例外，那就是您得到了一条信息 $d$，即陷阱门。在这种情况下，您只需计算 $y^d$ 即可得出 $x$。

让我们通过一个具体的例子来说明 RSA 问题。我不能选择一个在上述条件下会被认为很难的 RSA 问题，因为数字会很庞大。这个例子只是为了说明 RSA 问题的一般原理。

首先，假设您随机选择了两个质数 13 和 31。那么 $p = 13$ 和 $q = 31$。这两个素数的乘积 $N$ 等于 403。我们可以很容易地计算出 403 的阶数。它等价于 $(13 - 1) \cdot (31 - 1) = 360$。

接下来，根据 RSA 问题第 3 步的要求，我们需要为 360 选择一个大于 2 且小于 360 的同素数。我们不必随机选择这个值。假设我们选择 103。这是 360 的共素数，因为它与 103 的最大公约数是 1。

步骤 4 现在要求我们计算出一个值 $d$，使得 $103 \cdot d \mod 360 = 1$。当 $N$ 的值很大时，手工计算并不容易。这要求我们使用一种称为**扩展欧几里得算法**的程序。

虽然我没有在这里展示这个过程，但当 $e = 103$ 时，它可以得到值 7。你可以通过下面的计算验证 103 和 7 这对数值确实满足一般条件 $e \cdot d \mod \phi(n) = 1$。


- $103 \cdot 7 \mod 360 = 721 \mod 360 = 1 \mod 360$

重要的是，考虑到*命题4*，我们知道$d$在1和360之间的其他整数都不会产生$103 \cdot d = 1 \mod 360$的结果。此外，命题还暗示，为 $e$ 选择一个不同的值，将为 $d$ 产生一个不同的唯一值。

在 RSA 问题的第 5 步中，我们必须选择一个与 403 成较小同素数的正整数 $y$。假设我们设置 $y = 2^{103}$。2 乘以 103 的幂运算结果如下。


- $2^{103}\mod 403 = 10,141,204,801,825,835,211,973,625,643,008 \mod 403 = 349 \mod 403$

本例中的 RSA 问题如下：您将得到 $N = 403$、$e = 103$、$y = 349 \mod 403$。您现在必须计算出 $x$ 使 $x^{103} = 349 \mod 403$。也就是说，您必须发现在乘以 103 的指数之前的原始值是 2。

如果我们知道 $d = 7$，那么计算 $x$ 就很容易了（至少对计算机而言）。在这种情况下，您只需按下面的方法确定 $x$。


- $x = y^7 \mod 403 = 349^7 \mod 403 = 630,634,881,591,804,949 \mod 403 = 2 \mod 403$

问题在于，我们没有向您提供 $d = 7$ 的信息。当然，你可以根据 $103 \cdot d = 1 \mod 360$ 计算出 $d$。问题是你也没有得到 $N = 360$ 的信息。最后，你也可以通过计算下面的乘积来计算 403 的阶：$(p - 1) \cdot (q - 1)$ 。但是，我们也没有告诉您 $p = 13$ 和 $q = 31$。

当然，计算机仍然可以比较容易地解决这个例子中的 RSA 问题，因为所涉及的素数并不大。但当质数变得非常大时，计算机就会面临几乎不可能完成的任务。

现在，我们已经介绍了 RSA 问题、它的一系列困难条件以及基本数学知识。这些对非对称密码学有什么帮助呢？具体来说，我们如何才能将 RSA 问题在特定条件下的难度转化为加密方案或数字签名方案？

一种方法是利用 RSA 问题，以简单明了的方式构建方案。例如，假设您按照 RSA 问题中的描述生成了一组变量 $\Pi$，并确保 $p$ 和 $q$ 足够大。您将公钥设置为 $(N,e)$，并与全世界共享这一信息。如上所述，您要对 $p$、$q$、$\phi(n)$ 和 $d$ 的值保密。事实上，$d$ 就是你的私人密钥。

如果有人想给您发送一条 $m$ 的信息，而该信息又是 $C_N$ 的一个元素，那么他只需对该信息进行如下加密即可：您只需计算 $c^d \mod N$，就可以轻松解密这条信息。

您可以尝试以同样的方式创建数字签名方案。假设你想给某人发送一条带有数字签名 $S$ 的信息 $m$。你只需设置 $S = m^d \mod N$ 并将一对 $(m,S)$ 发送给收件人。任何人都可以通过检查 $S^e \mod N = m \mod N$ 来验证数字签名。然而，任何攻击者都很难为信息创建有效的 $S$，因为他们并不拥有 $d$。

遗憾的是，将 RSA 问题这个本身就很难解决的问题转化为加密方案并不那么简单。对于直截了当的加密方案，你只能选择 $N$ 的共素数作为你的信息。这样我们就没有多少可能的信息，当然也就不足以进行标准通信。此外，这些信息必须随机选择。这似乎有点不切实际。最后，任何被选择两次的信息都会产生完全相同的密文。这在任何加密方案中都是极不可取的，也不符合任何严格的现代加密安全标准概念。

对于我们简单明了的数字签名方案来说，问题变得更加严重。目前的情况是，任何攻击者只需首先选择 $N$ 的一个共乘数作为签名，然后计算相应的原始信息，就可以轻松伪造数字签名。这显然打破了存在不可伪造性的要求。

不过，只要增加一点巧妙的复杂性，RSA 问题就可以用来创建安全的公开密钥加密方案和安全的数字签名方案。在此，我们将不再详述此类构造的细节。[4] 但重要的是，这种额外的复杂性并不会改变这些方案所基于的基本 RSA 问题。

**注：**

[4] 例如，参见 Jonathan Katz 和 Yehuda Lindell，《现代密码学入门》，CRC Press (Boca Raton, FL: 2015)，关于 RSA 加密的第 410-32 页和关于 RSA 数字签名的第 444-41 页。

# 结论

<partId>e538fb79-bf28-40cd-a5c3-badf864d8567</partId>

## 评论 & 评分
<chapterId>366d6fd0-ceb2-4299-bf37-8c6dfcb681d5</chapterId>
<isCourseReview>true</isCourseReview>
 

## 期末考试
<chapterId>44882d2b-63cd-4fde-8485-f76f14d8b2fe</chapterId>
<isCourseExam>true</isCourseExam>

## 结论
<chapterId>f1905f78-8cf7-5031-949a-dfa8b76079b4</chapterId>
<isCourseConclusion>true</isCourseConclusion>
