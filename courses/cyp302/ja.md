---
name: 形式暗号入門
goal: 暗号の科学と実践を深く掘り下げた入門書。
objectives: 

  - 暗号の基本的な概念と歴史的な概念を理解するために、ビール暗号と現代の暗号手法を探求する。
  - 数論、群、場を深く掘り下げ、暗号の基礎となる重要な数学的概念をマスターする。
  - 対称暗号アルゴリズムについて学ぶために、RC4ストリーム暗号と128ビット鍵のAESを学ぶ。
  - RSA暗号システム、鍵配布、ハッシュ関数を調査し、非対称暗号を探求する。

---
# 暗号学への深入り

暗号教育において、良い中間点を提供する教材を多く見つけるのは難しい。

一方では、数学、論理学、あるいはその他の形式的な学問分野の強力なバックグラウンドを持っている人だけがアクセスできる、長くて形式的な論文がある。一方では、非常にハイレベルな入門書もあり、少なくとも少し興味がある人にとっては、詳細があまりにも多く隠されている。

この暗号学入門書は、その中間を狙ったものである。暗号を初めて学ぶ人にとっては、比較的挑戦的で詳細な内容であるが、典型的な基礎的な論文のようなウサギの穴のようなものではない。

+++
# はじめに

<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## 短い説明

<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

本書は暗号の科学と実践について深く掘り下げた入門書である。可能な限り、形式的な説明よりも概念的な説明に重点を置いている。

> このコースは[JWBurgersのレポ](https://github.com/JWBurgers/An_Introduction_to_Cryptography)に基づいています。JWBurgersの了解を得ています。コンテンツはまだ完成しておらず、JWBurgerの同意が得られればどのように統合できるかを紹介するためだけにここにあります。
### 動機と目的

暗号教育において、良い中間点を提供する教材を多く見つけるのは難しい。

一方では、数学、論理学、あるいはその他の形式的な学問分野の強力なバックグラウンドを持っている人だけがアクセスできる、長くて形式的な論文がある。一方では、非常にハイレベルな入門書もあり、少なくとも少し興味がある人にとっては、詳細があまりにも多く隠されている。

この暗号学入門書は、その中間を狙ったものである。暗号を初めて学ぶ人にとっては、比較的挑戦的で詳細な内容であるが、典型的な基礎的な論文のようなウサギの穴のようなものではない。

### 対象読者

開発者から知的好奇心旺盛な人に至るまで、本書は暗号技術の表面的な理解以上のものを求めるすべての人に役立つ。暗号技術をマスターすることが目的であれば、本書は良い出発点にもなるだろう。

### 読書ガイドライン

この本には現在7つの章がある：「暗号とは何か」（第1章）、「暗号の数学的基礎I」（第2章）、「暗号の数学的基礎II」（第3章）、「対称暗号」（第4章）、「RC4とAES」（第5章）、「非対称暗号」（第6章）、「RSA暗号システム」（第7章）。最終章として「暗号の実際」が追加される予定である。この章では、トランスポート層のセキュリティ、オニオン・ルーティング、ビットコインの価値交換システムなど、さまざまな暗号アプリケーションに焦点を当てている。

数学の知識が豊富でない限り、数論は本書で最も難しいトピックであろう。第3章でその概要を説明し、第5章のAESと第7章のRSA暗号システムの説明にも登場する。

もし、このような部分の形式的なディテールに本当に悩んでいるのであれば、初回はハイレベルな読み物に落ち着くことをお勧めする。

### 謝辞

この本を形作る上で最も影響力のある本は、ジョナサン・カッツとイェフダ・リンデルの『現代暗号学入門』（CRC Press, Boca Raton, FL）、2015年である。Courseraでは "Cryptography "というコースが用意されている。

本書の概要の作成に役立った主な追加資料は、Simon Singh, _The Code Book_, Fourth Estate (London, 1999); Christof Paar and Jan Pelzl, _Understanding Cryptography_, Springer (Heidelberg, 2010) and [a course based on the book by Paar called "Introduction to Cryptography"](https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg); and Bruce Schneier, Applied Cryptography, 2nd edn, 2015 (Indianapolis, IN: John Wiley & Sons)である。

私は、これらの情報源から得た非常に具体的な情報と結果のみを引用するが、ここでは彼らへの一般的な恩義を認めたい。

この入門書の後に暗号技術についてより高度な知識を求める読者には、カッツとリンデルの本を強くお勧めする。CourseraにあるKatzのコースは、この本よりもいくらかわかりやすい。

### 寄付金

プロジェクトをサポートするためのガイドラインについては、[リポジトリ内のコントリビューションファイル](https://github.com/JWBurgers/An_Introduction_to_Cryptography/blob/master/Contributions.md)をご覧ください。

### 表記

**主要な用語:**

入門書のキーワードは太字にして紹介する。例えば、Rijndael暗号をキータームとして紹介する場合は次のようになる： **Rijndael cipher**.

主要な用語は、固有名詞であったり、議論からその意味が明らかである場合を除き、明確に定義されている。

定義は通常、重要な用語の導入時に行うが、後ほど定義する方が便利な場合もある。

**強調される単語とフレーズ：**。

語句はイタリック体で強調される。例えば、"Remember your password "というフレーズは以下のようになります： *パスワードを記憶してください。

**正式表記:**

正式な表記法は主に変数、確率変数、集合に関するものである。


- 変数：これらは通常、小文字で示される（例："x "や "y"）。わかりやすくするために大文字にすることもある（例えば "M "や "K"）。
- 確率変数：これらは常に大文字で示される（例えば "X "や "Y"）。
- セット：これらは常に太字の大文字で示される（例：**S**）。

# 暗号技術とは何か？

<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

## ビール暗号

<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>

暗号の歴史において、より魅力的で楽しいエピソードのひとつであるビール暗号から、暗号分野への探究を始めよう。[1]

ビール暗号の話は、現実というよりフィクションである可能性が高いと私は思う。しかし、次のような経緯があったとされている。

1820年と1822年の冬、トーマス・J・ビールという男がリンチバーグ（ヴァージニア州）のロバート・モーリス所有の宿に滞在した。2度目の滞在の終わりに、彼は貴重な書類を入れた鉄の箱をモリスに手渡した。

数ヵ月後、モリスはビールから1822年5月9日付の手紙を受け取った。その手紙には、鉄の箱の中身の価値の高さが強調され、モリスへのいくつかの指示が書かれていた。もしベールも彼の仲間もこの箱を引き取りに来なかったら、手紙の日付（つまり1832年5月9日）から正確に10年後に箱を開けること。中に入っていた書類のいくつかは普通の文章で書かれていた。しかし、他のいくつかの紙は、「鍵の助けなしには理解できない」だろう。この "鍵 "は、1832年6月、ベールの無名の友人によってモーリスに届けられることになる。

明確な指示があったにもかかわらず、モーリスは1832年5月に箱を開けず、ビール氏の謎めいた友人もその年の6月には現れなかった。宿の主人がようやく箱を開ける決心をしたのは1845年のことだった。その箱の中でモーリスは、ビールとその仲間が西部で金銀を発見し、それを宝飾品とともに大切に埋めたことを説明するメモを見つけた。さらに、箱の中には3つの**暗号文**が入っていた。それは暗号で書かれた文章で、暗号を解くには**暗号鍵**、つまり秘密とそれに付随するアルゴリズムが必要である。暗号文を解除するこのプロセスは**復号化**と呼ばれ、ロックするプロセスは**暗号化**と呼ばれる。(第3章で説明したように、暗号という言葉にはさまざまな意味がある。ビール暗号 "という名前では、暗号文の略である)。

モーリスが鉄の箱の中で見つけた3つの暗号文は、それぞれコンマで区切られた数字の羅列で構成されている。ベールのメモによれば、これらの暗号文には、宝のありか、宝の中身、宝の正当な相続人の名前とその持ち分のリストが別々に記されている（後者の情報は、ベールとその仲間が箱を受け取りに来なかった場合に関係する）。

モリスは20年間、3つの暗号文の解読を試みた。鍵があれば簡単なことだった。しかし、モリスは鍵を持っていなかったため、原文、つまり暗号学で一般的に呼ばれる**平文**を復元しようとしても失敗した。

人生の終わりに近づいた1862年、モーリスはこの箱を友人に譲った。この友人はその後、1885年にJ.B.ウォードというペンネームでパンフレットを出版した。そこには箱の歴史（とされるもの）、3つの暗号文、そして2つ目の暗号文について彼が見つけた解法が書かれていた。(どうやら各暗号文には一つの鍵があり、ビールがモリスに宛てた手紙の中で当初示唆していたと思われるように、三つの暗号文すべてに通用する鍵は一つではないらしい）。

以下の*図2*で2つ目の暗号文を見ることができる。[この暗号文の鍵はアメリカ合衆国独立宣言である。解読の手順は、次の2つのルールを適用することになる：


- 暗号文中の任意の数nについて、アメリカ合衆国独立宣言のn番目の単語を探し出す。
- 数字のnを、見つけた単語の最初の文字に置き換えてください。

*図1：ビール暗号No.2*

![Figure 1: Beale cipher no 2.](assets/Figure1-1.webp "Figure 1: Beale cipher no. 2")

例えば、2番目の暗号文の最初の数字は115である。独立宣言の115番目の単語は "instituted "なので、平文の最初の文字は "i "である。暗号文は単語の間隔や大文字を直接示していない。しかし、最初の数単語を解読した後、平文の最初の単語は単に "I "であったと論理的に推論することができる。(平文は "I have deposited in the county of Bedford "というフレーズで始まる）。

解読後、2つ目のメッセージには財宝の詳細な内容（金、銀、宝石）が記載され、ベッドフォード郡（バージニア州）で鉄鍋に入れられ、岩で覆われて埋められたことが示唆されている。人々はミステリーが大好きなので、他の2つのビール暗号、特に宝のありかを記した暗号の解読に多大な努力が払われてきた。様々な著名な暗号学者でさえ、その解読を試みている。しかし、今のところ、他の2つの暗号文を解読できた者はいない。

**注：**。

[1] ストーリーの概要については、サイモン・シン『コード・ブック』（1999年、ロンドン）、82-99頁を参照。2010年にアンドリュー・アレンによってこの物語の短編映画が作られた。映画『The Thomas Beale Cipher』は［ウェブサイトで］見ることができる（http://www.thomasbealecipher.com/）。

[2] この画像はウィキペディアのビール暗号のページに掲載されている。

## 現代の暗号技術

<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

ビール暗号のようなカラフルなストーリーは、私たちの多くが暗号を連想するものだ。しかし、現代の暗号は、こうした歴史的な例とは少なくとも4つの点で異なっている。

第一に、歴史的に暗号は**秘密性**（または機密性）にのみ関係してきた。[3] 暗号文は、ビール暗号の場合のように、特定の当事者だけが平文の情報を知ることができるように作成される。暗号化方式がこの目的を十分に果たすためには、暗号文の解読は鍵を持っている場合にのみ可能でなければならない。

現代の暗号は、秘密性だけでなく、より広範なテーマに取り組んでいる。これらのテーマには主に、(1) **メッセージの完全性**-つまり、メッセージが変更されていないことを保証すること、(2) **メッセージの真正性**-つまり、メッセージが特定の送信者から本当に来たものであることを保証すること、(3) **否認防止**-つまり、送信者がメッセージを送ったことを後で偽って否定できないことを保証すること、が含まれる。[4]

このように、**暗号化スキーム**と**暗号化スキーム**を区別することが重要である。暗号化スキームは単に秘密に関わるものである。暗号化スキームは暗号化スキームであるが、その逆は真ではない。暗号方式は、完全性、真正性、否認防止など、暗号の他の主要なテーマにも対応することができる。

完全性と真正性というテーマは、秘密性と同様に重要である。現代の通信システムは、通信の完全性と真正性が保証されなければ機能しない。否認防止もまた、デジタル契約のような重要な関心事であるが、暗号アプリケーションでは、秘密性、完全性、真正性に比べて、あまり広く必要とされていない。

第2に、ビール暗号のような古典的な暗号化方式では、関係者間で共有される鍵は常に1つである。しかし、現代の暗号化方式の多くは1つだけでなく、**秘密鍵**と**公開鍵**という2つの鍵を含んでいる。前者はどのような用途でも非公開のままであるべきだが、後者は通常、公知のものである（それゆえ、それぞれの名前がある）。暗号化の分野では、公開鍵はメッセージの暗号化に使われ、秘密鍵は復号化に使われる。

すべての関係者が1つの鍵を共有する方式を扱う暗号の一分野は、**対称暗号** として知られている。このような方式における1つの鍵は、通常**秘密鍵** (または秘密鍵)と呼ばれる。秘密鍵と公開鍵のペアを必要とする暗号方式を扱う暗号学は、**非対称暗号** と呼ばれる。これらの分岐は、それぞれ**秘密鍵暗号**および**公開鍵暗号**とも呼ばれることがある（ただし、公開鍵暗号方式にも秘密鍵があるため、混乱を招く可能性がある）。

1970年代後半の非対称暗号の登場は、暗号の歴史において最も重要な出来事の一つである。これがなければ、ビットコインを含む現代の通信システムのほとんどは実現しなかったか、少なくとも非常に実用的ではなかっただろう。

重要なのは、現代の暗号学は共通鍵暗号方式とアサイメトリック鍵暗号方式だけを研究しているわけではないということだ（この分野の大部分は共通鍵暗号方式で占められているが）。例えば、暗号はハッシュ関数や擬似乱数生成器にも関係しており、共通鍵暗号やアサイメトリック鍵暗号とは関係のない、これらのプリミティブを使ったアプリケーションを構築することもできる。

第三に、ビール暗号で使われていたような古典的な暗号化方式は、科学というより芸術だった。その安全性の認識は、その複雑さに関する直感に大きく基づいていた。これらの暗号方式は通常、それに対する新たな攻撃が発見されたときにパッチを当てるか、その攻撃が特に深刻なものであった場合は完全に削除された。しかし、現代の暗号学は、暗号スキームの開発と解析の両方に、形式的で数学的なアプローチを用いた厳密な科学である[5]。[5]

具体的には、現代の暗号技術は形式的な**安全性の証明**を中心としている。暗号スキームの安全性の証明は、3つのステップで進められる：

1.	セキュリティの**暗号的な定義**、すなわち、一連のセキュリティ目標と攻撃者がもたらす脅威の声明。

2.	スキームの計算複雑性に関する数学的仮定の記述。例えば、暗号スキームには擬似乱数生成器が含まれている可能性がある。これらの存在を証明することはできないが、存在すると仮定することはできる。

3.	セキュリティの形式的概念と数学的仮定に基づいて、スキームの数学的**安全性**の証明を説明すること。

第四に、歴史的に暗号は主に軍事的な場面で利用されてきたが、デジタル時代には日常生活に浸透している。オンラインバンキングであれ、ソーシャルメディアへの投稿であれ、アマゾンでクレジットカードを使って商品を購入するときであれ、友人にビットコインをチップとして渡すときであれ、暗号はデジタル時代の必須条件である。

これら4つの側面から現代暗号を考えると、現代**暗号**とは、敵対的な攻撃からデジタル情報を保護するための暗号方式の正式な開発と分析に関わる科学である。[6] ここでのセキュリティとは、通信における秘密性、完全性、認証、および／または否認防止を損なう攻撃を防ぐこととして広く理解されるべきである。

暗号は**サイバーセキュリティ**の一分野であり、コンピュータシステムの窃盗、損害、悪用を防ぐことを目的としている。サイバーセキュリティに関する多くの問題は、暗号技術とはほとんど関係がないか、部分的にしか関係がないことに注意すること。

例えば、ある企業が高価なサーバーをローカルに置いている場合、このハードウェアを盗難や損傷から守ることを心配するかもしれない。これはサイバーセキュリティの問題ではあるが、暗号技術とはあまり関係がない。

別の例を挙げると、**フィッシング攻撃**は現代においてよくある問題である。これらの攻撃は、電子メールやその他のメッセージ媒体を通じて人々を欺き、パスワードやクレジットカード番号などの機密情報を放棄させようとするものである。暗号はある程度フィッシング攻撃に対処するのに役立つが、包括的なアプローチには、単に暗号を使うだけでは不十分である。

**注：**。

[3]正確に言えば、暗号方式の重要な応用は、秘密に関するものであった。例えば、子供たちは単純な暗号方式を "遊び "のためによく使う。このような場合、秘匿性はあまり問題にならない。

[4] Bruce Schneier, *Applied Cryptography*, 2nd edn, 2015 (Indianapolis, IN: John Wiley & Sons), p. 2.

[5] Jonathan Katz and Yehuda Lindell, *Introduction to Modern Cryptography*, CRC Press (Boca Raton, FL: 2015), esp.

[6] Katz and Lindell, ibid., p. 3.を参照のこと。私は、彼らの表現には問題があると思うので、ここでは少し違うバージョンを紹介する。

## オープン・コミュニケーション

<chapterId>cb23d0a6-ba9a-5dc6-a55a-258405ae4117</chapterId>

現代の暗号は、**オープンな通信**環境においてセキュリティを保証するために設計されている。もし私たちの通信チャネルが、盗聴者が私たちのメッセージを操作したり、あるいはただ観察したりする可能性さえないほど十分に保護されているのであれば、暗号は余計なものである。しかし、私たちのコミュニケーション・チャネルのほとんどは、これほど厳重に守られてはいない。

現代世界における通信のバックボーンは、巨大な光ファイバーケーブルのネットワークである。現代の家庭で電話をかけたり、テレビを見たり、ウェブを閲覧したりするのは、一般的にこの光ファイバーケーブルのネットワークに依存している（ごく一部は純粋に衛星に依存している場合もある）。確かに、家庭内には同軸ケーブル、（非対称）デジタル加入者線、光ファイバーケーブルなど、さまざまなデータ接続があるかもしれない。しかし、少なくとも先進国では、これらの異なるデータ媒体はすぐに家の外で、地球全体をつなぐ巨大な光ファイバー・ケーブル・ネットワークのノードに接続される。例外は、アメリカやオーストラリアなど、先進国の一部の遠隔地で、データ・トラフィックが従来の銅線電話線でもかなりの距離を移動する場合があることだ。

潜在的な攻撃者がこのケーブル網とそれを支えるインフラに物理的にアクセスするのを防ぐことは不可能だろう。実際、私たちのデータのほとんどが、インターネットの重要な交差点でさまざまな国家情報機関によって傍受されていることはすでに知られている[7]。これには、フェイスブックのメッセージからあなたが訪問したウェブサイトのアドレスまで、あらゆるものが含まれる。

大規模なデータを監視するには、国家情報機関のような強力な敵が必要だが、わずかなリソースしか持たない攻撃者なら、もっとローカルな規模で簡単に盗聴を試みることができる。これは電線を盗聴するレベルでも可能だが、無線通信を傍受するだけならはるかに簡単だ。

家庭でも、オフィスでも、カフェでも、私たちのローカル・ネットワーク・データのほとんどは、物理的なケーブルではなく、オールインワン・ルーターのワイヤレス・アクセス・ポイントに電波を介して移動している。そのため、攻撃者がローカル・トラフィックを傍受するのに必要なリソースはほとんどない。ほとんどの人は、ローカル・ネットワークを通過するデータを保護するためにほとんど何もしていないため、これは特に懸念すべきことです。さらに、潜在的な攻撃者は、3G、4G、5Gなどのモバイル・ブロードバンド接続も標的にすることができる。これらの無線通信はすべて、攻撃者にとって格好の標的なのだ。

したがって、通信経路を保護することで通信の秘密を守ろうという考えは、現代世界の多くにとって絶望的なまでに妄想的な願望である。私たちが知っていることはすべて、深刻なパラノイアを保証するものだ。そして暗号は、この現代環境においてあらゆる種類のセキュリティを得るための主要な手段なのである。

**注：**。

[7] 例えば、Olga Khazan, "The creepy, long-standing practice of undersea cable tapping", *The Atlantic*, July 16, 2013 (available at [The Atlantic](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/)).

# 暗号の数学的基礎1

<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

## ランダム変数

<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

暗号は数学に依存している。暗号技術について表面的な理解以上のものを得たいのであれば、その数学に慣れておく必要がある。

この章では、暗号を学ぶ上で遭遇する基本的な数学のほとんどを紹介する。ランダム変数、モジュロ演算、XOR 演算、擬似ランダム性などである。暗号を表面的に理解しないためには、これらのセクションの内容をマスターする必要があります。

次のセクションでは、より難易度の高い数論を扱う。

### ランダム変数

確率変数は通常、太字でない大文字で表します。例えば、確率変数$X$、確率変数$Y$、確率変数$Z$というように。以降もこの表記法を使います。

確率変数**は2つ以上の可能な値を取ることができ、それぞれがある正の確率を持つ。取り得る値は**結果集合**にリストされている。

確率変数を**サンプル**するたびに、定義された確率に従って、その結果セットから特定の値を引きます。

簡単な例を挙げよう。次のように定義された変数Xがあるとする：


- Xは結果集合${1,2}$を持つ。

$$
Pr[X = 1] = 0.5
$$

$$
Pr[X = 2] = 0.5
$$

X$が確率変数であることは簡単にわかる。まず、$X$が取りうる値は$1$と$2$の2つ以上である。次に、$X$ を標本にするときはいつでも、$0.5$ という正の確率で起こりうる値がある。

確率変数に必要なのは、2つ以上の可能性を持つ結果集合であり、それぞれの可能性はサンプリング時に正の確率で発生する。原理的には、確率変数は文脈を無視して抽象的に定義することができる。この場合、「サンプリング」とは、確率変数の値を決定するために何らかの自然実験を行うことだと考えることができる。

上の変数$X$は抽象的に定義した。したがって、上の変数 $X$ のサンプリングは、公平なコインをひっくり返して、表なら「2」、裏なら「1」を代入するようなものだと考えればよい。X$をサンプリングするごとに、もう一度コインを裏返す。

あるいは、$X$のサンプリングは、公平なダイスを振って、$1$、$3$、$4$のいずれかが出たら「2」とし、$2$、$5$、$6$のいずれかが出たら「1」とする、と考えることもできる。X$をサンプリングするたびに、もう一度ダイスを振る。

本当に、上記の$X$の可能な値の確率を定義することができるような自然実験は、図面に関して想像することができる。

しかし多くの場合、確率変数は抽象的に導入されるだけではない。その代わりに、可能性のある結果値の集合は、（単なる数値としてではなく）現実世界での明確な意味を持つ。さらに、これらの結果値は、ある特定のタイプの実験に対して定義されるかもしれない（むしろ、それらの値を持つ任意の自然な実験として）。

ここで、抽象的に定義されていない変数$X$の例を考えてみよう。Xは2つのチームのどちらがサッカーの試合を始めるかを決めるために次のように定義される：


- X$は結果集合{赤キックオフ,青キックオフ}を持つ。
- 特定のコイン$C$を裏返す：表＝"赤が蹴られる"、裏＝"青が蹴られる"

$$
Pr [X = \text{red kicks off}] = 0.5
$$

$$
Pr [X = \text{blue kicks off}] = 0.5
$$

この場合、Xの結果集合は、フットボールの試合でどのチームが先発するかという具体的な意味を持つ。さらに、可能な結果とそれに関連する確率は、特定のコイン$C$を裏返すという具体的な実験によって決定される。

暗号技術の議論では、通常、現実世界での意味を持つ結果集合に対して確率変数が導入される。それは、メッセージ空間として知られる暗号化される可能性のあるすべてのメッセージの集合であったり、鍵空間として知られる暗号化を使用する当事者が選択できるすべての鍵の集合であったりする。

しかし、暗号に関する議論における確率変数は、特定の自然実験に対して定義されるのではなく、正しい確率分布が得られる可能性のあるあらゆる実験に対して定義されるのが普通である。

確率変数には離散確率分布と連続確率分布がある。離散確率分布**を持つ確率変数、つまり離散確率変数は、起こりうる結果の数が有限である。これまで挙げた2つの例題の確率変数 $X$ は離散的なものでした。

**連続確率変数**は、代わりに1つ以上の区間の値を取ることができます。例えば、ある確率変数がサンプリングされると、0から1の間の任意の実数値をとり、この区間内の各実数は等しく可能性があると言うことができる。この区間内では、無限に可能な値があります。

暗号に関する議論では、離散乱数変数のみを理解すればよい。従って、これから先の確率変数の議論は、特に断りのない限り、離散確率変数を指すものとして理解されたい。

### 確率変数のグラフ化

確率変数の取り得る値と関連する確率は、グラフによって簡単に可視化できる。例えば、前節の確率変数 $X$ の結果集合が $Pr [X = 1] = 0.5$ と $Pr [X = 2] = 0.5$ であるとする。このような確率変数を*図1*のように棒グラフの形で表示するのが一般的である。

*図 1: 確率変数 X*

![Figure 1: Random variable X.](assets/Figure2-1.webp)

図1*の幅の広い棒グラフは、明らかに確率変数$X$が実際に連続であることを示唆するものではない。むしろ、棒グラフの幅を広くしているのは、視覚的にわかりやすくするためである（まっすぐな線だけでは、直感的な視覚化ができない）。

### 一様変数

ランダム変数」という表現において、「ランダム」という用語は「確率的」という意味にすぎない。言い換えれば、その変数の2つ以上の可能な結果がある確率で発生することを意味する。しかし、これらの結果は、必ずしも同じ確率である必要はない（ただし、「ランダム」という用語は、他の文脈では実際にそのような意味を持つことがある）。

一様変数**は確率変数の特殊なケースである。これは、すべて等しい確率で2つ以上の値をとることができる。図1*の確率変数$X$は明らかに一様変数である。しかし、一様変数ではない確率変数もたくさんある。

例えば、確率変数 $Y$ を考える。これは結果集合${1, 2, 3, 8, 10}$を持ち、以下の確率分布を持つ：

$$
\Pr[Y = 1] = 0.25
$$

$$
\Pr[Y = 2] = 0.35
$$

$$
\Pr[Y = 3] = 0.1
$$

$$
\Pr[Y = 8] = 0.25
$$

$$
\Pr[Y = 10] = 0.05
$$

確かに$1$と$8$の2つの結果は等しい確率で起こりうるが、$Y$はサンプリングによって$0.25$とは異なる確率で特定の値をとることもある。したがって、$Y$は確かに確率変数であるが、一様変数ではない。

Y$を図式化したものが*図2*である。

*図2：確率変数Y

![Figure 2: Random variable Y.](assets/Figure2-2.webp "Figure 2: Random variable Y")

最後の例として、確率変数Zを考えてみよう。Zは結果集合{1,3,7,11,12}を持ち、以下の確率分布を持つ：

$$
\Pr[Z = 2] = 0.2
$$

$$
\Pr[Z = 3] = 0.2
$$

$$
\Pr[Z = 9] = 0.2
$$

$$
\Pr[Z = 11] = 0.2
$$

$$
\Pr[Z = 12] = 0.2
$$

図3*を参照されたい。確率変数Zは、Yとは対照的に一様変数であり、サンプリング時に可能な値の確率はすべて等しい。

*図 3: ランダム変数 Z*

![Figure 3: Random variable Z.](assets/Figure2-3.webp "Figure 3: Random variable Z")

### 条件付き確率

ボブは去年の暦年から一律に一日を選ぶつもりだとする。選択された日が夏である確率はどのように結論づけられるだろうか？

ボブのプロセスが本当に一様であると考える限り、ボブが夏の日を選ぶ確率は1/4であると結論づけられるはずである。これは、ランダムに選択された日が夏である**無条件確率**である。

ここで、ボブは暦日を一律に選ぶのではなく、クリスタル湖（ニュージャージー州）の正午の気温が摂氏21度以上の日だけを一律に選ぶとする。この追加情報を考えると、ボブが夏の日を選ぶ確率はどう結論づけられるだろうか？

それ以上の具体的な情報（例えば、昨年の各日の正午の気温）がなくても、以前とは異なる結論が導き出されるはずだ。

クリスタル・レイクがニュージャージー州にあることを考えると、冬の正午の気温が摂氏21度以上になることはないだろう。むしろ、春か秋の暖かい日か、夏のどこかの日である可能性が高い。したがって、選択した日のクリスタルレイクの正午の気温が21℃以上であることを知っていれば、ボブが選択した日が夏である確率はずっと高くなる。これが，水晶湖の正午の気温が摂氏21度以上であったと仮定した場合の，無作為に選択された日が夏である**条件付き確率**である。

前の例とは異なり、2つの事象の確率がまったく無関係であることもある。その場合、両者は**独立**であると言う。

例えば、ある公平なコインの表が出たとする。この事実から、明日雨が降る確率はいくらになるだろうか？この場合の条件付き確率は、明日雨が降るという無条件確率と同じになるはずである。なぜなら、コインの裏表は一般に天気に何の影響も与えないからである。

条件付き確率の記述には「｜」記号を使う。例えば、事象 $B$ が起こったときの事象 $A$ の確率は次のように書ける：

$$
Pr[A|B]
$$

つまり、$A$と$B$の2つの事象が独立であるとき、次のようになる：

$$
Pr[A|B] = Pr[A] \text{ and } Pr[B|A] = Pr[B]
$$

独立性の条件は次のように単純化できる：

$$
Pr[A, B] = Pr[A] \cdot Pr[B]
$$

確率論の重要な結果に**ベイズの定理**がある。これは基本的に$Pr[A|B]$は次のように書き換えられるというものである：

$$
Pr[A|B] = \frac{Pr[B|A] \cdot Pr[A]}{Pr[B]}
$$

特定の事象に対する条件付き確率を使う代わりに、起こりうる事象の集合に対して2つ以上の確率変数に関係する条件付き確率を見ることもできる。X$と$Y$の2つの確率変数があるとする。X$の取りうる値を$x$とし、$Y$の取りうる値を$y$とする。このとき、次の式が成り立つとき、2つの確率変数は独立であると言える：

$$
Pr[X = x, Y = y] = Pr[X = x] \cdot Pr[Y = y]
$$

すべての$x$と$y$について。

この発言の意味をもう少し明確にしよう。

X$と$Y$の結果集合が次のように定義されているとする： **X** = ${x_1, x_2, \ldots, x_i, \ldots, x_n}$, **Y** = ${y_1, y_2, \ldots, y_i, \ldots, y_m}$ とする。(値の集合を太字の大文字で示すのが一般的である)。

ここで、$Y$を標本にして$y_1$を観測したとする。上の文は、今 $X$ をサンプリングして $x_1$ が得られる確率は、$y_1$ を観測しなかったときとまったく同じであることを示しています。これは、最初に$Y$をサンプリングして得られた$y_i$についても同じです。最後に、このことは $x_1$ に限ったことではありません。どのような $x_i$ に対しても、$Y$ のサンプリングの結果によって発生確率が左右されることはありません。このことは、$X$を最初にサンプリングした場合にも当てはまります。

もう少し哲学的な話をしよう。現実世界のどのような状況においても、ある事象の確率は常に特定の情報の集合に対して評価される。厳密な意味での「無条件確率」は存在しない。

例えば、私が2030年までに豚が空を飛ぶ確率を尋ねたとしよう。私はそれ以上の情報を与えないが、あなたは明らかに、あなたの判断に影響を与えうる世界について多くのことを知っている。あなたは豚が飛ぶのを見たことがない。あなたは、ほとんどの人が豚が飛ぶとは思っていないことを知っている。豚は飛ぶようにはできていない。などなど。

したがって、現実世界の文脈で、ある事象の「無条件確率」について語るとき、この用語は、「それ以上の明示的な情報がない場合の確率」というような意味でしか意味を持ち得ないのである。したがって、「条件付き確率」を理解するときは、常に何らかの特定の情報に対して理解しなければならない。

例えば、ニュージーランドのヤギが数年の訓練で空を飛べるようになったという証拠を示した後で、2030年までに豚が空を飛ぶ確率を尋ねるかもしれない。この場合、おそらくあなたは2030年までに豚が飛ぶ確率の判断を修正するだろう。つまり、2030年までにブタが飛ぶ確率は、ニュージーランドのヤギに関するこの証拠を条件としているのである。

## モジュロ演算

<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

### モジュロ

モジュロ演算**を使った最も基本的な式は次の形である。

変数 $x$ を配当、変数 $y$ を除数という。正の配当と正の除数でモジュロ演算を行うには、除算の余りを求めればいい。

例えば、$25 \mod 4$という式を考えてみよう。25 の中に 4 が合計 6 回入る。したがって、$25 ⊖mod 4$は1になります。同様にして、下の式も評価できる：


- 30 = 29$ (30が29に入るのは0回で、余りは29だから)
- 42 ゙mod 2 = 0$ (2が42に入るのは合計21回で、余りは0だから)
- $12 ゙mod 5 = 2$ (5が12に合計2回入り、余りが2なので)
- 20 ╱ 8 = 4$ (8が20に入るのは全部で2回で、余りは4だから)

配当や除数が負である場合、モジュロ演算はプログラミング言語によって扱いが異なることがある。

暗号で配当がマイナスになるケースには必ず出くわす。このような場合、典型的なアプローチは次のようになる：


- まず、除数がゼロの余りで割り切れる、配当より*小さいか*等しい*最も近い値を求める。その値を $p$ と呼ぶ。
- 配当が $x$ なら、モジュロ演算の結果は $x - p$ の値である。

例えば、配当が $-20$ で除数が 3 だとする。3 が均等になる $-20$ 以下の最も近い値は $-21$ である。このとき、 $x - p$ の値は $-20 - (-21)$ となる。これは 1 に等しいので、 $-20 ㎟ 3$ は 1 に等しい。同様にして、下の式も評価できます：


- 8 ╱ 5 = 2$.
- 19 ¶mod 16 = 13$
- 14 ╱6 = 4$.

表記については、一般的に次のような式を見かけます： $x = [y \mod z]$.括弧の関係で、この場合のモジュロ演算は式の右辺にしか適用されません。例えば、$y$が25で$z$が4なら、$x$は1になる。

括弧がない場合、モジュロ演算は式の両辺*に作用する。例えば、 $x = y \mod z$ という式があるとする。これは、$x$が集合${ldots,-7,-3,1,5,9,}$の中のどの値でも一致する。

数や式に対するモジュロ演算を含む数学の一分野を**モジュラ算**と呼ぶ。この分野は、数列が無限に長くない場合の算術と考えることができる。暗号技術では（正の）整数に対するモジュロ演算が一般的ですが、任意の実数を用いてモジュロ演算を行うこともできます。

### シフト暗号

モジュロ演算は暗号の世界では頻繁に登場する。例として、歴史的に最も有名な暗号化方式の一つであるシフト暗号を考えてみよう。

まずそれを定義しよう。英語のアルファベットを順番に並べた辞書*D*と、数字の集合${0, 1, 2, Γ, 25}$があるとする。メッセージ空間**M**を仮定する。このとき、**シフト暗号**は次のように定義される暗号化方式である：


- 鍵空間**K**から一様に鍵$k$を選択する（ここで、**K** = ${0, 1, 2, \ldots, 25}$ [1]）。
- メッセージ$mを以下のように暗号化する：
    - m$をそれぞれの文字に分ける $m_0, m_1, Ⅾ, m_i, Ⅾ, m_l$.
    - 各 $m_i$ を *D* に従って数値に変換する。
    - 各 $m_i$ に対して、 $c_i = [(m_i + k)  \mod 26]$ である。
    - 各$c_i$を*D*に従って文字に変換する。
    - 次に、$c_0, c_1, \ldots, c_l$を組み合わせて、暗号文$c$を得る。
- 暗号文$c$を以下のように復号する：
    - 各 $c_i$ を *D* に従って数値に変換する。
    - 各$c_i$について、$m_i = [(c_i - k) ˶mod 26]$.
    - 各 $m_i$ を *D* に従って文字に変換する。
    - 次に、$m_0, m_1, m_ldots, m_l$を組み合わせて、元のメッセージ$m$を得る。

シフト暗号のモジュロ演算子は文字の折り返しを保証するため、すべての暗号文の文字が定義される。例として、「DOG」という単語にシフト暗号を適用した場合を考えてみよう。

あるキーの値を一律に17にしたとする。文字 "O "は15に相当する。モジュロ演算がなければ、この平文の数字と鍵を足すと32の暗号文の数字になる。しかし、英語のアルファベットには26文字しかないため、この暗号文の数字を暗号文の文字にすることはできない。モジュロ演算により、暗号文の数字が実際には6（$32 \mod 26$の結果）になり、これが暗号文の文字 "G "に等しくなる。

DOG "という単語をキー値17で暗号化すると、以下のようになる：


- メッセージ = DOG = D,O,G = 3,15,6
- c_0 = [(3 + 17) ˶26] = [(20) ˶26] = 20 = U$.
- c_1 = [(15 + 17) ˶26] = [(32) ˶26] = 6 = G$.
- c_2 = [(6 + 17) ˶26] = [(23) ˶26] = 23 = X$.
- c = UGX$

シフト暗号の仕組みは誰でも直感的に理解できるし、おそらく自分でも使えるだろう。しかし、暗号の知識を深めるには、スキームがより難しくなるため、形式化に慣れることが重要である。それゆえ、シフト暗号の手順が形式化されたのである。

**注：**。

[1] 前節の用語を使えば、この文を正確に定義できる。一様変数 $K$ の可能な結果の集合を $K$ とする。そこで

$$
Pr[K = 0] = \frac{1}{26}
$$

$$
Pr[K = 1] = \frac{1}{26}
$$

...と続く。一様変数$K$を一度サンプリングして、特定のキーを得る。

## XOR演算

<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

すべてのコンピュータ・データは、ビット・レベルで処理され、保存され、ネットワークを介して送信される。コンピュータ・データに適用される暗号化スキームも、すべてビット・レベルで動作する。

例えば、電子メール・アプリケーションに電子メールを入力したとする。あなたが適用した暗号化は、電子メールのASCII文字に直接適用されるわけではありません。代わりに、電子メールに含まれる文字やその他の記号のビット表現に適用されます。

modulo演算のほかに、現代の暗号技術で理解すべき重要な数学演算は、**XOR演算**、つまり「排他的論理和」演算である。この演算は2つのビットを入力とし、もう1つのビットを出力とする。XOR演算は単に「XOR」と表記される。2つのビットが同じなら0を、異なるなら1を返します。以下に4つの可能性を示す。記号$oplus$は "XOR "を表す：


- 0ドル
- 0ドル
- 1ドル
- 1ドル

説明のために、メッセージ$m_1$ (01111001)とメッセージ$m_2$ (01011001)があるとする。この2つのメッセージのXOR演算は以下のようになる。


- m_1 ︓ m_2 = 01111001 ︓ 01011001 = 00100000$.

手順は簡単だ。まず$m_1$と$m_2$の左端のビットをXORする。この場合、$0 \oplus 0 = 0$である。次に左から2番目のビットをXORします。この場合、$1 \oplus 1 = 0$である。この作業を、一番右のビットの XOR 演算が終わるまで続ける。

XOR 演算が可換であること、すなわち $m_1 Ⓐ m_2 = m_2 Ⓐ m_1$ であることは簡単にわかる。さらに、XOR演算は連想演算でもある。すなわち、$(m_1 \oplus m_2) Γ m_3 = m_1 Γ (m_2 Γ m_3)$ である。

異なる長さの2つの文字列に対するXOR演算は、文脈によって異なる解釈を持つことがある。ここでは、異なる長さの文字列に対するXOR演算には触れない。

XOR演算は、除数が2の場合にビットの加算に対してモジュロ演算を行う特殊なケースと等価である：


- (0＋0)╱モッド2＝0╱プラス0＝0$。
- (1 + 0) ゙モッド 2 = 1 ゙プラス 0 = 1$.
- (0 + 1) ゙モッド2=0゙プラス1=1$。
- (1 + 1) ゙モッド 2 = 1 ゙プラス 1 = 0$.

## 疑似ランダム性

<chapterId>20463fc5-3e92-581f-a1b7-3151279bd95e</chapterId>

乱数変数と一様変数の議論では、"random "と "uniform "を明確に区別した。この区別は通常、ランダム変数を記述する際に維持されます。しかし、現在の文脈では、この区別を捨て、"random "と "uniform "を同義語として使用する必要があります。その理由はこのセクションの最後で説明します。

手始めに、長さ$n$の2進文字列を**乱数**（または**一様**）と呼ぶことができる。このような長さ$n$の各2進文字列が等しい確率で選択されるような一様変数$S$をサンプリングした結果である場合である。

例えば、長さ8のすべての2進文字列の集合${0000 0000, 0000 0001, ￢dots, 1111￢111111}$があるとする。(8ビットの文字列を2つの4分割して書くのが一般的で、それぞれを**ニブル**と呼ぶ)。この文字列の集合を**S_8$**と呼ぶことにする。

上の定義に従えば、長さ8の特定の2進文字列は、**$S_8$**の各文字列が等しい確率で選択されるような一様変数$S$をサンプリングした結果であれば、ランダム（または一様）と呼ぶことができる。集合**$S_8$**が$2^8$個の要素を含むことを考えると、サンプリング時の選択確率は、集合内の各文字列に対して$1/2^8$でなければならない。

バイナリ文字列のランダム性の重要な側面は、それが選択されたプロセスを参照して定義されることである。したがって、特定のバイナリ文字列の形式は、それ自体では、その選択におけるランダム性について何も明らかにしない。

例えば、多くの人は直感的に、$111111$のような文字列はランダムに選ばれたはずがない、という考えを持っている。しかし、これは明らかに誤りである。

長さ8の全ての2進文字列に一様変数$S$を定義すると、集合**$S_8$**から$111111$を選ぶ可能性は、$01110100$のような文字列を選ぶ可能性と同じである。このように、文字列のランダム性については、文字列自体を分析するだけでは何も分からない。

また、2進文字列を特に意味することなく、ランダムな文字列について話すこともできる。例えば、ランダムな16進文字列$AF 02\ 82$について話すことができる。この場合、この文字列は、長さ6のすべての16進文字列の集合からランダムに選択されたことになる。これは、16進の各桁が4ビットを表すので、長さ24の2進文字列をランダムに選択することと同じである。

通常、「ランダムな文字列」という表現は、無条件に、同じ長さを持つすべての文字列の集合からランダムに選択された文字列を指す。このように説明した。もちろん、長さ$n$の文字列は、別の集合からランダムに選ぶこともできます。例えば、長さ $n$ のすべての文字列の部分集合だけを構成する集合や、長さの異なる文字列を含む集合などである。しかし、そのような場合は、「ランダムな文字列」とは呼ばず、「ある集合**S**からランダムに選ばれた文字列」と呼ぶことにします。

暗号技術における重要な概念は、擬似乱数性である。長さ$n$の**擬似ランダム文字列**は、**S_n$**内の各文字列が等確率で選択される一様変数$S$をサンプリングした結果であるかのように*見える。しかし、実際には、この文字列は一様変数$S'$をサンプリングした結果であり、その一様変数$S'$は、**S_n$**の部分集合上で、すべての可能な結果に対して等しい確率を持つ確率分布を定義しているにすぎない。ここで重要なのは、$S$と$S'$のサンプルをたくさん取ったとしても、誰もそれを区別することはできないということである。

例えば、確率変数$S$があるとする。その結果集合は**$S_{256}$**であり、これは長さ256のすべての2進文字列の集合である。この集合には $2^{256}$ 個の要素がある。各要素の選択確率は等しく、サンプリング時に $1/2^{256}$ である。

さらに、確率変数$S'$があるとする。その結果集合は、長さ256の2進文字列 $2^{128}$ だけを含む。これらの文字列に対してある確率分布を持っているが、この分布は必ずしも一様ではない。

今、私が$S$から1000個のサンプルと$S'$から1000個のサンプルを取り、2組の結果をあなたに渡したとします。どちらの結果がどちらの確率変数に関連するかをあなたに伝えます。次に、私は2つの確率変数の一方からサンプルを取る。しかし、今度はどちらの確率変数を標本にするかは教えない。仮に$S'$が擬似ランダムだとすると、私がどちらの確率変数をサンプリングしたかを正しく推測できる確率は、実質的に$1/2$以下ということになる。

通常、長さ$n$の擬似乱数文字列は、サイズ$n - x$の文字列をランダムに選択し、それを展開アルゴリズムの入力として使用することによって生成される。このサイズ$n - x$のランダム文字列は**シード**として知られています。

疑似ランダム文字列は、暗号を実用的なものにするための重要な概念である。例えば、ストリーム暗号を考えてみよう。ストリーム暗号では、ランダムに選ばれた鍵が拡張アルゴリズムに差し込まれ、より大きな擬似ランダム文字列が生成される。この擬似ランダム文字列をXOR演算によって平文と組み合わせ、暗号文を生成する。

ストリーム暗号でこのような擬似ランダム文字列を作ることができなければ、セキュリティのためにメッセージと同じ長さの鍵が必要になる。これはほとんどの場合、あまり現実的な選択肢ではない。

このセクションで説明した擬似ランダム性の概念は、より正式に定義することができる。また、他の文脈にも拡張できる。しかし、ここではその議論を掘り下げる必要はない。暗号技術の大部分において本当に直感的に理解する必要があるのは、ランダム文字列と擬似ランダム文字列の違いだけである。[2]

ランダム」と「一様」の区別をやめて議論する理由も、これで明らかになったはずである。実際には、一様な変数$S$をサンプリングした結果であるかのように見える文字列を示すために、誰もが擬似ランダムという言葉を使っている。厳密に言えば、このような文字列を「擬似一様」と呼ぶべきであり、先ほどの言葉を採用する。擬似一様 "という用語は使いにくいし、誰も使わないので、ここではわかりやすくするために使わない。その代わり、現在の文脈では「ランダム」と「一様」の区別を取り払うことにする。

*注***。

[2] これらの事柄について、より正式な解説に興味があれば、Katz and Lindell's *Introduction to Modern Cryptography*、特に第3章を参照されたい。

# 暗号の数学的基礎2

<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>

## 数論とは何か？

<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>

この章では、暗号の数学的基礎について、より高度なトピックである数論を取り上げる。数論は対称暗号（Rijndael暗号など）にとって重要であるが、公開鍵暗号の設定では特に重要である。

もしあなたが数論の詳細を面倒に感じているなら、最初のうちはハイレベルの読書をお勧めする。後でいつでも戻ってくることができる。

___

整数論**とは、整数と整数を扱う数学関数の性質を研究するものである。

例えば、任意の2つの数$a$と$N$は、それらの最大公約数が1に等しい場合、**共素**（または**相対素**）であると考える。ここで、ある整数 $N$ があるとする。N$より小さい整数で$N$と共約数になるものはいくつあるか。この問いの答えについて一般的なことは言えるだろうか？これらは、数論が答えを求める典型的なタイプの問題である。

現代の整数論は抽象代数学のツールに依存している。抽象代数**分野は、代数的構造として知られる抽象的な対象を主な解析対象とする数学の下位分野である。代数的構造**とは、ある公理を満たす1つ以上の演算と結合した要素の集合である。代数的構造を通して、数学者は特定の数学的問題の詳細を抽象化することで、その問題に対する洞察を得ることができる。

抽象代数学は現代代数学とも呼ばれる。また、**抽象数学**（あるいは**純粋数学**）という概念に出会うこともある。この後者の用語は抽象代数への言及ではなく、潜在的な応用を視野に入れるだけでなく、それ自身のために数学を研究することを意味する。

抽象代数学の集合は、正三角形の形状保存変換から壁紙の模様まで、多くの種類の対象を扱うことができる。整数論の場合は、整数を含む要素の集合か、整数を扱う関数のみを考える。

## グループ

<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

数学の基本概念は要素の集合である。集合は通常、要素をカンマで区切ったアコレード記号で表される。

例えば、すべての整数の集合は${..., -2, -1, 0, 1, 2, ...￢}$である。ここでの楕円は、あるパターンが特定の方向に続くことを意味する。つまり、すべての整数の集合には、 $3, 4, 5, 6$ なども含まれるし、 $-3, -4, -5, -6$ なども含まれる。この全整数の集合は、典型的には $mathbb{Z}$ で表されます。

集合のもう一つの例は$mathbb{Z}である。\mod 11$ である。全集合$mathbb{Z}$とは対照的に、この集合は有限個の要素、すなわち${0, 1, }, 9, 10}$しか含まない。

よくある間違いは、集合$mathbb{Z}が実際には${-10, -9, 0, 9, 10}$であると考えることである。\mod 11$ は実際には ${-10, -9, ̫, 0, ̫, 9, 10}$ であると考えることである。しかし、さっきのモジュロ演算の定義からすると、そうではない。modulo 11で縮小された負の整数は${0, 1, Γ, 9, 10}$にラップされます。例えば、 $-2 \mod 11$ という式は $9$ に回り込み、 $-27 \mod 11$ という式は $5$ に回り込みます。

数学のもう一つの基本概念は二項演算である。2項演算とは、2つの要素を用いて3つ目の要素を生成する演算のことである。例えば、基本的な算数や代数学では、足し算、引き算、掛け算、割り算という4つの基本的な二項演算に馴染みがあるだろう。

この2つの基本的な数学的概念、集合と二項演算は、抽象代数学で最も重要な構造である群の概念を定義するために使われる。

具体的には、ある二項演算$circ$があるとする。さらに、その演算を備えた要素の集合**S**があるとする。ここでいう「備える」とは、集合**S**内の任意の2つの要素の間で$circ$演算ができるということである。



1.a$と$b$が$mathbf{S}$の要素であるとき、$a$は$mathbf{S}$の要素でもある。これは**閉包条件**として知られている。

2.a$、$b$、$c$が$mathbf{S}$の要素であるとき、$(a \circ b) ˶=a ˶(b˶circ c)$となる。これを**結合性条件**という。

3.S}の要素$a$に対して、次の式が成り立つような$e$が$mathbf{S}$に1つだけ存在する。このような要素$e$は1つしかないので、**同一要素**と呼ばれる。この条件を**同一性条件**という。

4.mathbf{S}$の各要素$a$に対して、$mathbf{S}$に次の式が成り立つ要素$b$が存在する。ここでの要素 $b$ は**逆要素** と呼ばれ、一般に $a^{-1}$ と表記される。この条件を**逆条件**または**可逆条件**という。

群についてもう少し調べてみよう。すべての整数の集合を$mathbb{Z}$とする。この集合と標準的な足し算、つまり $langle \mathbb{Z}, + \rangle$ を組み合わせると、上の4つの公理を満たすので、明らかに群の定義に合う。

1.x$と$y$が$mathbb{Z}$の要素であれば、$x + y$も$mathbb{Z}$の要素である。だから、$langle \mathbb{Z}, + \rangle$は閉条件を満たす。

2.x$、$y$、$z$が$mathbb{Z}$の要素であれば、$(x + y) + z = x + (y + z)$である。だから、$langle \mathbb{Z}, + \rangle$は連想条件を満たす。

3.langle \mathbb{Z}, + \rangle$ には、0という恒等式がある：0 + x = x + 0 = x$ が成り立つ。よって、$langle ˶, + ˶rangle$は恒等式条件を満たす。

4.最後に、$mathbb{Z}$の各要素$x$に対して、$x + y = y + x = 0$となる$y$がある。例えば、$x$が10だったら、$y$は$-10$になる（$x$が0の場合、$y$も0になる）。よって、 $langle  \mathbb{Z}, +  \rangle$ は逆条件を満たす。

重要なことは、足し算をする整数の集合が群を構成するということは、掛け算をする群を構成するということを意味しないということである。このことは、$langle  \mathbb{Z}, ˶cdot ˶rangle$ を4つの群公理（ここで、$cdot$は標準乗法を意味する）に照らして検定することで確かめられる。

最初の2つの公理は明らかに成り立つ。さらに、乗算のもとでは、要素1は恒等要素として機能することができる。任意の整数 $x$ に 1 を掛けると、すなわち $x$ が得られる。しかし、$langle  \mathbb{Z}, ˶cdot ˶rangle$は逆条件を満たさない。つまり、$mathbb{Z}$のすべての$x$に対して、$x Γcdot y = 1$となるような一意な要素$y$が$mathbb{Z}$に存在しない。

例えば、$x = 22$とする。このとき、集合 $mathbb{Z}$ から $y$ を取り出して $x$ と掛けると、恒等元 1 になる値は何でしょうか。1/22$という値でもいいのですが、これは集合$mathbb{Z}$の中にはありません。実は、1と-1以外の整数$x$では、この問題にぶつかります（$y$はそれぞれ1と-1でなければならない）。

集合に実数を使えば、問題はほとんどなくなる。集合のどの要素$x$に対しても、$1/x$の掛け算で1が得られる。分数も実数の集合に含まれるので、すべての実数について逆数を求めることができる。ただし、ゼロは例外であり、ゼロとの掛け算で恒等式の要素1が得られることはない。したがって、掛け算を備えたゼロ以外の実数の集合は、まさに群である。

いくつかのグループは、**可換性条件**として知られる5番目の一般的な条件を満たす。この条件は以下の通りである：


- 集合**S**と二項演算子$*circ$を持つ群$G$があるとする。a$と$b$が**S**の要素であるとする。S**の任意の2つの要素$a$と$b$に対して、$a \circ b = b \circ a$となるとき、$G$は可換条件を満たす。

可換条件を満たす群はすべて**可換群**、または**アーベル群**（ニールス・ヘンリック・アーベルにちなむ）として知られている。加算に関する実数の集合と加算に関する整数の集合の両方がアベル群であることを検証するのは簡単である。乗算の整数の集合は群ではないので、アベル群にはならない。これとは対照的に、掛け算の非0実数の集合もアーベル群である。

表記法に関する2つの重要な慣例に留意すべきである。第一に、「+」または「×」という記号は、要素が実際には数でない場合でも、グループ演算を記号化するために頻繁に使用される。このような場合、これらの記号を標準的な算術の足し算や掛け算と解釈してはならない。これらの記号は、算術演算と抽象的に似ているだけの演算である。

特に算術の足し算や掛け算を指すのでなければ、$circ$や$diamond$といった記号をグループ演算に使う方が簡単である。

次に、"+" や "×" が算術演算以外の演算を表すのによく使われるのと同じ理由で、群の同一要素は、これらの群の要素が数でない場合でも、"0" や "1" で記号化されることがよくある。数を持つ群の恒等要素を指しているのでない限り、恒等要素を示すには「$e$」のような中立的な記号を使う方が簡単である。

数学において、ある種の二項演算を備えた多くの異なる非常に重要な値の集合が群である。しかし暗号アプリケーションは、整数または少なくとも整数で記述される要素からなる集合、つまり整数論の領域内でしか動作しない。したがって、整数以外の実数を持つ集合は暗号の応用には用いられない。

最後に、整数でないにもかかわらず「整数で記述できる」要素の例を挙げよう。良い例は楕円曲線の点である。楕円曲線上の任意の点は明らかに整数ではないが、そのような点は確かに2つの整数によって記述される。

例えば、楕円曲線はビットコインにとって極めて重要である。標準的なビットコインの秘密鍵と公開鍵のペアは、次の楕円曲線で定義される点の集合から選択される：

$$
x^3 + 7 = y^2 \mod 2^{256} – 2^{32} – 29 – 28 – 27 – 26 - 24 - 1
$$

($2^{256}$より小さい最大の素数)。x$座標が秘密鍵、$y$座標があなたの公開鍵となる。

ビットコインの取引は通常、何らかの方法で1つ以上の公開鍵に出力をロックする。そして、これらのトランザクションからの値は、対応する秘密鍵でデジタル署名を行うことでロックを解除することができる。

## 環状グループ

<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

大きな違いは、**無限**群と**無限群**である。前者は有限個の要素を持ち、後者は無限個の要素を持つ。有限群の要素数は群の**次数**として知られている。群の使用を伴う実用的な暗号はすべて有限（数論的）群に依存している。

公開鍵暗号では、ある種の有限アベル群として知られる環状群が特に重要である。巡回群を理解するためには、まず群要素の指数化の概念を理解する必要がある。

群演算 $circ$ を持つ群 $G$ があり、 $a$ が $G$ の要素であるとする。このとき、 $a^n$ という式は、 $a$ という要素を自分自身と合計 $n - 1$ 回組み合わせたものと解釈する。例えば、 $a^2$ は $a \circ a$ 、 $a^3$ は $a \circ a$ などである。(ここでの指数化は必ずしも標準的な算術的な意味での指数化ではないことに注意)。

例を挙げよう。G = ゙langle ゙mathbb{Z} とします。\mod 7, + \rangle$ とし、 $a$ の値を 4 とします。このとき、 $a^2 = [4 + 4 ゙mod 7] = [8 ゙mod 7] = 1 ゙mod 7$ となる。あるいは、 $a^4$ は $[4 + 4 + 4 + 4 ゙mod 7] = [16 ゙mod 7] = 2 ゙mod 7$ を表します。

いくつかのアベル群には、累乗によって他のすべての群要素を得ることができる1つ以上の要素がある。これらの要素は**生成要素**または**原始要素**と呼ばれる。

このような群の重要なクラスは$langle \mathbb{Z}^* ゙mod N, ゙cdot ゙rangle$であり、$N$は素数である。ここでの$mathbb{Z}^*$という表記は、この群が$N$より小さい0でない正の整数をすべて含むという意味である。したがって、このような群は常に $N - 1$ 個の要素を持つ。

例えば、$G = ゙mathbb{Z}^* ゙mod 11, ゙cdot ゙rangle$を考えます。この群には次の要素がある：$\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}$.この群の次数は10である（これは確かに$11 - 1$に等しい）。

この群から要素2を指数化することを調べてみよう。$2^{12}$ までの計算を以下に示す。式の左辺で、指数が群要素の指数化を指していることに注意。この例では、式の右辺で算術指数を使うことになる（しかし、例えば足し算を使うこともできる）。明確にするために、私は右辺の指数形式ではなく、繰り返し演算を書き出した。


- $2^1 = 2 ゙mod 11$.
- $2^2 = 2 ゙cdot 2 ゙mod 11 = 4 ゙mod 11$.
- $2^3 = 2 ⊖cdot 2 ⊖cdot 2 ⊖cdot 11 = 8 ⊖cdot 11$.
- $2^4 = 2 ╱11 = 16 ╱11 = 5 ╱11$ である。
- $2^5 = 2 ╱11 = 32 ╱11 = 10 ╱11$ である。
- $2^6 = 2 ╱11 = 64 ╱11 = 9 ╱11$ である。
- $2^7 ＝ 2 ╱11 ╱128 ╱11 ＝ 7 ╱11$ である。
- $2^8 = 2 ┣11 = 256 ┣11 = 3 ┣11$ である。
- $2^9 = 2 ╱11 = 512 ╱11 = 6 ╱11$ である。
- $2^{10} = 2 ╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱$1
- $2^{11} = 2 ゙モッド11 = 2048 ゙モッド11 = 2 ゙モッド11$である。
- 

2,4,8,5,10,9,7,3,6,1。$2^{10}$の後、要素2の累乗を続けると、また同じ順序ですべての要素を循環する。よって、要素2は$langle ↪Mathbb{Z}^* ↪Mod 11, ゙cdot ↪Mathbb{Z}^* ↪Mod 11, ゙rangle$の生成子である。

例えば、要素3を考えてみよう。面倒な計算を見せずに最初の10個の指数化を実行すると、次のような結果が得られる：


- 3^1 = 3 ゙mod 11$.
- 3^2 = 9 ♪mod 11$
- 3^3 = 5 ♪mod 11$
- 3^4 = 4 ゙モッド 11$.
- 3^5 = 1 ゙モッド 11$.
- 3^6 = 3 ゙mod 11$.
- 3^7 = 9 ♪mod 11$
- 3^8 = 5 ゙mod 11$.
- 3^9 = 4 ゙mod 11$.
- 3^{10} = 1 ゙モッド 11$.

3、9、5、4、1。5回目の指数化以降、これらの値は繰り返され始める。

ここで**巡回群**を、少なくとも1つの生成子を持つ群として定義することができる。つまり、少なくとも1つの群要素があり、そこから他のすべての群要素をべき乗によって生成することができる。

上の例で、$2^{10}$も$3^{10}$も$1 \mod 11$に等しいことに気づいたかもしれない。なぜそうなるのか？

これは重要な質問だが、答えるには少し手間がかかる。

まず、2つの正の整数 $a$ と $N$ を考える。数論で重要な定理は、$a$と$N$の最大公約数が1に等しい場合に限り、$a$は$N$に対して乗法的な逆数を持つ（つまり、$a Γcdot b = 1 Γcdot N$となるような整数$b$を持つ）というものである。つまり、$a$と$N$が共素数のときである。

つまり、$N$の乗法を持つ整数群に対しては、$N$の小さい共素数のみが集合に含まれる。この集合を $mathbb{Z}^c \mod N$ と表すことができる。

例えば、$N$が10だとする。10と共素数の整数は1,3,7,9だけである。だから、集合 $mathbb{Z}^c \mod 10$ には ${1, 3, 7, 9}$ しか含まれない。1から10までの他の整数を使って、10の整数乗法を持つ群を作ることはできない。この特別な群では、逆数は1と9、3と7の組である。

N$ 自体が素数の場合、1から $N - 1$ までの整数はすべて $N$ と共素数である。したがって、このような群は $N - 1$ の位数を持つ。先ほどの表記法を使えば、$N$ が素数のとき、$mathbb{Z}^c  \mod N$ は $mathbb{Z}^*  \mod N$ に等しい。先ほどの例で選んだ群、$langle  \mathbb{Z}^*  \mod 11, ˶cdot ˶rangle$は、このクラスの特定の例である。

次に、ある数$N$までの共素数の数を計算する関数$phi(N)$は、**オイラーのファイ関数**として知られている。[1] **オイラーの定理**によれば、2つの整数$a$と$N$が共素数であるとき、必ず次が成り立つ：


- a^{phi(N)}  \mod N = 1 Γmod N$.

このことは、$N$が素数の群$langle ↪Mathbb{Z}^* ↪Mod N, ゙cdot ↪Mathbb{Z}^* ↪Mod N, ゙rangle$のクラスにとって重要な意味を持つ。これらの群では、群要素の指数化は算術指数化を表す。すなわち、$a^{{phi(N)} \mod N$は算術演算$a^{{phi(N)} \mod N$を表す。これらの乗法群の任意の要素 $a$ は $N$ と共次なので、$a^{{Nphi(N)} \mod N = a^{N - 1} となる。\となる。

オイラーの定理は実に重要な結果である。langleの場合、各要素は2,5,10個の要素を循環することしかできません。どの要素も累乗時に循環するグループ値は、要素の**次数**として知られています。ある群の次数と等価な次数を持つ要素は生成子である。

さらに、オイラーの定理は、$a^{N - 1} の結果を常に知ることができることを意味している。これは実際の計算がいかに複雑であろうと同じである。

例えば、我々の群が$mathbb{Z}^* \mod 160,481,182$（ここで160,481,182は確かに素数）だとする。1から160,481,181までの整数はすべてこの群の要素でなければならず、$phi(n) = 160,481,181$であることがわかる。すべての計算はできないが、$514^{160,481,181}$、$2,005^{160,481,181}$、$256,212^{160,481,181}$のような式はすべて$1 ̫mod 160,481,182$と評価されることがわかる。

**注：**。

[1] この関数は次のように働く。任意の整数 $N$ は素数の積に因数分解できる。ある $N$ が次のように因数分解されたとする：p_1^{e1}\p_cdot p_2^{e2}\ここで、$p$はすべて素数、$e$はすべて1以上の整数である：

$$
\phi(N) = \sum_{i=1}^m \left[p_i^{e_i} - p_i^{e_i - 1}\right]
$$

N$の素因数分解に対するオイラーのPhi関数公式。

## フィールド

<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

群は抽象代数学における基本的な代数構造であるが、それ以外にも多くの代数構造がある。唯一知っておく必要があるのは、**体**の代数構造、特に**無限体**の代数構造である。この種の代数構造は、Advanced Encryption Standardのような暗号技術でよく使われる。後者は実際に遭遇する主な対称暗号化方式である。

場(field)は群(group)の概念から派生したものである。具体的には、**場**は、$circ$と$diamond$の2つの二項演算子を持つ要素集合**S**であり、以下の条件を満たす：

1.S**が$circ$を持つ集合はアベル群である。

2.diamond$を持つ集合**S**は、"0でない "要素に対してアベル群である。

3.この2つの演算子を備えた集合**S**は、分配条件と呼ばれるものを満たす：a$、$b$、$c$が**S**の要素であるとする。a$、$b$、$c$が**S**の要素であるとすると、この2つの作用素を持つ**S**は、$a \circ(b ˶c)=(a ˶circ b)˶circ(a˶circ c)$のとき、分配条件を満たす。

群と同様、場の定義は非常に抽象的であることに注意。S**の要素の型や、$circ$と$diamond$の操作については何も主張しない。ただ、上の3つの条件が成り立つ2つの演算を持つ要素の集合が場であると述べているだけである。(第2アーベル群の「ゼロ」要素は抽象的に解釈できる）。

では、フィールドの例とは何だろう？良い例は、集合 $mathbb{Z} である。\つまり、標準加法（上の$circ$の代わり）と標準乗法（上の$diamond$の代わり）で定義される${0, 1, }, 7}$である。

まず、$mathbb{Z}。\mod 7$ は、足し算上のアベル群である条件を満たし、0でない要素だけを考えれば、掛け算上のアベル群である条件を満たす。次に、集合と2つの作用素の組み合わせは分配条件を満たす。

ある特定の値を用いてこれらの主張を探求することは、教育的に価値がある。集合 $mathbb{Z} からランダムに選ばれた要素である実験値5, 2, 3 を使ってみよう。\を調べるために、実験値5, 2, 3$ を使ってみよう。\mod 7, +, ゙cdot ゙rangle$を調べる。この3つの値を必要に応じて順番に使って、特定の条件を調べる。

まず、足し算を備えた$mathbb{Z}がアベリアン群かどうかを調べてみよう。\足し算を備えた $mathmod 7$ がアベル群かどうかをまず調べてみよう。

1. **クローズ条件**：5と2を値としよう。この場合、$[5 + 2] ゙mod 7 = 7 ゙mod 7 = 0$となる。これは確かに$mathbb{Z}の要素です。\この結果は閉包条件と一致します。

2. **結合条件**：5、2、3を値として考えます。この場合、[(5+2)+3] ゙mod 7 = [5+(2+3)] ゙mod 7 = 10 ゙mod 7 = 3$ となります。これは連想条件と一致する。

3. **識別条件**：5を値とする。この場合、$[5 + 0] ゙mod 7 = [0 + 5] ゙mod 7 = 5$となります。つまり、0は足し算の恒等式になる。

4. **逆条件**：5 の逆数を考えよう。ある$d$の値に対して、$[5 + d]  \mod 7 = 0$となる必要がある。このとき、この条件を満たす$mathbb{Z}のユニークな値は$mathbb{Z}である。\この条件を満たす $mathmod 7$ の一意な値は 2 である。

5. **可換条件**：5と3を値としよう。この場合、$[5 + 3] ゙mod 7 = [3 + 5] ゙mod 7 = 1$となります。これは可換条件と一致します。

足し算を備えた集合$mathbb{Z}は明らかにアベル群である。\mod 7$ は明らかにアベル群である。では、$mathbb{Z} \mod 7$の乗法がアベル群かどうかを調べてみよう。\mathmod 7$ が0でないすべての要素に対してアベル群かどうかを調べてみよう。

1. **クローズ条件**：5と2を値とする。このとき、$[5 \cdot 2] ˶=10˶=3$ となります。これも$mathbb{Z}の要素です。\mod 7$ の要素でもあるので、この結果は閉包条件と一致する。

2. **連想条件**：5、2、3を値とする。この場合、$[(5 ㏄ 2) ㏄ 3] ㏄ 7 = [5 ㏄ (2 ㏄ 3)] ㏄ 7 = 30 ㏄ 7 = 2$となります。これは連想条件と一致する。

3. **識別条件**：を5とします。この場合、$[5  \cdot 1] ˶=[1 ˶=5] ˶=5$ となります。ということで、1が乗算の恒等式になるようです。

4. **逆条件**：5 の逆数を考えよう。ある $d$ の値に対して $[5 \cdot d] ˶=1$ となる必要がある。この条件を満たす$mathbb{Z}のユニークな値は$mathbb{Z}である。\この条件を満たす $mathmbb{Z} 7$ のユニークな値は 3 である。

5. **可換条件**：5と3を値とする。この場合、$[5 ㏄ 3] ㏄ 7 = [3 ㏄ 5] ㏄ 7 = 15 ㏄ 7 = 1$となります。これは可換条件と一致する。

集合 $mathbb{Z｝\mod 7$ は、ゼロでない要素上の足し算か掛け算を組み合わせると、明らかにアベル群になる規則を満たすようである。

最後に、両演算子を組み合わせたこの集合は、分配条件を満たしているように見える。5、2、3を値としましょう。5 \cdot (2 + 3)] ˶mod 7 = [5 ˶mod 2 + 5 ˶mod 3] ˶mod 7 = 25 ˶mod 7 = 4$ であることがわかります。

これで、足し算と掛け算を備えた $mathbb{Z｝\足し算と掛け算を備えた $mathmod 7$ は、特定の値でテストするとき、有限体の公理を満たすことがわかった。もちろん、一般的に示すこともできるが、ここでは省略する。

重要なのは、2種類の場、すなわち有限場と無限場の区別である。

無限体**とは、集合**S**が無限に大きい場のことである。足し算と掛け算を備えた実数の集合$mathbb{R}$は無限場の例である。無限体**は、**ガロア体**とも呼ばれ、集合**S**が有限である体である。上の$langle  \mathbb{Z} の例。\の例は有限体である。

暗号学では、主に有限体（finite field）に興味がある。ここで$p$は素数、$m$は1以上の正の整数である。つまり、ある集合**S**の次数が素数（$p^m$で$m=1$）か素乗（$p^m$で$m>1$）であれば、場の条件を満たすような2つの演算子$circ$と$diamond$を見つけることができる。

ある有限体が素数の要素を持つ場合、それは**素体**と呼ばれる。有限体の要素数が素数乗である場合、その場は**拡張体**と呼ばれる。暗号学では、素数場と拡張場の両方に興味がある。[2]

暗号学で注目される主な素数場は、すべての整数の集合がある素数によって変調され、演算子が標準的な加算と乗算であるものである。この有限体には$mathbb{Z}, $mathbb{Z}, $mathbb{Z}, $mathbb{Z}, $mathbb{Z\mod 2$, $mathbb{Z}\mod_3$, $mathbb{Z}\mod 5$, $mathbb{Z} 7$, $mathbb{Z} 7$, $mathbb{Z} 7$ がある。\mod_7$, $mathbb{Z}\mod_od 11$, $mathbb{Z}\mod 13$, and so on.任意の素体$mathbb{Z}に対して\mod p$のとき、その場の整数の集合は次のようになる：0, 1, p - 2, p - 1}$ である。

暗号学では、拡張体、特に$2^m$個の要素を持ち、$m>1$である場にも興味がある。このような有限体は、例えば、Advanced Encryption Standardの基礎をなすRijndael暗号で使われている。素数場は比較的直感的に理解できるが、このような基底2拡張場は、抽象代数に不慣れな人にとってはおそらく理解できないだろう。

まず始めに、$2^m$個の要素を持つ整数の集合には、（m$が正の整数である限り）その組合せを場にする2つの演算子を割り当てることができるのは確かである。しかし、場が存在するからといって、それが発見しやすいとは限らないし、ある応用にとって特に実用的であるとも限らない。

結局のところ、暗号学において$2^m$の拡張体として特に適用できるのは、整数の集合ではなく、多項式式の特定の集合上で定義されるものである。

例えば、$2^3$ (つまり8)の要素を持つ拡張体が欲しいとする。そのサイズの場に使える集合はいろいろあるかもしれないが、そのような集合の1つは、各係数 $a_i$ が0か1である $a_2x^2 + a_1x + a_0$ の形の一意多項式をすべて含む。したがって、この集合**S**は次の要素を含む：

1. $0$:a_2 = 0$, $a_1 = 0$, $a_0 = 0$ の場合。

2. $1$:a_2 = 0$, $a_1 = 0$, $a_0 = 1$ の場合。

3. $x$:a_2 = 0$, $a_1 = 1$, $a_0 = 0$ の場合。

4.$x + 1$:a_2 = 0$, $a_1 = 1$, $a_0 = 1$ の場合。

5.$x^2$:a_2 = 1$, $a_1 = 0$, $a_0 = 0$ の場合。

6.$x^2 + 1$:a_2 = 1$, $a_1 = 0$, $a_0 = 1$ の場合。

7.x^2 + x$である：a_2 = 1$, $a_1 = 1$, $a_0 = 0$ の場合。

8.x^2 + x + 1$ である：a_2 = 1$, $a_1 = 1$, $a_0 = 1$ の場合。

つまり、**S**は集合${0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1}$となる。この要素の集合に対して、それらの組み合わせが場であることを保証するために定義できる2つの操作は何か。

集合**S** ($circ$)に対する最初の操作は、標準的な多項式のモジュロ2の加算として定義できる。通常のように多項式を加算し、得られた多項式の各係数にモジュロ2を適用するだけである。以下はその例です：


- (x^2)＋(x^2＋x＋1)]゙モッド2＝[2x^2＋x＋1]゙モッド2＝x＋1$。
- (x^2 + x) + (x)] ゙mod 2 = [x^2 + 2x] ゙mod 2 = x^2$.
- $[(x + 1) + (x^2 + x + 1)] ゙mod 2 = [x^2 + 2x + 2] ゙mod 2 = x^2 + 1$.

フィールドの作成に必要な集合**S**（$diamond$）に対する2つ目の操作は、より複雑である。これは一種の掛け算だが、算術の標準的な掛け算ではない。その代わりに、各要素をベクトルとしてとらえ、その演算を、既約多項式をモジュロとする2つのベクトルの乗算として理解しなければならない。

まず、既約多項式について説明しよう。既約多項式**とは因数分解できない多項式のことである（素数が1と素数そのもの以外の要素に因数分解できないのと同じである）。我々の目的では，すべての整数の集合に関して既約多項式に興味がある．(ある多項式を整数で因数分解できなくても、例えば実数や複素数で因数分解できるかもしれないことに注意しよう)。

例えば、多項式 $x^2 - 3x + 2$ を考えてみよう。これは $(x - 1)(x - 2)$ と書き換えることができる。よって、これは既約ではありません。次に、多項式 $x^2 + 1$ を考えてみましょう。整数だけを使って、この式をさらに因数分解する方法はありません。よって、これは整数に関して既約多項式である。

次に、ベクトルの掛け算について説明しよう。このトピックを深く掘り下げることはしないが、基本的なルールだけは理解しておく必要がある：配当の次数が被除数の次数以上であれば、どのようなベクトルの除算も可能です。もし配当が被除数より次数が低ければ、配当はもはや被除数で割ることはできない。

例えば、 $x^6 + x + 1 \mod x^5 + x^2$ という式を考えてみましょう。次に、 $x^5 + x + 1 Γmod x^5 + x^2$ という式を考えてみましょう。これも、配当の次数5と除数の次数5が等しいので、さらに減ります。

しかし、ここで $x^4 + x + 1 ゙mod x^5 + x^2$ という式を考えてみましょう。配当の次数 4 は被除数の次数 5 より低いので、これ以上減らない。

この情報を基に、集合${0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1}$に対する2番目の演算を求める準備ができた。

私はすでに、2番目の演算はある既約多項式をモジュロとするベクトルの乗算として理解されるべきであると述べた。この既約多項式は、2番目の演算が**S**上のアーベル群を定義し、分配条件と矛盾しないことを保証しなければならない。では、その既約多項式とは何だろうか？

集合内のすべてのベクトルは次数2以下であるから、既約多項式は次数3でなければならない。集合内の2つのベクトルの乗算が次数3以上の多項式をもたらすなら、次数3の多項式のモジュロは常に次数2以下の多項式をもたらすことがわかる。これは、次数3以上の多項式は必ず次数3の多項式で割り切れるからである。

次数3の既約多項式には、除数として使えるものがいくつかあることがわかった。これらの多項式はそれぞれ、集合**S**と加算モジュロ2と組み合わせて異なる場を定義する。つまり、暗号で拡張体$2^m$を使う場合、複数の選択肢があるということだ。

この例題では、多項式 $x^3 + x + 1$ を選ぶとします。整数を使って因数分解できないので、これは確かに既約物である。また、2つの要素の掛け算は、必ず次数2以下の多項式になります。

多項式 $x^3 + x + 1$ を除数として、2つ目の操作の例題を解いてみましょう。集合 **S** の要素 $x^2 + 1$ と $x^2 + x$ を掛け合わせるとします。このとき、式 $[(x^2 + 1) ╱ (x^2 + x)] ╱mod x^3 + x + 1$ を計算する必要があります。これは次のように簡略化できる：


- (x^2+1)◆cdot(x^2+x)]◆mod x^3 + x + 1 =$.
- x^2 ㎤ x^2 + x^2 ㎤ x + 1 ㎤ x^2 + 1 ㎤ x] ㎤ x^3 + x + 1 =$.
- x^4 + x^3 + x^2 + x]  \mod x^3 + x + 1$.

x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$ は、配当が被除数(3)よりも次数(4)が高いので、小さくできることがわかる。

まず、 $x^3 + x + 1$ という式は、 $x^4 + x^3 + x^2 + x$ に合計 $x$ 回入ることがわかります。これを確かめるには、 $x^3 + x + 1$ に $x$ をかければよく、 $x^4 + x^2 + x$ となります。後項は配当と同じ次数、つまり4なので、これが成り立つことがわかります。この $x$ で割った余りは、次のように計算できます：


- (x^4+x^3+x^2+x)-(x^4+x^2+x)]♪mod x^3 + x + 1 =$.
- x^3] ゙モッド x^3 + x + 1 =$.
- $x^3$

つまり、 $x^4 + x^3 + x^2 + x$ を $x^3 + x + 1$ で合計 $x$ 回割ると、 $x^3$ の余りができる。これをさらに $x^3 + x + 1$ で割ることができるか。

直感的には、 $x^3$ はもはや $x^3 + x + 1$ で割り切れないと言った方が、後者の項が大きく見えて魅力的かもしれません。しかし、先ほどのベクトルの割り算の話を思い出してください。配当が除数と同じかそれ以上の次数であれば、式はさらに小さくすることができます。具体的には、 $x^3 + x + 1$ という式は、 $x^3$ にちょうど1回入ることができます。余りは次のように計算します：

$$
[(x^3) - (x^3 + x + 1)] \mod x^3 + x + 1 = [x + 1] \mod x^3 + x + 1 = x + 1
$$

なぜ $(x^3) - (x^3 + x + 1)$ は $x - 1$ ではなく $x + 1$ と評価されるのか不思議に思うかもしれない。この場の最初の演算は、2のモジュロで定義されていることを思い出してください。したがって、2つのベクトルの引き算は、2つのベクトルの足し算とまったく同じ結果になります。

x^2 + 1$ と $x^2 + x$ の掛け算をまとめる：この2項を掛け合わせると、 $x^4 + x^3 + x^2 + x$ という次数4の多項式になり、 $x^3 + x + 1$ を減じる必要がある。次多項式は $x^3 + x + 1$ でちょうど $x + 1$ 回割り切れる。x^4 + x^3 + x^2 + x$ を $x^3 + x + 1$ でちょうど $x + 1$ 回割った余りは $x + 1$ である。これは、集合 $0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1}$ の要素である。

上の例のような多項式の集合を底2とする拡張体が、なぜ暗号に有用なのだろうか。その理由は、このような集合の多項式の係数（0か1）を、特定の長さを持つ2進文字列の要素として見ることができるからだ。例えば上の例の集合**S**は、代わりに長さ3（000から111）のすべての2進文字列を含む集合**S**と見なすことができる。そして、**S**に対する演算は、これらのバイナリ文字列に対して演算を実行し、同じ長さのバイナリ文字列を生成するために使用することもできる。

**注：**。

[2] 拡張体は非常に直感に反するものとなる。整数の要素を持つ代わりに、多項式の集合を持つ。さらに、どのような演算も、ある既約多項式をモジュロして実行される。

## 抽象代数の実践

<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>

形式的な表現と抽象的な議論にもかかわらず、グループの概念を理解することはそれほど難しくないはずだ。群とは、二項演算を伴う要素の集合に過ぎず、それらの要素に対する二項演算の実行は4つの一般的な条件を満たす。アーベル群には、可換性という追加の条件がある。環状群は特殊なアーベル群であり、生成子を持つ群である。場は、基本的な群の概念をより複雑にしたものに過ぎない。

しかし、もしあなたが実務志向の人なら、この時点で疑問に思うかもしれない：どうでもいいじゃないか。ある演算子を持つ要素の集合が群であること、あるいはアーベル群や環状群であることを知ったところで、実世界に何か関係があるのだろうか？何かが場であることを知っていることが、現実の世界と関係があるのだろうか？

詳細は省くが、答えは「イエス」である。群は19世紀、フランスの数学者エヴァリスト・ガロワによって初めて作られた。彼はこれを用いて、5次以上の多項式を解くための結論を導き出した。

それ以来、群という概念は、数学やその他の分野における数多くの問題に光を当てるのに役立ってきた。例えば、物理学者のマレー＝ゲルマンは、群論に基づいて、実験で実際に観測される前に粒子の存在を予測することができた。[別の例では、化学者は分子の形を分類するために群論を使う。数学者は、壁紙のような具体的なものについて結論を導き出すために、群という概念さえ使ってきた！

基本的に、ある演算子を持つ要素の集合が群であることを示すということは、あなたが記述しているものが特定の対称性を持つことを意味する。一般的な意味での対称性ではなく、より抽象的な形である。そしてこれは、特定のシステムや問題に対する実質的な洞察を提供することができる。抽象代数から得られるより複雑な概念は、私たちに付加的な情報を与えてくれるに過ぎない。

最も重要なことは、暗号、特に公開鍵暗号への応用を通して、数論的な群や場の重要性を実際に理解することである。例えば、Rijndael暗号で拡張体がどのように使われているかは、既に場の議論で見た通りである。その例については、*第5章*で説明する。

抽象代数に関する更なる議論には、Socraticaによる抽象代数に関する素晴らしいビデオ・シリーズをお勧めする。[4]特にお勧めしたいのは以下のビデオである：「抽象代数とは何か」、「群の定義（拡張）」、「環の定義（拡張）」、「場の定義（拡張）」。これらの4つのビデオは、上記の議論の多くについて、さらに深い洞察を与えてくれるだろう。(環については説明しなかったが、場は環の特殊な型に過ぎない)。

現代数論についてのさらなる議論は、暗号技術に関する多くの高度な議論を参考にすることができる。Jonathan KatzとYehuda Lindellの『Introduction to Modern Cryptography』や、Christof PaarとJan Pelzlの『Understanding Cryptography』などが、より詳しい議論に役立つでしょう。[5]

**注：**。

[3] [YouTube動画](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be)を参照。

[4] ソクラテス、[抽象代数](https://www.socratica.com/subject/abstract-algebra)

[5] Katz and Lindell, *Introduction to Modern Cryptography*, 2nd edn, 2015 (CRC Press: Boca Raton, FL).Paar and Pelzl, *Understanding Cryptography*, 2010 (Springer-Verlag: Berlin).

# 対称暗号

<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

## アリスとボブ

<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

暗号の2大分野の1つが対称暗号である。対称暗号には、暗号化方式だけでなく、認証や完全性に関する方式も含まれる。1970年代までは、暗号技術のすべてが対称暗号方式で構成されていた。

主な議論は、まず対称暗号化方式を概観し、ストリーム暗号とブロック暗号を決定的に区別することから始まる。次に、メッセージの完全性と真正性を保証するための方式であるメッセージ認証符号について説明する。最後に、安全な通信を保証するために、対称暗号方式とメッセージ認証符号をどのように組み合わせることができるかを探る。

この章では、実際に使われている様々な対称暗号方式について一通り説明する。次の章では、ストリーム暗号とブロック暗号、それぞれRC4とAESを用いた暗号化について、実践から詳しく解説する。

対称暗号の議論を始める前に、この章以降のアリスとボブのイラストについて簡単に述べておきたい。

___

暗号の原理を説明する際、人々はしばしばアリスとボブの例に頼る。私もそうするつもりだ。

特に暗号の初心者であれば、これらのアリスとボブの例は、単純化された環境における暗号の原理と構造を説明するためのものでしかないことを理解することが重要である。しかし、この原理と構造は、もっと広い現実の文脈に適用できるものである。

以下は、暗号におけるアリスとボブの例について留意すべき5つのポイントである：

1.これらは、企業や政府組織など、他のタイプのアクターの例にも容易に置き換えられる。

2.3人以上の俳優を加えることも簡単にできる。

3.この例では、ボブとアリスは通常、各メッセージの作成とそのメッセージへの暗号スキームの適用に積極的に参加している。しかし実際には、電子通信はほとんど自動化されている。例えば、トランスポート・レイヤー・セキュリティを使用したウェブサイトにアクセスする場合、暗号は通常、すべてあなたのコンピュータとウェブサーバーによって処理される。

4.電子通信の文脈では、通信チャネルを介して送信される「メッセージ」は通常TCP/IPパケットである。これらは、電子メール、フェイスブックのメッセージ、電話での会話、ファイル転送、ウェブサイト、ソフトウェアのアップロードなどに属する。これらは伝統的な意味でのメッセージではない。とはいえ、暗号化技術者はしばしばこの現実を単純化し、メッセージは例えば電子メールであると表現する。

5.この例では通常、電子的なコミュニケーションに焦点を当てているが、手紙のような伝統的なコミュニケーション形式にも拡張することができる。

## 対称暗号方式

<chapterId>41bfdbe1-6d41-5272-98bb-81f24b2fd6af</chapterId>

非対称暗号方式**とは、3つのアルゴリズムを持つ暗号方式と大雑把に定義できる：

1.秘密鍵を生成する**鍵生成アルゴリズム**。

2.秘密鍵と平文を入力とし、暗号文を出力する**暗号化アルゴリズム**。

3.秘密鍵と暗号文を入力とし、元の平文を出力する**復号アルゴリズム**。

通常、暗号化スキームは、対称型であれ非対称型であれ、厳密な仕様ではなく、コア・アルゴリズムに基づく暗号化のテンプレートを提供する。

例えば、対称暗号方式であるSalsa20を考えてみよう。鍵長は128ビットでも256ビットでも使用できる。鍵長の選択は、アルゴリズムの細かい部分（正確にはアルゴリズムのラウンド数）に影響する。

しかし、128ビットの鍵でSalsa20を使うのと、256ビットの鍵でSalsa20を使うのとでは、暗号化方式が違うとは言えないだろう。核となるアルゴリズムは変わらないからだ。コアとなるアルゴリズムが変わって初めて、2つの異なる暗号化方式と言えるのだ。

(1)2つ以上のエージェントが離れたところから通信しており、その通信内容を秘密にしたい場合、(2)1つのエージェントが時間を超えてメッセージの内容を秘密にしたい場合、である。

下の*図1*に状況(1)の描写がある。ボブは距離の離れたアリスにメッセージ$M$を送りたいが、他人にそのメッセージを読まれたくない。

ボブはまず、メッセージ$M$を秘密鍵$K$で暗号化する。そして、暗号文 $C$ をアリスに送る。アリスは暗号文を受け取ると、鍵 $K$ を使って復号し、平文を読むことができる。優れた暗号化方式であれば、暗号文$C$を傍受した攻撃者は、メッセージ$M$について本当に重要なことは何も知ることができないはずである。

下の*図2*に状況(2)の描写がある。ボブはある情報を他人に見られないようにしたい。典型的な状況は、ボブが自分のコンピューターに機密データを保存している従業員で、部外者や同僚はそのデータを読むことができないようになっているというものだ。

ボブは時刻$T_0$にメッセージ$M$を鍵$K$で暗号化し、暗号文$C$を生成する。時刻$T_1$に再びメッセージが必要になり、鍵$K$で暗号文$C$を復号する。その間に暗号文$C$に出くわしたかもしれない攻撃者は、そこから$M$に関する重要なことを推測できないはずである。

*図1：空間を超えた秘密主義

![Figure 1: Secrecy across space](assets/Figure4-1.webp "Figure 1: Secrecy across space")

*図2：時系列を超えた秘密性

![Figure 2: Secrecy across time](assets/Figure4-2.webp "Figure 2: Secrecy across time")

## 例シフト暗号

<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

第2章では、非常に単純な対称暗号化方式の一例であるシフト暗号に出会った。ここでもう一度見てみよう。

英語のアルファベットをすべて順番に数字の集合${0,1,2,}$と等しくした辞書*D*があるとする。可能なメッセージの集合**M**を仮定する。シフト暗号は次のように定義される暗号化方式である：


- K** = $*K**, **K** = ${0,1,2,∕dots,25}$ のとき、取り得るキーの集合**K** からランダムにキー$k$を選択する。
- メッセージ$mを以下のように暗号化する：
    - m$をそれぞれの文字に分ける $m_0, m_1, ㎤, m_i, ㎤, m_l$.
    - 各 $m_i$ を *D* に従って数値に変換する。
    - 各 $m_i$ に対して、 $c_i = [(m_i + k)  \mod 26]$ である。
    - 各$c_i$を*D*に従って文字に変換する。
    - 次に$c_0,c_1,dots,c_l$を組み合わせて暗号文$c$を得る。
- 暗号文$c$を以下のように復号する：
    - 各 $c_i$ を *D* に従って数値に変換する。
    - 各$c_i$について、$m_i = [(c_i - k) ˶mod 26]$.
    - 各 $m_i$ を *D* に従って文字に変換する。
    - 次に、$m_0,m_1,m_l$を組み合わせて、元のメッセージ$m$を得る。

シフト暗号が対称暗号方式であるのは、暗号化と復号化の両方のプロセスで同じ鍵が使われるからだ。例えば、「DOG」というメッセージをシフト暗号を使って暗号化したいとし、鍵として「24」をランダムに選んだとする。この鍵でメッセージを暗号化すると、"BME "が得られる。元のメッセージを取り出す唯一の方法は、同じ鍵 "24 "を使って復号化することである。

このShift暗号は**モノアルファベット置換暗号**の一例であり、暗号文のアルファベットが固定されている（つまり1つのアルファベットだけが使われる）暗号化スキームである。復号アルゴリズムが決定論的であると仮定すると、置換暗号文に含まれる各シンボルは、平文中の最大でも1つのシンボルに関連することができる。

1700年代まで、暗号化の多くの応用は単アルファベット置換暗号に大きく依存していたが、しばしばこれらはシフト暗号よりもはるかに複雑だった。例えば、各文字が暗号文のアルファベットで一度しか出現しないという制約の下で、元のテキストの各文字をアルファベットからランダムに選ぶことができる。これは、コンピュータがなかった時代には巨大なものだった。

暗号の世界では、**暗号**という言葉をよく目にする。この用語にはさまざまな意味があることに注意してほしい。実際、私が知っている暗号用語には少なくとも5つの異なる意味がある。

シフト暗号やモノアルファベット置換暗号のように、暗号化方式を指す場合もある。しかし、この用語は暗号化アルゴリズムや秘密鍵、あるいはそのような暗号化方式の暗号文だけを指すこともある。

最後に、暗号という用語は、暗号方式を構築するための核となるアルゴリズムを指すこともある。これには様々な暗号化アルゴリズムだけでなく、他のタイプの暗号スキームも含まれる。この用語の意味は、ブロック暗号の文脈で意味を持つようになる（以下の「ブロック暗号」のセクションを参照）。

また、**暗号化**や**復号化**という言葉を目にすることもあるだろう。これらの用語は暗号化と復号化の同義語に過ぎません。

## ブルートフォース攻撃とケルッコフの原理

<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

シフト暗号は、少なくとも現代においては非常に安全性の低い対称暗号方式である。[1] 攻撃者は、26個の可能な鍵すべてを使って暗号文の復号を試み、どの結果が意味を持つかを確認することができる。この種の攻撃は、攻撃者がただ鍵を循環させて何が有効かを確認するもので、 **ブルートフォース攻撃**または**網羅的鍵探索**として知られている。

どのような暗号化方式であれ、セキュリティの最小限の概念を満たすためには、ブルートフォース攻撃が実行不可能なほど大きな、可能な鍵の集合、すなわち**鍵空間**を持たなければならない。現代の暗号化方式はすべてこの基準を満たしている。これは**十分な鍵空間の原則**として知られている。同様の原則は、異なるタイプの暗号方式にも一般的に適用される。

最新の暗号化方式における膨大な鍵空間の大きさを知るために、あるファ イルがAdvanced Encryption Standardを使って128ビットの鍵で暗号化されたとする。これは攻撃者がブルートフォース攻撃のために必要な$2^{128}$個の鍵のセットを持っていることを意味する。この戦略で0.78%の確率で成功するには、攻撃者はおよそ$2.65×10^{36}$個の鍵を循環させる必要がある。

攻撃者が毎秒10^{16}$個の鍵を試行できると楽観的に仮定する。鍵空間の全鍵の0.78%を試すには、攻撃者は2.65×10^{20}$秒の攻撃を続けなけれ ばならない。これは約8兆4000億年である。つまり、とんでもなく強力な敵による総当たり攻撃でさえ、最新の128ビット暗号化スキームでは現実的ではないのだ。これが十分鍵空間の原理である。

攻撃者が暗号化アルゴリズムを知らない場合、シフト暗号の方が安全なのだろうか？おそらくだが、それほどの差はないだろう。

いずれにせよ、現代の暗号技術では、対称暗号方式の安全性は秘密鍵の秘匿にのみ依存していると常に仮定している。攻撃者は常に、メッセージ空間、鍵空間、暗号文空間、鍵選択アルゴリズム、暗号化アルゴリズム、復号化アルゴリズムなど、他のすべての詳細を知っていると想定されている。

対称暗号方式の安全性は秘密鍵の秘匿性にのみ依存するという考え方は、**Kerckhoffsの原理**として知られている。

ケルクホフが当初意図したように、この原理は対称暗号方式にのみ適用される。しかし、この原則のより一般的なバージョンは、現代の他のすべてのタイプの暗号方式にも適用される：どのような暗号方式であれ、その設計が安全であるためには秘密であることを要求してはならない。秘密であることができるのは、ある情報の文字列（通常は秘密鍵）だけである。

Kerckhoffsの原理が現代暗号の中心である理由は4つある。[2]第一に、特定の種類のアプリケーションに対応する暗号方式は限られている。例えば、最新の対称暗号化アプリケーションのほとんどはRijndael暗号を使用している。そのため、スキームの設計に関する秘密は非常に限られています。しかし、Rijndael暗号の秘密鍵を秘密にしておく方が、はるかに柔軟性があります。

第二に、暗号スキーム全体を置き換えるよりも、一部の情報文字列を置き換える方が簡単である。ある会社の従業員全員が同じ暗号化ソフトウェアを持っていて、従業員同士が秘密裏に通信するための秘密鍵を持っているとしよう。このシナリオでは鍵の漏洩は面倒だが、少なくとも会社はこのようなセキュリティ侵害があってもソフトウェアを維持できる。もし会社がこのスキームの秘密性に依存しているのであれば、その秘密性が破られた場合、すべてのソフトウェアを交換する必要がある。

第三に、ケルコフスの原理は、暗号方式の標準化とユーザー間の互換性を可能にする。これは効率化にとって大きなメリットがある。例えば、グーグルのウェブ・サーバーに毎日何百万人もの人々が安全に接続できることを想像するのは難しい。

第四に、Kerckhoffの原理は暗号スキームの公開精査を可能にする。この種の精査は、安全な暗号方式を実現するために絶対に必要である。例えば、共通鍵暗号の主要なコア・アルゴリズムであるRijndael暗号は、1997年から2000年にかけて米国標準技術研究所（National Institute of Standards and Technology）によって開催されたコンペティションの結果である。

曖昧さ**によるセキュリティ**を達成しようとするシステムは、その設計や実装の詳細を秘密にすることに依存するものである。暗号技術では、特に暗号方式の設計の詳細を秘密にすることに依存するシステムがこれに該当する。つまり、曖昧さによるセキュリティは、ケルクホフの原理とは正反対なのだ。

オープン性が品質とセキュリティを強化する能力は、暗号技術だけでなく、より広範なデジタルの世界にも及んでいる。例えば、DebianのようなフリーでオープンソースのLinuxディストリビューションは、一般的に、プライバシー、安定性、セキュリティ、柔軟性の面で、WindowsやMacOSのディストリビューションよりもいくつかの利点がある。その原因は複数あるかもしれないが、最も重要な原則は、エリック・レイモンドが有名なエッセイ「大聖堂とバザール」で言い表したように、「十分な目玉があれば、すべてのバグは浅いものである」ということだろう[3]。[3]Linuxに最も大きな成功をもたらしたのは、この群衆の知恵のような原理である。

ある暗号方式が "安全 "であるとか "安全でない "といったことを明確に述べることはできない。その代わり、暗号方式にはさまざまな安全性の概念がある。各暗号方式の安全性**の定義には、(1)安全性の目標と(2)攻撃者の能力を明記する必要がある。1つまたは複数の特定のセキュリティ概念に照らして暗号方式を分析することで、その応用と限界について洞察することができる。

暗号のセキュリティに関する様々な概念の詳細についてはここでは触れないが、対称・非対称スキーム（そして何らかの形で他の暗号プリミティブも含む）に関連するセキュリティに関する現代の暗号概念には、2つの前提条件が普遍的に存在することを知っておく必要がある：


- 攻撃者のスキームに関する知識は、ケルクホフの原理に従う。
- 攻撃者はこのスキームに対してブルートフォースアタックを実行することは不可能である。具体的には、暗号的なセキュリティ概念の脅威モデルは、ブルートフォースアタックを考慮に入れていないため、通常ブルートフォースアタックすら許さない。

**注：**。

[1] セウトニウスによれば、ユリウス・カエサルが軍事通信で使用したのは、一定のキー値3を持つシフト暗号であった。つまり、Aは常にDになり、Bは常にEになり、Cは常にFになるというように。シフト暗号のこの特別なバージョンは、こうして**カエサル暗号**として知られるようになった（ただし、鍵の値は一定なので、現代的な意味での暗号とは言えない）。カエサル暗号は紀元前1世紀には安全であったかもしれない。もしローマの敵が暗号にあまり慣れていなかったのなら。しかし、現代では明らかに安全とは言えないだろう。

[2] Jonathan Katz and Yehuda Lindell, _Introduction to Modern Cryptography_, CRC Press (Boca Raton, FL: 2015), p. 7f.

[3] Eric Raymond, "The Cathedral and the Bazaar", 論文はLinux Kongress, Würzburg, Germanyで発表された（1997年5月27日）。この論文は、1997年5月27日にドイツのWürzburgで開催されたLinux Kongressで発表された。引用はこの本の30ページから：Eric Raymond, _The Cathedral and the Bazaar：The Cathedral and the Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary_, revised edn.(2001), O'Reilly：Sebastopol, CA.

## ストリーム暗号

<chapterId>479aa6f4-45c4-59ca-8616-8cf8e61fc871</chapterId>

対称暗号方式は標準的に2つのタイプに分類される： **ストリーム暗号**と**ブロック暗号**である。しかし、この区別はやや厄介で、人々はこれらの用語を一貫性のない方法で使っている。次の数セクションでは、私が最も良いと思う方法でこの区別を説明する。しかし、多くの人がこれらの用語を私が示したのとは多少違った形で使っていることに注意すべきである。

まずストリーム暗号について説明しよう。ストリーム暗号**は対称暗号方式で、暗号化は2つのステップからなる。

まず、秘密鍵を使って平文と同じ長さの文字列を生成する。この文字列を**キーストリーム**と呼ぶ。

次に、キーストリームを平文と数学的に組み合わせ、暗号文を生成する。この組み合わせは通常XOR演算である。復号には、この操作を逆にすればよい。($A$と$B$がビット列の場合、$A \oplus B = B \oplus A$であることに注意。つまり、ストリーム暗号におけるXOR演算の順序は結果には関係ない。この性質は**可換性**として知られている)。

典型的なXORストリーム暗号を図3*に示す。まず秘密鍵$K$を受け取り、それを使ってキーストリームを生成する。キーストリームは次に、XOR演算によって平文と結合され、暗号文が生成される。暗号文を受け取ったエージェントは、鍵$K$を持っていれば簡単に復号できる。エージェントがすべきことは、スキームの指定された手順に従って、暗号文と同じ長さのキーストリームを作成し、それを暗号文とXORするだけである。

*図3: XORストリーム暗号*。

![Figure 3: An XOR stream cipher](assets/Figure4-3.webp "Figure 3: An XOR stream cipher")

暗号化スキームとは、厳密な仕様ではなく、一般的に同じコア・アルゴリズムによる暗号化のテンプレートであることに留意されたい。その延長として、ストリーム暗号は通常、異なる長さの鍵を使うことができる暗号化のテンプレートである。鍵の長さはスキームの細部に影響を与えることはあっても、その本質的な形に影響を与えることはない。

シフト暗号は非常に単純で安全でないストリーム暗号の一例である。一つの文字（秘密鍵）を使って、メッセージと同じ長さの文字列（キーストリーム）を作ることができる。このキーストリームをモジュロ演算によって平文と組み合わせ、暗号文を生成する。(このモジュロ演算は、文字をビットで表す場合はXOR演算に単純化できる）。

ストリーム暗号のもう一つの有名な例は**Vigenere暗号**で、これは16世紀末にこれを完全に開発したBlaise de Vigenereにちなんだものである（他の人々も多くの先行研究を行ったが）。これは**ポリアルファベット置換暗号**の一例であり、平文記号に対する暗号文のアルファベットがテキスト中の位置によって変化する暗号化方式である。単アルファベット置換暗号とは対照的に、暗号文記号は複数の平文記号に関連付けることができる。

ルネサンス期のヨーロッパで暗号が普及するにつれて、**暗号解析**、つまり暗号文の解読、特に**頻度解析**を用いた解読も普及した。特に**頻度分析**を用いた暗号文の解読である。後者は、暗号文を解読するために我々の言語の統計的な規則性を用いるもので、9世紀にはすでにアラビアの学者によって発見されていた。これは特に長い文章に有効なテクニックだ。また、ヨーロッパでは1700年代になると、特に軍事やセキュリティの場面では、最も洗練されたモノアルファベットの置換暗号でさえ、周波数分析に対してはもはや十分ではなくなっていた。Vigenere暗号はセキュリティに大きな進歩をもたらしたため、この時代に普及し、1700年代後半には広まった。

非公式に言えば、暗号化スキームは次のように動作する：

1.秘密鍵として複数文字の単語を選択する。

2.任意のメッセージに対して、キーワードの対応する文字をシフトとして、メッセージの各文字にシフト暗号を適用する。

3.キーワードを循環させたが、まだ平文を完全に暗号化できていない場合、キーワードの文字をシフト暗号として、残りのテキストの対応する文字に再度適用する。

4.メッセージ全体が暗号化されるまでこの作業を続ける。

例えば、あなたの秘密鍵が "GOLD "で、メッセージ "CRYPTOGRAPHY "を暗号化したいとする。この場合、Vigenère暗号に従って次のように処理する：


- c_0 = [(2 + 6) Μmod 26] = 8 = I$.
- c_1 = [(17 + 14) Μmod 26] = 5 = F$.
- c_2 = [(24 + 11) Μmod 26] = 9 = J$.
- c_3 = [(15 + 3) Μmod 26] = 18 = S$.
- c_4 = [(19 + 6) ゙モッド 26] = 25 = Z$.
- c_5 = [(14 + 14) ゙モッド 26] = 2 = C$.
- c_6 = [(6 + 11) Μmod 26] = 17 = R$.
- c_7 = [(17 + 3) Μmod 26] = 20 = U$.
- c_8 = [(0 + 6) ゙モッド 26] = 6 = G$.
- c_9 = [(15 + 14) ̫ 26] = 3 = D$.
- c_{10} = [(7 + 11) Μmod 26] = 18 = S$.
- c_{11} = [(24 + 3) Μmod 26] = 1 = B$.

したがって、暗号文$c$ = "IFJSZCRUGDSB "となる。

ストリーム暗号のもう一つの有名な例は**ワンタイムパッド**である。ワンタイムパッドでは、単純に平文メッセージと同じ長さのランダムなビット列を作成し、XOR演算によって暗号文を生成する。したがって、ワンタイムパッドでは秘密鍵とキーストリームは等価である。

Shift暗号とVigenere暗号は現代では非常に安全ではないが、ワンタイムパッドは正しく使えば非常に安全である。ワンタイムパッドの最も有名な応用例は、少なくとも1980年代までは、**ワシントン・モスクワ・ホットライン**であった。[4]

ホットラインは、キューバ危機の後に設置された、ワシントンとモスクワを結ぶ緊急用の直接通信回線である。その技術は年々変化している。現在では、直接光ファイバーケーブルのほか、電子メールやテキストメッセージを可能にする2つの衛星リンク（冗長性のため）がある。リンクの終点はアメリカのさまざまな場所にある。ペンタゴン、ホワイトハウス、レイヴン・ロック・マウンテンがエンドポイントとして知られている。一般的な意見に反して、ホットラインが電話を使ったことは一度もない。

要するに、ワンタイムパッドの仕組みは次のようなものだった。ワシントンとモスクワの双方が2組の乱数を持つ。ひとつはロシア人が作成した乱数セットで、ロシア語のメッセージの暗号化と復号化に関係する。アメリカ人が作成した1組の乱数は、英語によるメッセージの暗号化と解読に関係する。時々、より多くの乱数が信頼できる運び屋によって相手側に届けられた。

ワシントンとモスクワは、ワンタイムパッドを作るためにこの乱数を使うことで、秘密裏に通信することができた。通信が必要になるたびに、次の部分の乱数をメッセージに使うのだ。

安全性は高いが、ワンタイムパッドには実用上大きな制限がある。キーはメッセージと同じ長さが必要で、ワンタイムパッドのどの部分も再利用できない。つまり、ワンタイムパッドのどこにいるのかを追跡し、膨大な数のビットを保存し、相手と時々ランダムなビットを交換する必要がある。結果として、ワンタイムパッドは実際にはあまり使われない。

その代わりに、実際に使われているストリーム暗号の主流は**擬似ランダム・ストリーム暗号**である。Salsa20とChaChaと呼ばれる密接に関連した亜種は、一般的に使用される擬似ランダム・ストリーム暗号の例である。

これらの擬似ランダム・ストリーム暗号では、まず平文の長さよりも短い鍵Kをランダムに選択する。このようなランダムな鍵Kは通常、私たちのコンピュータが、ネットワーク・メッセージ間の時間やマウスの動きなど、時間をかけて収集した予測不可能なデータに基づいて作成する。

このランダム鍵$K$を、メッセージと同じ長さの擬似ランダム鍵ストリー ムを生成する展開アルゴリズムに挿入する。鍵ストリームの長さを正確に指定することができる（例えば、500ビット、1000ビット、1200ビット、29,117ビットなど）。

擬似ランダム・キーストリームは、同じ長さの文字列の集合から完全にランダムに選ばれたかのように見える。したがって、擬似ランダム・キーストリームを使った暗号化は、あたかもワンタイムパッドを使ったかのように見える。しかし、もちろんそうではない。

私たちの秘密鍵はキーストリームよりも短く、暗号化/復号化プロセスが機能するためには、拡張アルゴリズムが決定論的である必要があるため、その特定の長さのキーストリームがすべて、拡張操作の出力として得られるとは限らない。

例えば、我々の秘密鍵が128ビットの長さを持ち、それを拡張アルゴリズムに 挿入することで、より長い鍵ストリーム、例えば2,500ビットの鍵ストリームを 作成できるとする。拡張アルゴリズムは決定論的である必要があるため、このアルゴリズムが選 択できるのはせいぜい$1/2^{128}$個の2,500ビットの文字列である。つまり、このようなキーストリームは、同じ長さの全ての文字列から完全にランダムに選択することはできない。

ストリーム暗号の定義には2つの側面がある。(1)平文と同じ長さのキーストリームが秘密鍵の助けを借りて生成されること、(2)このキーストリームが、通常XOR演算によって平文と結合され、暗号文が生成されること、である。

条件(1)をより厳密に定義し、キーストリームは特に擬似ランダムでなければならないと主張する人もいる。つまり、シフト暗号もワンタイムパッドもストリーム暗号とはみなされない。

私の考えでは、条件(1)をより広く定義することで、暗号化方式を整理しやすくなる。加えて、ある暗号化方式が実際には擬似ランダム鍵ストリームに依存していないことを知ったからといって、その暗号化方式をストリーム暗号と呼ぶのをやめる必要はないということだ。

**注：**。

[4] 暗号博物館、「ワシントン-モスクワ・ホットライン」、2013年、[https://www.cryptomuseum.com/crypto/hotline/index.htm](https://www.cryptomuseum.com/crypto/hotline/index.htm)で入手可能。

## ブロック暗号

<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

ブロック暗号**が一般的に理解される最初の方法は、ストリーム暗号よりも原始的なものとして理解されることだ：鍵の助けを借りて、適切な長さの文字列に対して長さ保存変換を行うコア・アルゴリズム。このアルゴリズムは、暗号化スキームやおそらく他のタイプの暗号化スキームの作成に使用できる。

ブロック暗号は、64ビット、128ビット、256ビットなどさまざまな長さの入力文字列と、128ビット、192ビット、256ビットなどさまざまな長さの鍵を受け取ることがよくある。これらの変数によってアルゴリズムの細部が変わることはあっても、核となるアルゴリズムが変わることはない。もしそうであれば、2つの異なるブロック暗号が存在することになる。ここでのコア・アルゴリズム用語の使用は、暗号化方式と同じであることに注意。

ブロック暗号がどのように機能するかは、以下の*図4*で見ることができる。長さ$L$のメッセージ$M$と鍵$K$がブロック暗号の入力となる。ブロック暗号は長さ$L$のメッセージ$M'$を出力する。ほとんどのブロック暗号では、鍵は必ずしも$M$と$M'$と同じ長さである必要はない。

*図4：ブロック暗号

![Figure 4: A block cipher](assets/Figure4-4.webp "Figure 4: A block cipher")

ブロック暗号はそれだけでは暗号化方式ではない。しかし、ブロック暗号は様々な**演算モード**と一緒に使うことで、様々な暗号化スキームを作り出すことができる。操作モードとは、単にブロック暗号の外側にいくつかの追加操作を加えるだけである。

この仕組みを説明するために、128ビットの入力文字列と128ビットの秘密鍵を必要とするブロック暗号（BC）を仮定する。下の図5は、そのブロック暗号を**電子コードブック・モード**（*ECBモード**）でどのように使用し、暗号化スキームを作成するかを示している。(右の楕円は、このパターンを必要なだけ繰り返すことができることを示している）。

*図5：ECBモード*を持つブロック暗号

![Figure 5: A block cipher with ECB mode](assets/Figure4-5.webp "Figure 5: A block cipher with ECB mode")

ブロック暗号を使った電子暗号の手順は以下の通りである。平文のメッセージを128ビットのブロックに分割できるかどうかを確認する。そうでなければ、メッセージに**パディング**を加え、その結果がブロックサイズ128ビットで均等に分割できるようにする。これが暗号化処理に使われるデータである。

データを128ビットの文字列（$M_1$, $M_2$, $M_3$...）に分割する。各128ビット文字列を128ビット鍵でブロック暗号に通し、128ビットの暗号文の塊（$C_1$, $C_2$, $C_3$など）を生成する。これらのチャンクを再び結合すると、完全な暗号文になる。

復号化は、その逆のプロセスだが、受信者は、復号化されたデータからパディングを取り除き、元の平文メッセージを生成するために、何らかの認識可能な方法を必要とする。

比較的簡単ではあるが、電子コードブック・モードのブロック暗号は安全性に欠ける。これは**決定論的暗号化**につながるからだ。同じ128ビットのデータ列が2つあれば、まったく同じように暗号化される。その情報は悪用される可能性がある。

つまり、任意のメッセージ$M$、または$M$の任意の特定の塊の暗号化は、一般的に毎回異なる結果をもたらすはずです。[5]

暗号ブロック連鎖モード**（**CBCモード**）は、ブロック暗号で使われる最も一般的なモードだろう。この組み合わせが正しく行われれば、確率的暗号化スキームが出来上がる。下の*図6*に、この動作モードの描写を見ることができる。

*図6：CBCモード*を持つブロック暗号

![Figure 6: A block cipher with CBC mode](assets/Figure4-6.webp "Figure 6: A block cipher with CBC mode")

ブロック・サイズが再び128ビットだとする。そこで、元の平文メッセージに必要なパディングが施されていることを保証する必要がある。

次に、平文の最初の128ビット部分を128ビットの**初期化ベクトル**とXORする。その結果をブロック暗号に入れ、最初のブロックの暗号文を生成する。128ビットの2番目のブロックでは、まず平文を1番目のブロックの暗号文とXORしてからブロック暗号に挿入する。平文メッセージ全体を暗号化するまで、このプロセスを続ける。

終了したら、暗号化されたメッセージを暗号化されていない初期化ベクタとともに受信者に送る。受信者は初期化ベクトルを知っている必要がある。

この構造は、正しく使えば電子コードブック・モードよりもはるかに安全である。まず、初期化ベクトルがランダムまたは擬似ランダム文字列であることを確認する必要がある。さらに、この暗号化方式を使うたびに異なる初期化ベクトルを使うべきである。

言い換えれば、初期化ベクターはランダムまたは擬似ランダム・ノンスであるべきで、**ノンス**は "一度しか使われない数字 "を意味する。この習慣を守れば、ブロック暗号を使ったCBCモードでは、2つの同じ平文ブロックが一般的に毎回異なる暗号化されることが保証される。

最後に、**出力フィードバック・モード**（*OFBモード**）に注目してみよう。このモードの描写を*図7*に見ることができる。

*図7：OFBモード*を持つブロック暗号

![Figure 7: A block cipher with OFB mode](assets/Figure4-7.webp "Figure 7: A block cipher with OFB mode")

OFBモードでは、初期化ベクトルも選択する。しかしここでは、最初のブロックについて、初期化ベクターが鍵とともにブロック暗号に直接挿入される。その結果、128ビットがキーストリームとして扱われる。このキーストリームを平文とXORし、そのブロックの暗号文を生成する。それ以降のブロックでは、前のブロックのキーストリームをブロック暗号への入力として使用し、手順を繰り返す。

よく見ると、OFBモードのブロック暗号から実際に作られたのはストリーム暗号である。平文の長さになるまで128ビットのキーストリーム部分を生成する（最後の128ビットのキーストリーム部分から不要なビットを捨てる）。そして、そのキーストリームと平文のメッセージを XOR して暗号文を得る。

前回のストリーム暗号のセクションでは、秘密鍵を使ってキーストリームを生成すると述べた。正確には、秘密鍵だけで作成する必要はない。OFBモードでは、秘密鍵と初期化ベクトルの両方を使用してキーストリームを生成する。

CBC モードと同様、OFB モードでブロック暗号を使用する際には、初期化ベクターに擬似ランダムまたはランダムなノンスを毎回選択することが重要であることに注意してください。そうしないと、異なる通信で送信された同じ128ビットのメッセージ文字列が同じように暗号化されてしまう。これがストリーム暗号で確率的暗号化を行う一つの方法である。

ストリーム暗号の中には、秘密鍵のみを使用してキーストリームを作成するものがある。そのようなストリーム暗号では、通信の各インスタンスで、ランダムな ノンスを使用して秘密鍵を選択することが重要である。そうしないと、そのようなストリーム暗号を使った暗号化の結果も決定論的なものになり、セキュリティ上の問題につながる。

現代のブロック暗号で最も有名なのは**Rijndael暗号**である。これは、1997年から2000年にかけて国立標準技術研究所（NIST）が開催した、古い暗号化標準である**データ暗号化標準**（*DES**）を置き換えるためのコンペティションで、15件の応募の中から優勝したものである。

Rijndael暗号は、鍵長やブロックサイズ、動作モードの異なる仕様で使用することができる。NISTのコンペティション委員会は、128ビットのブロックサイズと128ビット、192ビット、256ビットのいずれかの鍵長を必要とするRijndael暗号の制限バージョンを**advanced encryption standard** (**AES**)の一部として採用した。これは対称暗号化アプリケーションの主要な標準である。非常に安全であるため、NSAでさえ最高機密文書に256ビットの鍵で使用することを望んでいるようだ。[6]

AESブロック暗号については、*第5章*で詳しく説明する。

**注：**。

[5] 確率的暗号化の重要性は、Shafi GoldwasserとSilvio Micali, "Probabilistic encryption", _Journal of Computer and System Sciences_, 28 (1984), 270-99によって初めて強調された。

[6] NSA, "Commercial National Security Algorithm Suite", [https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm](https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm) 参照。

## 混乱の解消

<chapterId>121c1858-27e3-5862-b0ce-4ff2f70f9f0f</chapterId>

ブロック暗号とストリーム暗号の区別に関する混乱は、人々がブロック暗号という用語を、特に暗号化のブロック・モード*を持つ*ブロック暗号を指していると理解することがあるために生じる。

前節のECBモードとCBCモードを考えてみよう。これらは特に、暗号化のためのデータがブロック・サイズで割り切れることを要求する（つまり、元のメッセージにパディングを使わなければならないかもしれない）。加えて、これらのモードではデータもブロック暗号によって直接操作される（OFBモードのようにブロック暗号の操作結果と組み合わされるわけではない）。

したがって、別の方法として、**ブロック暗号**を、一度にメッセージの固定長ブロック（どのブロックも1バイトより長くなければならず、そうでなければストリーム暗号になる）を操作するあらゆる暗号化方式と定義することができる。暗号化のためのデータと暗号文は、どちらもこのブロックサイズに均等に分割されなければならない。通常、ブロック・サイズは64、128、192、256ビットの長さである。対照的に、ストリーム暗号は一度に1ビットまたは1バイトの塊であらゆるメッセージを暗号化することができる。

このようにブロック暗号をより具体的に理解すれば、現代の暗号化方式はストリーム暗号かブロック暗号のどちらかだと主張することができる。ここからは、特に断りのない限り、ブロック暗号という言葉をより一般的な意味で使うことにする。

前節のOFBモードに関する議論は、もう1つ興味深い点を提起している。ストリーム暗号の中には、OFBを持つRijndaelのように、ブロック暗号から作られるものもある。Salsa20やChaChaのように、ブロック暗号から作られていないものもある。後者を**プリミティブ・ストリーム暗号**と呼ぶこともある。(このようなストリーム暗号を指す標準的な用語はありません）。

ストリーム暗号とブロック暗号の長所と短所について語られるとき、彼らは通常、原始的なストリーム暗号とブロック暗号に基づく暗号化方式を比較している。

ブロック暗号からストリーム暗号を構築するのはいつでも簡単にできるが、（CBCモードなどの）ブロックモードの暗号を、原始的なストリーム暗号から構築するのは通常非常に難しい。

この議論から、あなたは*図8*を理解したはずである。これは対称暗号化方式の概要を示している。原始ストリーム暗号、ブロック暗号ストリーム暗号、ブロックモードのブロック暗号（図では「ブロック暗号」とも呼ばれる）である。

*図8：対称暗号方式*の概要

![Figure 8: Overview of symmetric encryption schemes](assets/Figure4-8.webp "Figure 8: Overview of symmetric encryption schemes")

## メッセージ認証コード

<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>

暗号化は秘密に関わる。しかし暗号は、メッセージの完全性、真正性、否認防止といった、より広範なテーマにも関係している。いわゆる**メッセージ認証コード**（MAC）は、通信における真正性と完全性をサポートする共通鍵暗号方式である。

なぜ通信に秘密以外のものが必要なのか？ボブが実質的に解読不可能な暗号を使ってアリスにメッセージを送ったとする。このメッセージを傍受した攻撃者は、内容に関する重要な洞察を得ることはできない。しかし、攻撃者は少なくとも2つの攻撃ベクトルをまだ持っている：

1.彼女は暗号文を傍受し、その内容を変更し、変更した暗号文をアリスに送ることができる。

2.彼女はボブのメッセージを完全にブロックし、自分で作成した暗号文を送ることができる。

どちらの場合も、攻撃者は暗号文(1)と(2)から内容を読み取ることはできないかもしれない。しかし、それでもこの方法で大きな損害を与えることができる。ここでメッセージ認証コードが重要になる。

メッセージ認証コードは、鍵生成アルゴリズム、タグ生成アルゴリズム、検証アルゴリズ ムの3つのアルゴリズムを持つ対称暗号方式として緩く定義される。セキュアなMACは、どのような攻撃者にとってもタグが**存在的に偽造不可能**であることを保証する。

ボブとアリスはMACを使って特定のメッセージの操作に対抗できる。とりあえず、彼らが秘密性には関心がないとする。彼らは、アリスが受信したメッセージが本当にボブからのもので、何ら変更されていないことを保証したいだけである。

その過程は*図9*に描かれている。MAC**（メッセージ認証コード）を使うには、まず二人の間で共有される秘密鍵$K$を生成する。ボブは秘密鍵$K$を使ってメッセージのタグ$T$を作成する。そして、メッセージとメッセージタグをアリスに送る。アリスは、秘密鍵、メッセージ、タグを検証アルゴリズムにかけることで、 ボブが本当にタグを作ったことを検証できる。

*図9：対称暗号方式*の概要

![Figure 9: Overview of symmetric encryption schemes](assets/Figure4-9.webp "Figure 9: Overview of symmetric encryption schemes")

実存的な偽造不可能性**により、攻撃者はメッセージ$M$を改ざんしたり、 有効なタグを持つメッセージを自作することはできない。これは、たとえ攻撃者が同じ秘密鍵を使ったボブとアリスの間の多くのメッセージのタグを観察したとしても同じである。攻撃者はせいぜい、アリスがメッセージ$M$を受け取れないようにするくらいである（暗号では対処できない問題）。

MACは、メッセージが実際にボブによって作成されたことを保証する。つまり、ボブが何らかのメッセージを作成したのであれば、そのメッセージは攻撃者によって何ら変更されていないということである。つまり、ボブがあるメッセージを作成したのであれば、事実上、攻撃者によって何ら改ざんされていないということである。したがって、ここから先は、認証に対する懸念は、自動的に完全性に対する懸念を意味すると理解すべきである。

私は、メッセージの信頼性と完全性を区別して議論してきたが、これらの用語を同義語として使用することも一般的である。これらの用語は、特定の送信者によって作成され、何ら変更されていないメッセージのことを指す。この精神から、メッセージ認証コードはしばしば**メッセージ完全性コード**とも呼ばれる。

## 認証された暗号化

<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>

一般的に、通信では秘密性と真正性の両方を保証したいので、暗号化方式とMAC方式が併用されるのが普通である。

認証された暗号化方式**とは、高度に安全な方法で暗号化とMACを組み合わせた方式である。具体的には、**選択暗号文攻撃**に耐性のある秘密性という非常に強い概念と同様に、存在的な偽造不可能性の基準を満たさなければならない。[7]

つまり、攻撃者が暗号文を変更した場合、無効な暗号文が生成されるか、元の暗号文とは全く関係のない平文に復号されるかのどちらかでなければならない。[8]

認証された暗号化スキームは、攻撃者が作成した暗号文が常に無効であることを保証するので（タグが検証されないため）、選択暗号文攻撃に対する耐性の基準を満たしている。興味深いことに、存在的に偽造不可能なMACと、**選択平文攻撃セキュリティ**として知られる、セキュリティのあまり強くない概念を満たす暗号化スキームの組み合わせから、認証された暗号化スキームが常に作成できることを証明することができます。

ここでは、認証された暗号化スキームを構築するための詳細をすべて掘り下げることはしない。しかし、その構築に関する2つの詳細を知っておくことは重要である。

まず、認証された暗号化スキームは、最初に暗号化を処理し、次に暗号文にメッセージタグを作成する。暗号文と平文のタグを組み合わせたり、最初にタグを作成してから平文とタグの両方を暗号化したりするような他のアプローチは、安全ではないことが判明している。さらに、どちらの操作にも、ランダムに選択された秘密鍵が必要である。

前述の原則はより一般的に適用される： *基本的な暗号方式*を組み合わせるときは、常に別々の鍵を使うべきである。

認証された暗号化方式を図10に示す。Bobはまず、ランダムに選んだ鍵$K_C$を使って、メッセージ$M$から暗号文$C$を作成する。次に、暗号文と別のランダムに選んだ鍵$K_T$をタグ生成アルゴリズムに通すことで、メッセージタグ$T$を作成する。暗号文とメッセージタグの両方がアリスに送られる。

アリスはまず、暗号文$C$と鍵$K_T$からタグが有効かどうかを調べる。有効であれば、鍵 $K_C$ を使ってメッセージを復号できる。アリスは通信の秘密が保証されるだけでなく、メッセージがボブによって作成されたことも知ることができる。

*図10：認証された暗号化方式*。

![Figure 10: An authenticated encryption scheme](assets/Figure4-10.webp "Figure 10: An authenticated encryption scheme")

MACはどのようにして作られるのか？MACは複数の方法で作成できますが、一般的で効率的な作成方法は**暗号ハッシュ関数**です。

暗号ハッシュ関数については、*第6章*で詳しく紹介する。今のところ、**ハッシュ関数**とは、任意のサイズの入力を受け取り、固定長の出力を生成する、効率的に計算可能な関数であることだけ知っておいてほしい。例えば、よく使われるハッシュ関数**SHA-256**（セキュア・ハッシュ・アルゴリズム256）は、入力のサイズに関係なく常に256ビットの出力を生成する。SHA-256のようないくつかのハッシュ関数は、暗号技術において有用なアプリケーションを持っている。

暗号ハッシュ関数で生成されるタグの最も一般的なタイプは、**ハッシュベースのメッセージ認証コード**（HMAC）である。そのプロセスを図11に示す。当事者は、秘密鍵$K$から2つの異なる鍵、内部鍵$K_1$と外部鍵$K_2$を生成する。平文$M$または暗号文$C$を内部鍵でハッシュする。その結果$T'$を外部鍵でハッシュし、メッセージタグ$T$を生成する。

HMACを作成するために使用できるハッシュ関数のパレットがある。最もよく使われるハッシュ関数はSHA-256である。

*図11：HMAC

![Figure 11: HMAC](assets/Figure4-11.webp "Figure 11: HMAC")

**注：**。

[7] このセクションで論じる具体的な結果は、Katz and Lindell, pp.131-47による。

[技術的には、選択された暗号テキスト攻撃の定義は、非可逆性の概念とは異なります。しかし、この2つの安全性の概念が等価であることを示すことができます。

## 安全な通信セッション

<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

2つの当事者が通信セッションに参加しており、複数のメッセージをやり取りしているとする。

認証された暗号化方式は、メッセージの受信者が、（秘密鍵が漏れていない限り）そのメッセージが通信セッションの中でパートナーによって作成されたものであることを検証することを可能にする。これは単一のメッセージであれば十分に機能する。しかし通常、2つのパーティは通信セッションでメッセージをやり取りする。このような状況では、前節で説明したような単純な認証付き暗号化方式では、セキュリティを提供するには不十分である。

主な理由は、認証された暗号化スキームでは、メッセージが通信セッション内でそれを作成したエージェントによっても実際に送信されたという保証がないからである。次の3つの攻撃ベクトルを考えてみよう：

1. **リプレイ攻撃**：攻撃者は、以前の時点で傍受した暗号文とタグを2者間で再送する。

2. **逆順攻撃**：攻撃者は異なる時間に2つのメッセージを傍受し、逆の順序で受信者に送信する。

3. **反射攻撃**：攻撃者はAからBに送信されたメッセージを観察し、そのメッセージをAにも送信する。

攻撃者は暗号文を知らないし、なりすましの暗号文を作ることもできないが、それでも上記の攻撃は通信に大きなダメージを与える可能性がある。

例えば、両者間の特定のメッセージに金銭の授受が含まれているとする。リプレイ攻撃は、その資金を2回目に送金するかもしれない。通常の認証付き暗号化方式では、このような攻撃に対する防御策はない。

幸いなことに、この種の攻撃は、**識別子**と**相対時間インジケータ**を使った通信セッションで簡単に軽減できる。

暗号化する前に識別子を平文メッセージに加えることができる。これにより、反射攻撃を防ぐことができる。相対的な時間指標とは、例えば特定の通信セッションにおけるシーケンス番号である。各パーティは暗号化の前にシーケンス番号をメッセージに付加するので、受信者はメッセージがどのような順序で送信されたかを知ることができる。これにより、再順序付け攻撃の可能性がなくなる。また、リプレイ攻撃もなくなります。攻撃者が下へ送るメッセージはすべて古いシーケンス番号を持つことになり、受信者はそのメッセージを再び処理しないように知ることができる。

安全な通信セッションがどのように機能するかを説明するために、再びアリスとボブを仮定する。二人は合計4つのメッセージをやり取りする。識別子とシーケンス番号による認証された暗号化スキームがどのように機能するか、*図11*で見ることができる。

通信セッションは、BobがAliceにメッセージタグ$T_{0,B}$付きで暗号文$C_{0,B}$を送るところから始まる。暗号文はメッセージ、識別子(BOB)、シーケンス番号(0)を含む。タグ$T_{0,B}$は暗号文全体につけられる。その後の通信において、アリスとボブはこのプロトコルを維持し、必要に応じてフィールドを更新する。

*図12：安全な通信セッション

![Figure 12: A secure communication session](assets/Figure4-12.webp "Figure 12: A secure communication sessesion")

# RC4とAES

<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

## RC4ストリーム暗号

<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>

本章では、最新のプリミティブ・ストリーム暗号であるRC4（または「Rivest cipher 4」）と、最新のブロック暗号であるAESを用いた暗号化方式の詳細について説明する。RC4暗号は暗号化の方法としては好まれなくなったが、AESは現代の対称暗号の標準である。この2つの例を見れば、対称暗号がどのように機能するのかがよくわかるだろう。

___

最新の擬似ランダム・ストリーム暗号がどのように機能するかを理解するために、RC4ストリーム暗号に焦点を当てる。これは擬似ランダム・ストリーム暗号で、WEPやWAP無線アクセス・ポイントのセキュリティ・プロトコルやTLSで使われていた。RC4には多くの弱点があることが証明されているため、現在ではあまり使われていません。実際、インターネット・エンジニアリング・タスク・フォースは現在、TLSのすべてのインスタンスで、クライアントおよびサーバー・アプリケーションによるRC4スイートの使用を禁止している。とはいえ、原始的なストリーム暗号がどのように機能するかを説明する例として、RC4は有効である。

手始めに、ベイビーRC4暗号を使って平文メッセージを暗号化する方法を紹介しよう。平文メッセージが "SOUP "だとする。このBaby RC4暗号を使った暗号化は4つのステップで行われる。

### ステップ1

まず、$S[0] = 0$ から $S[7] = 7$ までの配列 **S** を定義する。ここでの配列とは、単にインデックスによって編成された値の変更可能なコレクションを意味し、一部のプログラミング言語（Pythonなど）ではリストとも呼ばれる。この場合、インデックスは0から7まであり、値も0から7まである：


- $S = [0, 1, 2, 3, 4, 5, 6, 7]$

ここでの値はASCII数値ではなく、1バイト文字列の10進数値表現である。つまり、2という値は$0000 \ 0011$に相当する。したがって、配列**S**の長さは8バイトである。

### ステップ2

次に、8バイト長のキー配列**K**を定義し、1バイトから8バイトの間でキーを選択する（端数は許されない）。各バイトは8ビットなので、キーの各バイトには0から255までの任意の数値を選択できる。

キー**k**を$[14, 48, 9]$とし、長さが3バイトになるようにします。キー配列の各インデックスは、キーの特定の要素の10進数値に従って順番に設定されます。キー配列の8つのスロットが埋まるまで、キー全体を走査する場合は最初からやり直します。したがって、キー配列は以下のようになる：


- $K = [14, 48, 9, 14, 48, 9, 14, 48]$

### ステップ3

第3に、キー配列**K**を用いて配列**S**を変換する。これは**キースケジューリング**として知られる処理である。このプロセスは擬似コードで次のようになる：


- 変数 **j** と **i** を作成する。
- 変数 $j = 0$ を設定する
- 0から7までの各$i$について：
    - j = (j + S[i] + K[i])  \mod 8$ とする。
    - S[i]$と$S[j]$を入れ替える。

配列**S**の変換は、*表1*によって捉えられている。

まず、**S**の初期状態を$[0, 1, 2, 3, 4, 5, 6, 7]$とし、**j**の初期値を0とする。これは、キー配列$[14, 48, 9, 14, 48, 9, 14, 48]$を使って変換される。

forループは$i = 0$から始まります。上の擬似コードによると、**j**の新しい値は6になる($j = (j + S[0] + K[0]) ゙mod 8 = (0 + 0 + 14) ゙mod 8 = 6 ゙mod 8$)。S[0]$と$S[6]$を入れ替えると、1ラウンド後の**S**の状態は$[6, 1, 2, 3, 4, 5, 0, 7]$となる。

次の行では、$i = 1$である。もう一度forループを通すと、**j**は7という値を得る（$j = (j + S[1] + K[1]) ╱8 = (6 + 1 + 48) ╱8 = 55 ╱8 = 7 ╱8$）。現在の**S**の状態$[6, 1, 2, 3, 4, 5, 0, 7]$から$S[1]$と$S[7]$を入れ替えると、2ラウンド目以降は$[6, 7, 2, 3, 4, 5, 0, 1]$となる。

配列**S**の最後の行、$[6, 4, 1, 0, 3, 7, 5, 2]$ができるまで、この作業を続ける。

*表1：主なスケジューリング表*。

| S[0]｜S[1]｜S[2]｜S[3]｜S[4]｜S[5]｜S[6]｜S[7]

| ------- | --- | --- | --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |







| 2 | 1 | 7 | | 6 | 7 | 2 | 3 | 4 | 5 | 0 | 1 |





| 5 | 4 | 3 | | 6 | 7 | 2 | 0 | 3 | 5 | 4 | 1 |

| 6 | 5 | 6 | | 6 | 4 | 2 | 0 | 3 | 7 | 5 | 1 |





### ステップ4

第4段階として、**キーストリーム**を生成する。これは、送信したいメッセージと同じ長さの擬似ランダム文字列である。これは元のメッセージ「SOUP」を暗号化するために使用される。キーストリームはメッセージと同じ長さが必要なので、4バイトのものが必要である。

キーストリームは以下の擬似コードで生成される：


- 変数**j**、**i**、**t**を作成する。
- j = 0$ とする。
- 平文の各$i$について、$i = 1$から始まって$i = 4$まで、キーストリームの各バイトは以下のように生成される：
    - j = (j + S[i])  \mod 8$.
    - S[i]$と$S[j]$を入れ替える。
    - t = (S[i] + S[j]) \mod 8$.
    - キーストリームの$i^{th}$バイト = $S[t]$。

表2*で計算を追うことができる。

S**の初期状態は$S = [6, 4, 1, 0, 3, 7, 5, 2]$である。i＝1$とすると、**j**の値は4（$j＝(j＋S[i])゙モッド8＝(0＋4)゙モッド8＝4$）となる。次に、$S[1]$と$S[4]$を入れ替えて、2行目の**S**の変形、$[6,3,1,0,4,7,5,2]$を作る。このとき、**t**の値は7（$t = (S[i] + S[j]) ゙mod 8 = (3 + 4) ゙mod 8 = 7$）となる。最後に、キーストリームのバイトは$S[7]$、つまり2である。

2、6、3、7の4バイトになるまで、他のバイトを生成し続ける。これらの各バイトを使って、平文 "SOUP "の各文字を暗号化することができる。

手始めに、ASCIIテーブルを使用すると、「SOUP」をその下のバイト列の10進値でエンコードしたものが「83 79 85 80」であることがわかる。キーストリームの "2 6 3 7 "と組み合わせると、"85 85 88 87 "となり、これはモジュロ256演算後も変わらない。ASCIIでは、暗号文 "85 85 88 87 "は "UUXW "に等しい。

暗号化する単語が配列**S**より長かったらどうなるだろうか？その場合、配列**S**は、平文の各バイト**i**に対して、上に示した方法で、平文の文字数と同じバイト数のキーストリームができるまで変形し続ける。

*表2：キーストリームの生成

| i｜j｜t｜キーストリーム｜S[0]｜S[1]｜S[2]｜S[3]｜S[4]｜S[5]｜S[6]｜S[7]｜キーストリーム

| --- | --- | --- | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |





| 1 | 4 | 7 | 2 | 6 | 3 | 1 | 0 | 4 | 7 | 5 | 2 |

| 2 | 5 | 0 | 6 | 6 | 3 | 7 | 0 | 4 | 1 | 5 | 2 |

| 3 | 5 | 1 | 3 | 6 | 3 | 7 | 1 | 4 | 0 | 5 | 2 |

| 4 | 1 | 7 | 2 | 6 | 4 | 7 | 1 | 3 | 0 | 5 | 2 |

先ほど説明した例は、**RC4ストリーム暗号**の水増しバージョンに過ぎない。実際のRC4ストリーム暗号は、8バイトではなく256バイト長の**S**配列と、1バイトから8バイトではなく1バイトから256バイトまでのキーを持つ。鍵の配列とキーストリームは、すべて256バイト長の**S**配列を考慮して生成される。計算は非常に複雑になるが、原理は同じである。同じ鍵[14,48,9]を使用し、標準的なRC4暗号を使用すると、平文メッセージ「SOUP」は16進数で67 02 ed dfとして暗号化される。

鍵ストリームが平文メッセージや暗号文とは無関係に更新されるストリーム暗号は、**同期ストリーム暗号**である。鍵ストリームは鍵にのみ依存する。鍵ストリームは平文や暗号文とは無関係であるため、RC4が同期ストリーム暗号の一例であることは明らかです。シフト暗号、ヴィジェネール暗号、ワンタイムパッドなど、前章で紹介した原始的なストリーム暗号はすべて同期型である。

対照的に、**非同期ストリーム暗号**は、鍵と暗号文の前の要素の両方によって生成されるキーストリームを持つ。このタイプの暗号は**自己同期型暗号**とも呼ばれる。

重要なことは、RC4で生成されたキーストリームはワンタイムパッドとして 扱われるべきであり、次回から全く同じ方法でキーストリームを生成することは できないということである。毎回キーを変更するのではなく、キーと**nonce**を組み合わせてバイトストリームを生成するのが現実的な解決策である。

## 128ビット・キーのAES

<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

前章で述べたように、国立標準技術研究所（NIST）は1997年から2000年にかけて、新しい対称暗号の標準を決めるコンペを開催した。その結果、**Rijndael暗号**が最優秀作品に選ばれた。この名前はベルギーの考案者であるヴィンセント・ライメンとジョアン・デーメンの名前をもじったものである。

Rijndael暗号は**ブロック暗号**で、つまりコアとなるアルゴリズムがあり、鍵の長さやブロックの大きさを変えて使うことができる。そのため、暗号化スキームを構築するために異なる動作モードで使用することができます。

NISTコンペティションの委員会は、128ビットのブロックサイズと128ビット、192ビット、256ビットのいずれかの鍵長を必要とするRijndael暗号の制限バージョンを**Advanced Encryption Standard (AES)**の一部として採用した。この制限されたバージョンのRijndael暗号は、複数の動作モードで使用することもできる。この標準の仕様は、**Advanced Encryption Standard (AES)**として知られているものである。

AESの中核であるRijndael暗号がどのように機能するかを示すために、128ビットの鍵で暗号化するプロセスを説明する。鍵のサイズは、暗号化の各ブロックで行われるラウンド数に影響する。128ビットの鍵の場合、10ラウンドが必要である。192ビットと256ビットでは、それぞれ12ラウンドと14ラウンドとなる。

加えて、AESは**ECB-mode**で使用されると仮定する。これは説明を少し簡単にし、Rijndaelアルゴリズムには関係ない。確かに、ECBモードは決定論的暗号化につながるため、実際には安全ではない。AESで最もよく使われる安全なモードは**CBC**（Cipher Block Chaining）である。

鍵を$K_0$とする。ここで$M_i$は128ビットの平文メッセージの一部を表し、$C_i$は128ビットの暗号文の一部を表す。平文がブロックサイズで均等に分割できない場合、最後のブロックの平文にパディングが追加される。

*図1：128ビット鍵のAES-ECB*。

![Figure 1: AES-ECB with a 128-bit key](assets/Figure5-1.webp "Figure 1: AES-ECB with a 128-bit key")

Rijndael暗号化方式では、128ビットのテキストブロックはそれぞれ10ラウンドを経る。このため、ラウンドごとに別々のラウンド鍵が必要になる（$K_1$から$K_{10}$まで）。K_1$から$K_{10}$は、元の128ビット鍵$K_0$から**鍵拡張アルゴリズム**を用いて各ラウンドごとに生成される。従って、暗号化するテキストの各ブロックには、元の鍵$K_0$と10個のラウンド鍵を 使うことになる。暗号化が必要な128ビットの平文ブロックごとに、同じ11個の鍵が使われることに 注意。

キー展開アルゴリズムは長く複雑だ。このアルゴリズムに目を通したところで、教訓的な効果はほとんどない。お望みであれば、自分で鍵拡張アルゴリズムに目を通すことができる。ラウンド鍵が生成されると、Rijndael暗号は最初の128ビットブロックの平文$M_1$を操作する。では、この手順を説明しよう。

*図2：Rijndael暗号による$M_1$の操作。

**第0ラウンド


- M_1$ と $K_0$ を XOR して $S_0$ を生成する。

---
**n = {1,...,9}に対してnラウンド:**.


- S_{n-1}$ と $K_n$ の XOR
- バイト置換
- シフト行
- ミックス・コラム
- S$ と $K_n$ を XOR して $S_n$ を生成する。

---
**第10ラウンド


- S_9$ と $K_{10}$ の XOR
- バイト置換
- シフト行
- S$ と $K_{10}$ を XOR して $S_{10}$ を生成する。
- s_{10}$ = $c_1$.

### 第0戦

Rijndael暗号のラウンド0は簡単である。128ビットの平文と秘密鍵のXOR演算によって配列$S_0$が生成される。つまり


- S_0 = M_1  \oplus K_0$.

### 第1戦

ラウンド1では、まず配列$S_0$とラウンド鍵$K_1$をXOR演算で結合する。これにより、$S$の新しい状態が生成される。

次に、**バイト置換**演算が$S$の現在の状態に対して実行される。これは、16バイトの$S$配列の各バイトを取り出し、**RijndaelのS-box**と呼ばれる配列からのバイトで置換することによって動作する。各バイトは固有の変換を持ち、結果として$S$の新しい状態が生成される。RijndaelのS-boxを*図3*に示す。

*図3：RijndaelのS-Box*。

| 00｜01｜02｜03｜04｜05｜06｜07｜08｜09｜0a｜0b｜0c｜0d｜0e｜0f

| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

| 00｜63｜7c｜77｜7b｜f2｜6b｜6f｜c5｜30｜01｜67｜2b｜fe｜d7｜ab｜76

| 10 | ca | 82 | c9 | 7d | fa | 59 | 47 | f0 | ad | d4 | a2 | af | 9c | a4 | 72 | c0 |



| 30｜04｜c7｜23｜c3｜18｜96｜05｜9a｜07｜12｜80｜e2｜eb｜27｜b2｜75

| 40｜09｜83｜2c｜1a｜1b｜6e｜5a｜a0｜52｜3b｜d6｜b3｜29｜e3｜2f｜84

| 50｜53｜d1｜00｜ed｜20｜fc｜b1｜5b｜6a｜cb｜be｜39｜4a｜4c｜58｜cf

| 60｜d0｜ef｜aa｜fb｜43｜4d｜33｜85｜45｜f9｜02｜7f｜50｜3c｜9f｜a8

| 70｜51｜a3｜40｜8f｜92｜9d｜38｜f5｜bc｜b6｜da｜21｜10｜ff｜f3｜d2｜。

| 80｜cd｜0c｜13｜ec｜5f｜97｜44｜17｜c4｜a7｜7e｜3d｜64｜5d｜19｜73｜｜｜の4本



| a0｜e0｜32｜3a｜0a｜49｜06｜24｜5c｜c2｜d3｜ac｜62｜91｜95｜e4｜79

| b0｜e7｜c8｜37｜6d｜8d｜d5｜4e｜a9｜6c｜56｜f4｜ea｜65｜7a｜ae｜08｜｜｜｜の4種類。

| c0｜ba｜78｜25｜2e｜1c｜a6｜b4｜c6｜e8｜dd｜74｜1f｜4b｜bd｜8b｜8a

| d0｜70｜3e｜b5｜66｜48｜03｜f6｜0e｜61｜35｜57｜b9｜86｜c1｜1d｜9e

| e0｜e1｜f8｜98｜11｜69｜d9｜8e｜94｜9b｜1e｜87｜e9｜ce｜55｜28｜df

| f0｜8c｜a1｜89｜0d｜bf｜e6｜42｜68｜41｜99｜2d｜0f｜b0｜54｜bb｜16

このS-Boxは、Rijndael暗号で抽象代数、特に**ガロア体**が活躍する場所の一つである。

まず、00からFFまでの各バイト要素を8ビットベクトルとして定義します。このような各ベクトルは**ガロア体GF(2^8)**の要素で、モジュロ演算の既約多項式は$x^8 + x^4 + x^3 + x + 1$です。この仕様のガロア場は、**Rijndaelの有限体**とも呼ばれる。

次に、フィールド内の可能性のある各要素について、**Nyberg S-Box**と呼ばれるものを作成する。このボックスでは、各バイトがその**乗法的逆**にマップされる（つまり、それらの積が1に等しくなるように）。次に、**アフィン変換**を用いて、これらの値をNyberg S-boxからRijndaelのS-boxにマッピングします。

S**配列に対する3番目の操作は、**shift rows**操作である。これは**S**の状態を取り、16バイトのすべてを行列にリストする。行列の充填は左上から始まり、上から下へ、そして列が充填されるたびに1列右へ、そして上へとシフトしていくことで行われる。

S**の行列が構築されると、4つの行がシフトされる。行目はそのまま。行目は左に1つ移動する。3行目は左に2つ移動する。4行目は3つ左に移動する。この処理の例を*図4*に示す。上に**S**の元の状態を示し、その下にシフト行操作後の結果を示す。

*図4：シフト・ローの操作



|------|------|------|------|

| 59 | ef | 09 | 82 |

| 97｜01｜b0｜cc





|------|------|------|------|

| ef｜09｜82｜59｜｜の3つ。

| b0 | cc | 97 | 01 |

| 21 | D4 | 72 | 04 |

第4のステップでは、**ガロア場**が再び登場する。始めに、**S**行列の各列は、*図5*に見られる4×4行列の列と掛け合わされる。しかし、これは通常の行列の乗算ではなく、**既約多項式**、$x^8 + x^4 + x^3 + x + 1$をモジュロしたベクトルの乗算である。結果のベクトル係数はバイトの各ビットを表す。

*図5：ミックス・カラム・マトリックス

| 02 | 03 | 01 | 01 |

|------|------|------|------|







S**行列の最初の列と上記の4×4行列を掛け合わせると、*図6*の結果が得られる。

*図6：最初の列の乗算：*。

$$
\begin{matrix}
02 \cdot F1 + 03 \cdot EF + 01 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 02 \cdot EF + 03 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 01 \cdot EF + 02 \cdot B0 + 03 \cdot 21 \\
03 \cdot F1 + 01 \cdot EF + 01 \cdot B0 + 02 \cdot 21
\end{matrix}
$$

次のステップとして、行列のすべての項を多項式にする必要がある。例えば、F1は1バイトを表し、$x^7 + x^6 + x^5 + x^4 + 1$となり、03は1バイトを表し、$x + 1$となる。

すべての乗算は、**モジュロ** $x^8 + x^4 + x^3 + x + 1$ で実行される。この結果、列の4つのセルそれぞれに4つの多項式が足される。これらの足し算を**モジュロ2**すると、4つの多項式になります。これらの多項式はそれぞれ**S**の8ビット文字列、つまり1バイトを表している。図6*の行列でこれらの計算を行うのは大変なので、ここでは省略する。

最初の列が処理されると、**S**行列の他の3列も同じように処理される。最終的には、16バイトの行列ができあがり、これを配列に変換することができる。

最終段階として、配列**S**とラウンド・キーを再び**XOR**演算で結合する。これによって$S_1$の状態が生成される。つまり


- S_1 = S \oplus K_0$.

### 第2ラウンドから第10ラウンド

第2ラウンドから第9ラウンドまでは、第1ラウンドの繰り返しである。最終ラウンドは、**列を混ぜる**ステップが省かれていることを除けば、これまでのラウンドとよく似ている。つまり、ラウンド10は以下のように実行される：


- S_9 K_{10}$.
- バイト置換
- シフト行
- S_{10} = K_{10}$.

これで状態$S_{10}$は暗号文の最初の128ビットである$C_1$に設定される。残りの128ビットの平文ブロックを進むと、完全な暗号文**C**が得られる。

### Rijndael暗号の操作

Rijndael暗号に見られるさまざまな操作の理由は何ですか？

詳細は省くが、暗号化方式は混乱と拡散を引き起こす程度に基づいて評価される。暗号化方式が**混乱**の度合いが高い場合、暗号文が平文と大きく異なって見えることを意味する。暗号化スキームの**拡散**度が高い場合、平文にどんな小さな変更を加えても、劇的に異なる暗号文が生成されることを意味する。

Rijndael暗号の背後にある操作の理由は、高度な混乱と拡散の両方を生み出すことである。混乱はバイト置換操作によって生じ、拡散はシフト行操作とミックス列操作によって生じる。

# 非対称暗号

<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

## 鍵の配布と管理の問題

<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

対称暗号と同様、非対称暗号も秘密と認証の両方を確保するために使用できる。対照的に、非対称暗号方式では秘密鍵と公開鍵の2つの鍵を用いる。

ここではまず、非対称暗号の発見、特にその発見に拍車をかけた問題から話を始める。次に、暗号化と認証のための非対称スキームがどのように機能するかについて、高レベルで議論する。ハッシュ関数は、非対称認証方式を理解する上で鍵となるものであり、第4章で説明したハッシュベースのメッセージ認証コードなど、他の暗号的な文脈でも関連性がある。

___

ボブは、北米で数百万人の顧客を持つスポーツ用品のオンライン小売店、Jim's Sporting Goodsで新しいレインコートを買いたいとする。これは彼にとって初めての買い物で、クレジットカードを使いたいと考えています。そこで、ボブはまずJim's Sporting Goodsのアカウントを作り、住所やクレジットカード情報などの個人情報を送信する必要がある。その後、レインコートを購入するために必要な手続きを行います。

ボブとジムズ・スポーティング・グッズは、インターネットがオープンな通信システムであることを考慮し、このプロセスを通じて通信の安全性を確保したいと考えるだろう。例えば、潜在的な攻撃者がボブのクレジットカードと住所の詳細を確認できないようにし、潜在的な攻撃者がボブの購入を繰り返したり、ボブに代わって偽のものを作ったりできないようにする。

前章で議論したような高度な認証暗号化スキームを使えば、確かにボブとジム・スポーツ・グッズ社との間の通信を安全にすることができる。しかし、そのようなスキームを実装するには、明らかに現実的な障害がある。

このような現実的な障害を説明するために、対称暗号のツールしか存在しない世界に住んでいたとしよう。では、ジム・スポーツ・グッズとボブは、安全な通信を確保するために何ができるだろうか？

このような状況では、セキュアな通信を行うにはかなりのコストがかかる。インターネットはオープンな通信システムであるため、鍵のセットをインターネット上で交換することはできない。したがって、BobとJim's Sporting Goodsの担当者は、直接会って鍵交換を行う必要がある。

一つの可能性は、ジム・スポーツ・グッズ社が特別な鍵交換場所を作り、そこでボブや他の新規顧客が安全な通信のための鍵一式を取り出せるようにすることである。しかし、これにはかなりの組織コストがかかり、新規顧客の購買効率は大幅に低下する。

あるいは、Jim's Sporting Goodsが信頼度の高い宅配便でボブにペアの鍵を送ることもできる。これはおそらく、鍵交換場所を手配するよりも効率的であろう。しかし、多くの顧客が1回か数回しか購入しない場合は特に、これでもかなりのコストがかかる。

次に、認証された暗号化のための対称的なスキームは、Jim's Sporting Goods社にすべての顧客のための別々の鍵セットを保存することを強いる。これは、何百万人という顧客はおろか、何千人という顧客にとっても重大な現実的課題である。

この後者の点を理解するために、ジムズ・スポーティング・グッズ社が各顧客に同じ鍵のペアを提供したとしよう。この場合、各顧客、あるいはこの鍵のペアを入手できる他の誰もが、ジムズ・スポーティング・グッズとその顧客との間のすべての通信を読み、操作することさえできる。これでは、通信に暗号をまったく使わないのと同じことだ。

一部の顧客だけに鍵のセットを繰り返すことさえ、セキュリティ上ひどい行為だ。潜在的な攻撃者は誰でも、そのスキームの特徴を悪用しようとする可能性がある(攻撃者は、ケルクホフの原則に従い、鍵以外のスキームのすべてを知っていると仮定されることを覚えておいてほしい)。

つまり、Jim's Sporting Goodsは、鍵のペアがどのように配布されるかにかかわらず、顧客ごとに鍵のペアを保存しなければならない。これは明らかにいくつかの現実的な問題を引き起こす。


- ジムズ・スポーティング・グッズは、数百万組のキーを、顧客ごとに1セットずつ保管しなければならない。
- これらの鍵は、ハッカーにとって格好の標的となるため、適切に保護されなければならない。セキュリティーが破られれば、特別な鍵交換場所で、あるいは宅配便で、コストのかかる鍵交換を繰り返す必要がある。
- ジムズ・スポーティング・グッズの顧客なら誰でも、一対の鍵を自宅で安全に保管しなければならない。紛失や盗難が発生すれば、鍵の交換を繰り返さなければならない。顧客はまた、他のオンライン・ショップや、インターネット上で通信や取引を希望する他の種類の事業体に対しても、このプロセスを経なければならない。

今述べた2つの主な課題は、1970年代後半までは非常に基本的な問題であった。これらはそれぞれ、**鍵分配問題**および**鍵管理問題**として知られていた。

もちろん、こうした問題は以前から存在し、しばしば頭痛の種となっていた。例えば軍隊では、安全な通信のための鍵が書かれた本を、多大なリスクとコストをかけて常に現場の職員に配布しなければならなかった。しかし、世界が長距離デジタル通信の時代へと移行しつつある中で、特に非政府組織にとっては、こうした問題はますます深刻になっていた。

これらの問題が1970年代に解決されていなければ、ジムズ・スポーティング・グッズでの効率的で安全なショッピングはおそらく存在しなかっただろう。実際、実用的で安全な電子メール、オンライン・バンキング、ショッピングを含む現代世界のほとんどは、おそらく遠い空想に過ぎなかっただろう。ビットコインに似たものも、まったく存在しなかったかもしれない。

では、1970年代に何が起こったのか？オンラインで即座に買い物ができ、ワールド・ワイド・ウェブを安全に閲覧できるのはなぜだろう？スマートフォンから世界中にビットコインを瞬時に送ることができるのはなぜだろう？

## 暗号技術の新たな方向性

<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

1970年代までに、鍵の配布と鍵管理の問題は、アメリカの学術暗号学者グループの注目を集めるようになった：ホイットフィールド・ディフィー、マーティン・ヘルマン、ラルフ・マークルである。同業者の大多数から厳しい懐疑的な目を向けられる中、彼らはあえてその解決策を考案した。

彼らのベンチャー精神の少なくとも主要な動機のひとつは、オープンなコンピューター通信が我々の世界に大きな影響を与えるだろうという先見性であった。ディフィーとヘルマンは1976年にこう述べている、

> コンピューター制御による通信ネットワークの発達は、世界の反対側にいる人々やコンピューター間の簡単で安価なコンタクトを約束し、ほとんどの郵便や多くの小旅行を電気通信に置き換えている。多くの用途において、これらの連絡は盗聴や不正なメッセージの注入に対して安全でなければならない。しかし現在、セキュリティ問題の解決は、通信技術の他の分野に比べてかなり遅れている。 *現代の暗号技術は、その使用によってシステム利用者に深刻な不便を強いることになり、遠隔処理の利点の多くを排除してしまうという点で、要求を満たすことができない* [1] 。
ディフィー、ヘルマン、マークルの粘り強さは実を結んだ。彼らの成果が最初に発表されたのは、1976年にディフィーとヘルマンが発表した "New Directions in Cryptography "という論文である。その中で彼らは、鍵の配布と鍵管理の問題に対処する2つの独創的な方法を提示した。

つまり、安全でない通信チャネル上で1つ以上の共通鍵を交換するためのルールセットである。このプロトコルは、現在では*Diffie-Helmann鍵交換*または*Diffie-Helmann-Merkle鍵交換*として知られている。[2]

Diffie-Helmann鍵交換では、2つの当事者はまずインターネットのような安全でないチャネルで、ある情報を公に交換する。その情報に基づいて、両者は安全な通信のための共通鍵（または共通鍵のペア）を独自に作成する。両者が独自に鍵を作成する一方で、公開された情報を共有することで、この鍵作成プロセスが両者にとって同じ結果をもたらすことが保証される。

重要なのは、誰もが安全でないチャネル上で当事者によって公に交換される情報を観察できる一方で、情報交換に関与する2つの当事者だけが、そこから共通鍵を作成できるということだ。

もちろん、これは完全に直感に反する。どうして2つの当事者はある情報を公に交換し、そこから2人だけが共通鍵を作成できるのだろうか。情報交換を監視している他の誰もが、なぜ同じ鍵を作成できないのだろうか。

もちろん、それはいくつかの美しい数学に依存している。ディフィー・ヘルマン鍵交換は、トラップドア付きの一方向性関数を介して機能する。この2つの用語の意味を順番に説明しよう。

ある関数 $f(x)$ とその結果 $f(a) = y$ が与えられたとする。a$ と $f(x)$ が与えられたとき、値 $y$ を計算するのは簡単だが、 $y$ と $f(x)$ が与えられたとき、値 $a$ を計算するのは計算不可能であるとき、 $f(x)$ は **一方向性関数** であると言う。一方向性関数**という名前は、もちろん、このような関数は一方向にしか計算できないことに由来する。

一方向性関数の中には、**トラップドア**と呼ばれるものがある。y$と$f(x)$だけから$a$を計算するのは現実的に不可能だが、$y$から$a$を計算可能にする情報$Z$がある。この情報$Z$を**トラップドア**と呼ぶ。トラップドアを持つ一方向性関数を**トラップドア関数**と呼ぶ。

ここでは、ディフィー・ヘルマン鍵交換の詳細については触れない。しかし、基本的に各参加者は何らかの情報を作成し、その一部は公開され、一部は秘密のままである。そして各パーティーは、自分の秘密情報と相手から共有された公開情報を用いて秘密鍵を作成する。そして奇跡的に、両者が同じ秘密鍵を持つことになる。

Diffie Helmann鍵交換において、2つの当事者間で公開された共有情報のみを観察するいかなる当事者も、これらの計算を複製することはできない。そのためには、2つの当事者の一方から秘密情報を得る必要がある。

1976年の論文で発表されたDiffie-Helmann鍵交換の基本バージョンはあまり安全ではないが、基本プロトコルの洗練されたバージョンは今日でも確かに使われている。最も重要なことは、トランスポート層セキュリティ・プロトコルの最新バージョン（バージョン1.3）のすべての鍵交換プロトコルは、本質的に1976年にDiffieとHellmanによって発表されたプロトコルの強化バージョンであるということである。トランスポート層セキュリティ・プロトコルは、ウェブ・コンテンツを交換するための標準であるハイパーテキスト・トランスファー・プロトコル（http）に従ってフォーマットされた情報を安全に交換するための主流プロトコルである。

重要なのは、Diffie-Helmann鍵交換は非対称暗号方式ではないということだ。厳密に言えば、対称鍵暗号の領域に属する。しかし、Diffie-Helmann鍵交換も非対称暗号も、トラップドアを持つ一方向性数論的関数に依存しているため、一般的に両者は一緒に議論される。

ディフィーとヘルマンが1976年の論文で、鍵の配布と管理の問題を解決するために提示した2つ目の方法は、もちろん非対称暗号だった。

Diffie-Hellman鍵交換の説明とは対照的に、彼らは非対称暗号方式がどのように構築されうるかという一般的な輪郭を示したに過ぎない。彼らは、このようなスキームにおいて合理的なセキュリティに必要な条件を具体的に満たす一方向性関数を提供しなかった。

しかし、非対称スキームの実用的な実装は、その1年後に3人の異なるアカデミックな暗号学者と数学者によって発見された：Ronald Rivest、Adi Shamir、Leonard Adlemanである。[3]彼らが導入した暗号システムは、**RSA暗号システム**（彼らの名字にちなんで）として知られるようになった。

非対称暗号（およびDiffie Helmann鍵交換）で使用されるトラップドア関数は、すべて2つの主要な**計算困難な問題**に関連している：素因数分解と離散対数の計算。

**素因数分解**は、その名の通り、整数をその素因数に分解する必要がある。RSA問題は、素因数分解に関連する暗号システムとして最も有名な例である。

離散対数問題**は、環状群で起こる問題である。ある環状群の生成子が与えられたとき、その生成子から群内の別の要素を生成するのに必要な一意な指数を計算する必要がある。

離散対数に基づくスキームは、主に2種類の巡回群に依存している。整数の乗法群と楕円曲線上の点を含む群である。New Directions in Cryptography」で紹介されているオリジナルのDiffie Helmann鍵交換は、整数の巡回乗法群で動作する。ビットコインのデジタル署名アルゴリズムと最近導入されたシュナー署名スキーム（2021年）は、どちらも特定の楕円曲線巡回群に対する離散対数問題に基づいている。

次に、非対称な設定における秘密と認証のハイレベルな概要に目を向ける。しかし、その前に簡単な歴史的メモをしておく必要がある。

政府通信本部（GCHQ）で働く英国の暗号学者と数学者のグループが、数年前に上記の発見を独自に行っていたことは、今ではもっともらしく思える。このグループはジェームス・エリス、クリフォード・コックス、マルコム・ウィリアムソンで構成されていた。

彼ら自身とGCHQの説明によれば、1969年に公開鍵暗号の概念を最初に考案したのはジェームズ・エリスだった。その後、1973年にクリフォード・コックスがRSA暗号システムを発見し、1974年にマルコム・ウィリアムソンがディフィー・ヘルマン鍵交換の概念を発見したとされている[4]。[4]しかし、彼らの発見は、GCHQで行われた作業の秘密性を考慮し、1997年まで明らかにされなかったとされている。

**注：**。

[1] Whitfield Diffie and Martin Hellman, "New directions in cryptography," _IEEE Transactions on Information Theory_ IT-22 (1976), pp.

[2] Ralph Merkleもまた、"Secure communications over insecure channels", _Communications of the Association for Computing Machinery_, 21 (1978), 294-99で鍵交換プロトコルについて論じている。Merkleは、実際にはDiffieとHellmanの論文よりも前にこの論文を提出したが、後に発表された。Merkleの解決策は、Diffie-Hellmanのものとは異なり、指数関数的に安全というわけではない。

[3] Ron Rivest, Adi Shamir, and Leonard Adleman, "A method for obtaining digital signatures and public-key cryptosystems", _Communications of Association for Computing Machinery_, 21 (1978), pp.

[4] これらの発見の歴史については、サイモン・シン著『コードブック』（フォーサーズ・エステート、ロンドン、1999年）の第6章が詳しい。

## 非対称暗号化と認証

<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

ボブとアリスの助けを借りた**非対称暗号化**の概要を*図1*に示す。

K_P$の "P "は "public "を表し、$K_S$の "S "は "secret "を表す。K_P$のPは「公開」、$K_S$のSは「秘密」である。この配布プロセスの詳細については、もう少し後で触れる。しかし今は、ボブも含めて誰でもアリスの公開鍵 $K_P$ を安全に入手できると仮定する。

ある時点で、ボブはアリスにメッセージ$M$を書きたい。このメッセージには機密情報が含まれているので、アリス以外の誰にも内容を知られたくない。そこで、ボブはまず $K_P$ を使ってメッセージ $M$ を暗号化する。そして、出来上がった暗号文 $C$ をアリスに送り、アリスは $C$ を $K_S$ で復号して元のメッセージ $M$ を生成する。

*図1：非対称暗号※1

![Figure 1: Asymmetric encryption](assets/Figure6-1.webp "Figure 1: Asymmetric encryption")

ボブとアリスの通信を盗聴する敵は$C$を観測できる。また、$K_P$と暗号化アルゴリズム$E(˶cdot)$も知っている。しかし重要なのは、この情報では攻撃者が暗号文$C$を復号することはできないということである。復号化には特に$K_S$が必要であるが、攻撃者はこの$K_S$を持っていない。

対称暗号方式は一般的に、平文メッセージを有効に暗号化できる攻撃者に対して安全である必要がある（選択暗号文攻撃セキュリティとして知られている）。しかし、攻撃者や他の誰でもがそのような有効な暗号文を作成できるようにするという明確な目的を持って設計されているわけではない。

これは、攻撃者を含む誰もが有効な暗号文を生成できるようにすることを全目的とする非対称暗号化方式とは対照的である。したがって、非対称暗号化方式は**複数アクセス暗号**と呼ぶことができる。

何が起こっているかをよりよく理解するために、ボブが電子的にメッセージを送る代わりに、物理的な手紙を秘密裏に送りたいと考えたとしよう。秘密保持を確実にする一つの方法は、アリスが安全な南京錠をボブに送るが、それを開ける鍵は持っておくことである。手紙を書いた後、ボブは手紙を箱に入れ、アリスの南京錠で閉じることができる。そして、鍵のかかった箱をメッセージと一緒に、鍵を持っているアリスに送ることができる。

ボブは南京錠に鍵をかけることができるが、南京錠が本当に安全なものであれば、ボブはもちろん、箱を盗み見た他のいかなる人物も南京錠を外すことはできない。鍵を持っているアリスだけが鍵を開け、ボブの手紙の中身を見ることができる。

非対称暗号化方式とは、大雑把に言えば、このプロセスのデジタル版である。南京錠は公開鍵に似ており、南京錠の鍵は秘密鍵に似ている。しかし、南京錠はデジタルなので、アリスが彼女に秘密のメッセージを送りたい人に南京錠を配布するのはずっと簡単で、コストもそれほどかからない。

非対称設定における認証には、**デジタル署名**を使用する。これらは、対称設定におけるメッセージ認証コードと同じ機能を持つ。図2*にデジタル署名の概要を示す。

ボブはまず、公開鍵($K_P$)と秘密鍵($K_S$)からなる鍵のペアを作り、公開鍵を配布する。認証されたメッセージをアリスに送りたいとき、ボブはまず自分のメッセージ $M$と秘密鍵から**デジタル署名** $D$を作る。ボブは次に、アリスに自分のメッセージとデジタル署名を送る。

アリスはメッセージ、公開鍵、電子署名を**検証アルゴリズム**に 挿入する。このアルゴリズムは有効な署名に対しては**true**を、無効な署名に対しては **false**を生成する。

デジタル署名とは、その名の通り、手紙や契約書などに書かれた署名のデジタル版である。実際には、デジタル署名の方がはるかに安全である。書面での署名は、その真偽が確認されないことが多いため、努力次第で偽造することが可能である。しかし、安全なデジタル署名は、安全なメッセージ認証コードと同様に、**本質的に偽造不可能**である。つまり、安全なデジタル署名スキームでは、秘密鍵を持っていない限り、誰も検証手順を通過したメッセージの署名を作成することはできない。

*図2：非対称認証*の場合

![Figure 2: Asymmetric authentication](assets/Figure6-2.webp "Figure 2: Asymmetric authentication")

非対称暗号化と同様に、デジタル署名とメッセージ認証コードの間にも興味深い対比が見られる。後者の場合、検証アルゴリズムは、安全な通信を知る当事者の一方だけが採用できる。これは秘密鍵を必要とするからである。しかし、非対称の設定では、誰でもボブが作成したデジタル署名$S$を検証することができる。

これらにより、デジタル署名は非常に強力なツールとなる。例えば、法的な目的で検証可能な契約書への署名を作成する基礎となる。上のやり取りでボブが契約書に署名をした場合、アリスはメッセージ$M$、契約書、署名$S$を裁判所に見せることができる。そして裁判所は、ボブの公開鍵を使って署名を検証することができる。[5]

別の例を挙げると、デジタル署名は、安全なソフトウェアやソフトウェア・アップデートの配布において重要な役割を果たす。この種の公的な検証可能性は、メッセージ認証コードだけでは決して作り出すことができない。

デジタル署名の力を示す最後の例として、ビットコインを考えてみよう。ビットコインに関する最も一般的な誤解の一つは、特にメディアにおいて、取引が暗号化されているというものだ。そうではなく、ビットコインの取引はセキュリティを確保するためにデジタル署名を用いている。

ビットコインは、未使用トランザクション出力（または**UTXO's**）と呼ばれるバッチで存在します。あるビットコインアドレスで、2ビットコインずつの支払いを3回受けたとします。技術的には、あなたはそのアドレスに6ビットコインを持っていません。その代わりに、あなたはそのアドレスに関連する暗号化問題によってロックされた2ビットコインの3つのバッチを持っています。どのような支払いでも、取引に必要な量に応じて、これらのバッチの1つ、2つ、または3つすべてを使用することができます。

未使用の取引出力に対する所有権の証明は、通常、1つ以上のデジタル署名によって示される。ビットコインが正確に機能するのは、未使用の取引出力に対する有効なデジタル署名は、その作成に必要な秘密情報を所有していない限り、作成することが計算上不可能だからである。

現在、ビットコインの取引には、取引に使用された未使用の取引出力の出所など、ネットワークの参加者が検証する必要があるすべての情報が透過的に含まれている。Moneroのようないくつかの代替暗号通貨がそうであるように）そのような情報の一部を隠して検証を可能にすることは可能であるが、これはまた特別なセキュリティリスクを生み出す。

デジタル署名と、デジタルで取り込んだ書面による署名をめぐって混乱が生じることがある。後者の場合、あなたが書いた署名の画像をキャプチャし、雇用契約書などの電子文書に貼り付ける。しかし、これは暗号的な意味でのデジタル署名ではない。後者は、秘密鍵を所有することによってのみ生成できる長い数字に過ぎない。

共通鍵の設定と同様に、非対称暗号化と認証スキームを併用することもできる。同様の原則が適用される。まず第一に、暗号化と電子署名には異なる秘密鍵と公開鍵のペアを使うべきである。さらに、まずメッセージを暗号化し、次にそれを認証する。

重要なことは、多くのアプリケーションにおいて、非対称暗号は通信プロセス全体を通じて使用されるわけではないということである。むしろ、実際に通信を行う当事者間で対称鍵*を交換するためにのみ使用されるのが一般的である。

例えば、オンラインで商品を購入する場合などがそうだ。ベンダーの公開鍵を知っていれば、デジタル署名されたメッセージを送ることができ、その真正性を確認することができる。これに基づいて、対称鍵を交換するための複数のプロトコルのいずれかに従って、安全に通信することができる。

前述のアプローチが頻繁に使われる主な理由は、非対称暗号は対称暗号に比べ、特定のセキュリティ・レベルを生み出す効率がはるかに低いからだ。これが、公開暗号の次に共通鍵暗号が必要な理由のひとつである。加えて、対称鍵暗号は、コンピューター・ユーザーが自分自身のデータを暗号化するような特定の用途においては、より自然である。

では、電子署名と公開鍵暗号化は、鍵の配布と鍵管理の問題に具体的にどのように対処するのだろうか。

答えは一つではない。非対称暗号は道具であり、その道具を使う方法は一つではないからだ。しかし、先ほどのJim's Sporting Goodsの例で、この問題が一般的にどのように対処されるかを示してみよう。

手始めに、Jim's Sporting Goodsはおそらく**認証局**（公開鍵の配布をサポートする組織）にアプローチするだろう。認証局はJim's Sporting Goodsの詳細を登録し、公開鍵を付与する。そして、Jim's Sporting Goods社に、**TLS/SSL証明書**として知られる、Jim's Sporting Goods社の公開鍵が認証局自身の公開鍵を使ってデジタル署名された証明書を送付する。このようにして、認証局は、特定の公開鍵が確かにJim's Sporting Goodsのものであることを確認する。

TLS/SSL証明書のこのプロセスを理解する鍵は、一般的にJim's Sporting Goodsの公開鍵がコンピュータのどこかに保存されていることはありませんが、公認の認証局の公開鍵は実際にブラウザやオペレーティングシステムに保存されているということです。これらは**ルート証明書**と呼ばれるものに格納されています。

したがって、Jim's Sporting GoodsがTLS/SSL証明書を提供する場合、ブラウザまたはオペレーティングシステムでルート証明書を介して認証局のデジタル署名を確認することができます。署名が有効であれば、証明書上の公開鍵が本当にJim's Sporting Goodsのものであることを比較的確実にすることができます。これに基づいて、Jim's Sporting Goodsとの安全な通信のためのプロトコルを設定するのは簡単です。

Jim's Sporting Goodsにとって、鍵の配布は大幅に簡素化された。鍵の管理も大幅に簡素化された。Jim's Sporting Goods社は、何千もの鍵を保管する代わりに、SSL証明書の公開鍵に署名を行うための秘密鍵を保管するだけでよい。顧客がJim's Sporting Goodsのサイトを訪れるたびに、この公開鍵から安全な通信セッションを確立できる。顧客はまた、（オペレーティング・システムとブラウザにある公認認証局の公開鍵以外の）情報を保存する必要もない。

**注：**。

[5]第1章で取り上げたもう一つのテーマである否認防止を達成しようとするスキームは、その根底にデジタル署名を含む必要がある。

## ハッシュ関数

<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

ハッシュ関数は暗号の世界ではどこにでもある。対称方式でも非対称方式でもなく、それ自体が暗号の範疇に入る。

第4章で、ハッシュベースの認証メッセージを作成する際にハッシュ関数に出会っ た。ハッシュ関数はデジタル署名の文脈でも重要である：デジタル署名は通常、実際の（暗号化された）メッセージではなく、何らかの（暗号化された）メッセージのハッシュ値に対して行われる。このセクションでは、ハッシュ関数についてより詳しく説明する。

ハッシュ関数の定義から始めよう。ハッシュ関数**とは、任意のサイズの入力を受けて固定長の出力を返す、効率的に計算可能な関数のことである。

暗号学的ハッシュ関数**とは、暗号学の応用に有用なハッシュ関数のことである。暗号ハッシュ関数の出力は通常、**ハッシュ**、*ハッシュ値**、または**メッセージ・ダイジェスト**と呼ばれる。

暗号技術の文脈では、「ハッシュ関数」は通常、暗号ハッシュ関数を指す。ここからはその慣例を採用する。

よく使われるハッシュ関数の例は、**SHA-256**（セキュア・ハッシュ・アルゴリズム256）である。入力のサイズ（例えば15ビット、100ビット、10,000ビット）に関係なく、この関数は256ビットのハッシュ値を生成します。以下に、SHA-256関数の出力例をいくつか示します。

「こんにちは`185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969`

"52398":`a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90`

「暗号は楽しい`3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c`

すべての出力は、16進数（16進数の各桁は2進数の4桁で表すことができる）で書き出された正確に256ビットである。つまり、SHA-256関数にトールキンの「指輪物語」を挿入したとしても、出力は256ビットのままだ。

SHA-256のようなハッシュ関数は、暗号技術において様々な目的で使用されている。ハッシュ関数にどのような性質が求められるかは、特定のアプリケーションの文脈に大きく依存する。暗号技術において一般的にハッシュ関数に求められる特性は主に2つある：[6]

1.	耐衝突性

2.	隠れる

ハッシュ関数$H$は、$x$と$y$の2つの値から、$x$がy$をneqし、$H(x)=H(y)$となるような値を見つけることが不可能な場合、**衝突に強い**という。

衝突に強いハッシュ関数は、例えばソフトウェアの検証において重要である。Bitcoin Core 0.21.0（ビットコインのネットワークトラフィックを処理するサーバーアプリケーション）のWindowsリリースをダウンロードしたいとします。そのソフトウェアの正当性を検証するために、あなたが取らなければならない主な手順は以下の通りである：

1.	まず、デジタル署名を検証できるソフトウェア（Kleopetraなど）に、1人以上の貢献者のBitcoin Coreの公開鍵をダウンロードしてインポートする必要がある。これらの公開鍵は [こちら](https://github.com/bitcoin/bitcoin/blob/master/contrib/builder-keys/keys.txt) にあります。複数の貢献者の公開鍵で Bitcoin Core ソフトウェアを検証することを推奨します。

2.	次に、インポートした公開鍵を検証する必要がある。少なくとも、インポートした公開鍵が他のさまざまな場所で公開されているものと同じかどうかを確認する必要がある。例えば、インポートした公開鍵の持ち主の個人的なウェブ・ページ、ツイッター・ページ、Githubページなどを参照するとよいだろう。通常、この公開鍵の比較は、フィンガープリントと呼ばれる公開鍵の短いハッシュを比較することで行われる。

3.	次に、Bitcoin Coreの実行ファイルを[ウェブサイト](www.bitcoincore.org)からダウンロードする必要がある。Linux、Windows、MACオペレーティングシステム用のパッケージが用意されている。

4.	次に、2つのリリースファイルを見つけなければなりません。最初のファイルには、ダウンロードした実行ファイルの公式SHA-256ハッシュと、リリースされた他のパッケージのハッシュが含まれています。もう1つのリリースファイルには、パッケージのハッシュとともに、リリースファイルに対する様々な貢献者の署名が含まれています。これらのリリースファイルは両方ともBitcoin Coreのウェブサイトにあります。

5.	 次に、Bitcoin Coreのウェブサイトからダウンロードした実行ファイルのSHA-256ハッシュを自分のコンピュータで計算する必要がある。そして、この結果を実行ファイルの公式パッケージのハッシュと比較する。それらは同じであるべきだ。

6.	最後に、公式パッケージのハッシュを使ったリリースファイル上の電子署名の1つ以上が、本当にインポートした1つ以上の公開鍵に対応しているかどうかを検証する必要があります（Bitcoin Coreのリリースは、必ずしも全員が署名しているとは限りません）。これはKleopetraのようなアプリケーションで行うことができます。

このソフトウェア検証プロセスには、主に2つの利点がある。第一に、Bitcoin Coreのウェブサイトからダウンロードする際に送信エラーがなかったことを保証します。第二に、攻撃者がビットコインコアのウェブサイトをハッキングしたり、トラフィックを傍受したりして、修正された悪意のあるコードをダウンロードさせることができなかったことを保証します。

上記のソフトウェア検証プロセスは、具体的にどのようにこれらの問題から守っているのだろうか？

インポートした公開鍵を真面目に検証したのであれば、これらの鍵が実際に彼らのものであり、漏洩していないことをかなり確信できる。デジタル署名が存在的に偽造不可能であることを考えると、あなたは、これらの貢献者だけがリリースファイル上の公式パッケージのハッシュに対してデジタル署名を行うことができたことを知っています。

ダウンロードしたリリースファイルの署名がチェックアウトされたとする。ダウンロードしたWindows実行ファイルについて、ローカルで計算したハッシュ値を、適切に署名されたリリースファイルに含まれるハッシュ値と比較することができます。ご存知のようにSHA-256ハッシュ関数はコリオンに強いので、あなたの実行ファイルは公式の実行ファイルと全く同じであることを意味する。

次に、ハッシュ関数に共通する2つ目の性質に目を向けてみよう： **隠蔽**である。任意のハッシュ関数$H$は、非常に大きな範囲からランダムに選ばれた$x$に対して、$H(x)$だけを与えられたときに$x$を見つけることが実行不可能である場合、隠蔽の性質を持つという。

下に、私が書いたメッセージのSHA-256出力を示す。十分なランダム性を確保するため、メッセージの最後にはランダムに生成された文字列が含まれている。SHA-256が隠蔽性を持っていることを考えると、誰もこのメッセージを解読することはできないだろう。


- `b194221b37fa4cd1cfce15aaef90351d70de17a98ee6225088b523b586c32ded`

しかし、SHA-256が弱体化するまで、私はあなたを放置するつもりはない。私が書いたオリジナルのメッセージは以下の通りである：


- "これは非常にランダムなメッセージである。この冒頭部分はそうではありませんが、非常に予測不可能なメッセージを確実にするために、比較的ランダムな文字で終わらせます。XLWz4dVG3BxUWm7zQ9qS"。

隠蔽特性を持つハッシュ関数が使われる一般的な方法は、パスワード管理である（この用途では耐衝突性も重要である）。フェイスブックやグーグルなどのまともなオンライン・アカウント・ベースのサービスでは、アカウントへのアクセスを管理するためにパスワードを直接保存することはない。代わりに、パスワードのハッシュを保存するだけだ。ブラウザでパスワードを入力するたびに、まずハッシュが計算される。そのハッシュのみがサービス・プロバイダーのサーバーに送られ、バックエンドのデータベースに保存されているハッシュと比較される。非表示特性は、攻撃者がハッシュ値からパスワードを復元できないようにするのに役立ちます。

ハッシュによるパスワード管理は、もちろん、ユーザーが実際に難しいパスワードを選んだ場合にのみ機能する。隠蔽性は、xが非常に大きな範囲からランダムに選ばれることを前提としている。1234"、"mypassword"、またはあなたの誕生日などのパスワードを選択しても、本当のセキュリティは得られません。一般的なパスワードとそのハッシュの長いリストが存在し、攻撃者があなたのパスワードのハッシュを入手した場合、これを活用することができます。この種の攻撃は、**辞書攻撃**として知られています。攻撃者があなたの個人情報をいくつか知っている場合、彼らはまた、いくつかの情報に基づいた推測を試みるかもしれません。したがって、長くて安全なパスワードが常に必要です（できれば、パスワード・マネージャの長くてランダムな文字列）。

アプリケーションによっては、耐衝突性と隠蔽性を併せ持つハッシュ関数が必要になることもある。しかし、常にというわけではない。例えば、我々が議論したソフトウェア検証プロセスでは、ハッシュ関数が衝突耐性を示すことだけが要求され、隠蔽は重要ではない。

暗号技術においてハッシュ関数に求められる主な特性は耐衝突性と隠蔽性であるが、アプリケーションによっては他の特性も望まれる場合がある。

**注：**。

[6] 「隠蔽」という用語は一般的な言葉ではなく、特にArvind Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller, and Steven Goldfeder, *Bitcoin and Cryptocurrency Technologies*, Princeton University Press (Princeton, 2016), Chapter 1から引用している。

# RSA暗号システム

<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

## 因数分解問題

<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

対称暗号はほとんどの人が直感的に理解できるが、非対称暗号はそうではない。前節までのハイレベルな説明には慣れているはずだが、一方向性関数とはいったい何なのか、非対称暗号を構築するためにどのように使われるのか、おそらく疑問に思っていることだろう。

この章では、非対称暗号にまつわる謎の一端を解き明かすべく、具体例であるRSA暗号をより深く掘り下げていく。最初のセクションでは、RSA暗号の基礎となっている因数分解問題を紹介する。その後、数論からいくつかの重要な結果を取り上げる。最後のセクションでは、これらの情報をまとめてRSA問題を説明し、これが非対称暗号方式の作成にどのように利用できるかを説明する。

私たちの議論にこのような深みを加えるのは簡単なことではない。数論的な定理や命題をかなり導入する必要があるからだ。しかし、数学に気を取られてはいけない。この議論に取り組むことで、非対称暗号の根底にあるものについての理解度が大幅に向上し、価値ある投資となるでしょう。

では、まず因数分解の問題に移ろう。

___

a$と$b$のように、2つの数を掛け合わせるときは、必ず$a$と$b$のことを**因子**、結果を**積**と呼ぶ。ある数 $N$ を2つ以上の因数の掛け算に書き換えることを、**因数分解** または **因数分解** といいます。[1] これを必要とする問題を**因数分解問題**と呼ぶことができる。

約2500年前、ギリシャの数学者アレクサンドリアのユークリッドが整数の因数分解に関する重要な定理を発見した。これは一般に**一意因数分解定理**と呼ばれ、次のように述べられている：

**定理1**.1より大きい整数$N$はすべて素数であるか、素因数の積で表せる。

この文の後半部分が意味するのは、1より大きい任意の非素数整数$N$を、素数の掛け算として書き出すことができるということだけである。以下に、素因数の積として書かれた非素数の整数の例をいくつか示す。


- $18 = 2 ⊖cdot 3 ⊖cdot 3 = 2 ⊖cdot 3^2$ である。
- 84 = 2 ㏄ 2 ㏄ 3 ㏄ 7 = 2^2 ㏄ 3 ㏄ 7$ である。
- 

上の3つの整数については、$N$だけ与えられても、素因数の計算は比較的簡単である。一番小さい素数、つまり2から始めて、整数 $N$ がそれで何回割り切れるかを調べます。次に、$N$が3、5、7で割り切れるかどうかを調べます。整数$N$が素数だけの積として書けるようになるまで、この作業を続ける。

例えば、整数84を考えてみよう。その素因数を決定するプロセスを以下に示す。各ステップで、残っている最小の素因数（左側）を取り出し、因数分解する余りの項を決定する。余りの項も素数になるまで続ける。各ステップで、84の現在の因数分解が右端に表示される。


- 素因数分解 = 2: 余りの項 = 42 ($84 = 2 ˶= 42$)
- 素因数分解＝2：余りの項＝21（$84＝2 ㏄2 ㏄21$)
- 素因数分解＝3：余り項＝7（$84＝2 ㏄2 ㏄3 ㏄7$)
- 7は素数なので、結果は $2 ㏄ 2 ㏄ 3 ㏄ 7$、つまり $2^2 ㏄ 3 ㏄ 7$となります。

ここで $N$ が非常に大きいとする。N$を素因数分解するのは難しいだろうか。

それは$N$に依存する。例えば、$N$が50,450,400だとする。この数値は威圧的に見えるが、計算はそれほど複雑ではなく、手で簡単にできる。上と同じように、2から始めて、どんどん進めていけばいい。以下は、上記と同じような方法で、この処理の結果を見たものである。


- 2: 25,225,200ドル (50,450,400ドル = 2 ㏄ 25,225,200ドル)
- 2: 12,612,600ドル (50,450,400ドル = 2^2 12,612,600ドル)
- 2: 6,306,300ドル (50,450,400ドル = 2^3 6,306,300ドル)
- 2：3,153,150ドル（50,450,400ドル＝2^4 ㎟3,153,150$)
- 2：1,576,575ドル（50,450,400ドル＝2^5 ㎟1,576,575ドル）
- 3: 525,525ドル (50,450,400ドル = 2^5 ╱3 ╱525,525ドル)
- 3: 175,175 ($50,450,400 = 2^5 ㎤ 3^2 ㎤ 175,175$)
- 5: 35,035（50,450,400ドル = 2^5 ㏄ 3^2 ㏄ 5 ㏄ 35,035$)
- 5: 7,007 ($50,450,400 = 2^5 ㎤ 3^2 ㎤ 5^2 ㎤ 7,007$)
- 7：1,001（50,450,400ドル＝2^5 ㎤3^2 ㎤5^2 ㎤7 ㎤1,001$)
- 7：143 （$50,450,400 = 2^5 ㎤ 3^2 ㎤ 5^2 ㎤ 7^2 ㎤ 143$)
- 11: 13 ($50,450,400 = 2^5 ╱ 3^2 ╱ 5^2 ╱ 7^2 ╱ 11 ╱ 13$)
- 13は素数なので、結果は $2^5 ㎤ 3^2 ㎤ 5^2 ㎤ 7^2 ㎤ 11 ㎤ 13$ となる。

この問題を手作業で解決するには時間がかかる。もちろんコンピュータなら、ほんの一瞬でこの問題を解くことができる。実際、コンピュータは非常に大きな整数の因数分解さえ、ほんの一瞬でやってのける。

ただし、例外もある。まず、非常に大きな素数を2つ無作為に選ぶとする。これには$p$と$q$というラベルをつけるのが一般的なので、ここではその慣例を採用する。

具体化のために、$p$と$q$がどちらも1024ビットの素数であり、表現するためには少なくとも1024ビットを必要とする（だから最初のビットは1でなければならない）としよう。ということは、例えば37は素数の1つにはなり得ない。確かに37を1024ビットで表すことはできる。しかし、37を表すのにこれだけのビットは必要ない。37は6ビット以上の文字列で表すことができる。(6ビットなら、37は$100101$となる）。

上記の条件で選んだ場合、$p$と$q$がどれだけ大きいかを理解することが重要である。例として、表現に少なくとも1024ビットを必要とするランダムな素数を以下に選んでみた。


- 14,752,173,874,503,595,484,930,006,383,670,759,559,764,562,721,397,166,747,289,220,945,457,932,666,751,048,198,854,920,097,085,690,793,755,254,946,188,163,753,506,778,089,706,699,671,722,089,715,624,760,049,594,106,189,662,669,156,149,028,900,805,928,183,585,427,782,974,951,355,515,394,807,209,836,870,484,558,332,897,443,152,653,214,483,870,992,618,171,825,921,582,253,023,974,514,209,142,520,026,807,636,589

ここで、素数$p$と$q$をランダムに選んだ後、それらを掛け合わせて整数$N$を得たとする。したがって、後者の整数は2048ビットの数であり、その表現には少なくとも2048ビットを必要とする。p$や$q$よりもずっとずっと大きい。

コンピュータに$N$だけを与えて、$N$の1024ビットの素因数分解を2つ求めるとする。コンピュータが$p$と$q$を発見する確率は極めて小さい。現実的には不可能と言っていい。これは、たとえスーパーコンピュータを使ったとしても、あるいはスーパーコンピュータのネットワークを使ったとしても同じである。

手始めに、コンピュータが1024ビットの数を循環させ、その都度素数かどうか、$N$の因数かどうかをテストして問題を解こうとしたとする。そうすると、テストされる素数の集合は約$1.265 ㏄ 10^{305}$となる。[2]

地球上のすべてのコンピュータを使って、この方法で1024ビットの素数を見つけてテストさせたとしても、$N$の素因数をうまく見つけられる確率は10億分の1であり、宇宙の年齢よりもはるかに長い計算期間を必要とする。

さて、実際には、コンピュータは今述べたような大まかな手順よりもうまくやることができる。コンピュータがより速く因数分解を行うために適用できるアルゴリズムがいくつか存在する。しかし、重要なのは、これらのより効率的なアルゴリズムを用いても、コンピュータのタスクはまだ計算不可能だということである。[3]

重要なことは、今述べた条件下での因数分解の難しさは、素因数を計算するための計算効率の良いアルゴリズムが存在しないという仮定にかかっているということである。効率的なアルゴリズムが存在しないことを実際に証明することはできない。とはいえ、この仮定は非常に妥当なものである。数百年にわたる広範な努力にもかかわらず、我々はまだそのような計算効率の良いアルゴリズムを発見していない。

したがって、因数分解問題は、ある条件下では難問であると考えるのが妥当である。具体的には、$p$と$q$が非常に大きな素数のとき、その積$N$を計算することは難しくないが、$N$だけを与えて因数分解することは事実上不可能である。

**注：**。

[1] 因数分解は、数以外の数学的対象を扱う場合にも重要である。例えば、 $x^2 - 2x + 1$ のような多項式を因数分解するのに役立ちます。ここでは、数、特に整数の因数分解だけを取り上げます。

[2] **素数定理**によると、$N$以下の素数の数は約$N/ln(N)$である。つまり、長さ1024ビットの素数の数は、次のようにして近似できる：

$$ \frac{2^{1024}}{\ln(2^{1024})} - \frac{2^{1023}}{\ln(2^{1023})} $$

...これは約10^{305}$の約1.265倍に相当する。

[離散対数問題についても同様である。それゆえ、非対称暗号は対称暗号よりもはるかに大きな鍵で動作するのである。

## 数論的結果

<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

残念ながら、因数分解問題は非対称暗号方式には直接使えない。しかし、より複雑だが関連する問題、RSA問題を使うことができる。

RSA問題を理解するためには、数論からいくつかの定理と命題を理解する必要がある。本節では、(1)Nの次数、(2)Nの逆変換性、(3)オイラーの定理、の3つのサブセクションに分けて説明する。

この3つのサブセクションの内容の一部は、すでに*第3章*で紹介している。しかし、ここでは便宜上、その内容を再掲する。

### N

整数 $a$ は、整数 $N$ との間の最大公約数が 1 であるとき、**共素** または**相対素** である。

例えば、$a = 18$、$N = 37$の場合を考えてみよう。これらは明らかに共素数である。これに対して、$a = 42$で$N = 16$の場合を考えてみよう。これらは明らかに共素数ではない。どちらも2で割り切れる数で、1より大きい。

ここで、$N$の次数を次のように定義する。N$が1以上の整数であるとする。N$の次数**とは、各共素数$a$に対して次の条件が成り立つような、$N$を持つすべての共素数の数である。

例えば、$N = 12$とすると、上記の条件を満たす共素数は1、5、7、11だけである。よって、12の次数は4に等しい。

N$が素数だとする。このとき、$N$より小さく1以上の整数は、$N$と共素数である。これには、次の集合のすべての要素が含まれる： ${1,2,3,...,N - 1}$.よって、$N$が素数のとき、$N$の次数は$N - 1$である。これは命題1で述べられ、$phi(N)$は$N$の位数を表す。

**命題1**.N$が素数のとき、$phi(N) = N - 1$ 。

N$が素数でないとする。このとき、**オイラーのファイ関数**を使って次数を計算することができる。小さな整数の次数を計算するのは比較的簡単ですが、オイラーのファイ関数は大きな整数に対して特に重要になります。オイラーのファイ関数の命題を以下に示す。

**定理 2**.N$を$p_1^{e_1}とする。\p_cdot p_2^{e_2} とする。\p_i^{e_i} とする。\ここで、集合${p_i}}$は$N$のすべての明確な素因数からなり、各$e_i$は$p_i$が$N$に対して何回出現するかを示す。このとき

p_1^{e_1 - 1}.\p_2^{e_2 - 1} ￤p_n^{e_n - 1} ￤p_n^{e_n - 1\(p_n - 1)$$.

**定理2**は、任意の非素数$N$をその明確な素因数に分解すれば、$N$の次数を簡単に計算できることを示している。

例えば、$N = 270$とする。これは明らかに素数ではない。N$を素因数分解すると、$2 ㎤ 3^3 ㎤ 5$という式が得られる。オイラーのファイ関数によれば、$N$の次数は次のようになる：

N） = 2^{1 - 1\2cdot (2 - 1) + 3^{3 - 1}.\Γ (3 - 1) + 5^{1 - 1｝\5 - 1} ＝ 1 ㏄ 1 ＋ 9 ㏄ 2 ＋ 1 ㏄ 4 ＝ 1 ＋ 18 ＋ 4 ＝ 23$.

次に、$N$が2つの素数$p$と$q$の積であるとする。 **このとき、上の定理2**によれば、$N$の次数は次のようになる：

$$p^{1 - 1}\p^{1 - 1} ￤ q^{1 - 1}\q^{1 - 1} = (p - 1)  \cdot (q - 1)$$.

これは特にRSA問題にとって重要な結果であり、以下の**命題2**で述べられている。

**命題2**である。N$が2つの素数$p$と$q$の積であるとき、$N$の次数は積$(p - 1)⊖(q - 1)$である。

説明のために、$N = 119$とする。この整数は2つの素数、すなわち7と17に因数分解できる。したがって、オイラーのファイ関数によれば、119の位数は次のようになる：

phi(119) = (7 - 1) ╱ (17 - 1) = 6 ╱ 16 = 96$$.

言い換えれば、整数119は1から119までの範囲に96個の共素数を持つ。実際、この集合には1から119までのすべての整数が含まれ、それらは7と17の倍数ではない。

以降、$N$の次数を決める共素数の集合を$C_N$とする。N = 119$ の例では、$C_{119}$ の集合は大きすぎて、全部を列挙することはできない。しかし、いくつかの要素は次の通りである：

C_{119} = \{1, 2, ㋑ 6, 8 ㋑ 13, 15, 16, 18 ㋑ 33, 35 ㋑ 96}$$.

### Nのモジュロによる反転性

ある整数 $a$ が **可逆モジュロ N** であると言えるのは、 $a Γcdot b Γcdot N = 1 Γcdot N$ となるような整数 $b$ が少なくとも1つ存在するときである。このような整数$b$は、$N$モジュロによる漸化式で$a$の**逆**(または**乗法的逆**)と呼ばれる。

例えば、$a = 5$、$N = 11$とする。5 ㎤ b ㎤ 11 ㎤＝ 1 ㎤ 11$ となるように、5 をかけることができる整数はたくさんある。例えば、20 と 31 という整数を考えてみよう。これらの整数がどちらも 11 を減じるための 5 の逆数であることは簡単にわかる。


- 5 ╱20 ╱11 = 100 ╱11 = 1 ╱11$ ╱20 ╱11 = 1
- 5 Ⅼ31 Ⅼ11 = 155 Ⅼ11 = 1 Ⅼ11$ $

5が11のモジュロで多くの逆行列を持つのに対して、11より小さい5の正の逆行列は1つしか存在しないことを示すことができる。実際、これは今回の例に限ったことではなく、一般的な結果である。

**命題3**。整数 $a$ が $N$ 変数の可逆整数であるとき、 $a$ の逆行列が $N$ より小さいのは、 $a$ のちょうど1つだけでなければならない（だから、 $a$ の唯一の逆行列は、集合 ${1, Γdots, N - 1}$ から来ていなければならない）。

命題3**の$a$の一意な逆数を$a^{-1}$としよう。a=5$、$N=11$のとき、$a^{-1}=9$であることがわかります。

a$の他の逆数を11倍することでも、$a^{-1}$の値9を求めることができる。例えば、$20 ㎤＝31 ㎤＝9 ㎤となります。だから、整数 $a > N$ が $N$ 変数で反転可能なときはいつでも、 $a \mod N$ も $N$ 変数で反転可能でなければならない。

a$の逆数が$N$をmoduloとして漸化式に存在するとは限らない。例えば、$a=2$、$N=8$とする。b$ 、具体的には $a^{-1}$ には、 $2 ㏄ b ㏄ = 1 ㏄ 8$ となるようなものはない。これは、$b$はどの値でも必ず2の倍数になるので、8で割っても余りが1になることはないからです。

ある整数 $a$ が、与えられた $N$ に対して逆数を持つかどうかを知るには、どうすればいいのだろうか。上の例で気づいたかもしれないが、2と8の最大公約数は1より大きい、つまり2である：

**命題4**.a$ と $N$ の最大公約数が 1 であるとき（つまり、それらが共約数であるとき）に限り、 $N$ を減じた整数 $a$ の逆数が存在し、特に $N$ より小さい一意な正の逆数が存在する。

a = 5$, $N = 11$ の場合は、$5 ㎤ 9 ㎤ 11 = 45 ㎤ 11 = 1 ㎤ 11$ であることから、$a^{-1} = 9$ となる。逆も成り立つことに注意しましょう。つまり、 $a = 9$ かつ $N = 11$ のとき、 $a^{-1} = 5$ となる。

### オイラーの定理

RSA問題に移る前に、もう一つ重要な定理、すなわち**オイラーの定理**を理解する必要がある。オイラーの定理とは次のようなものである：

**定理3**.つの整数 $a$ と $N$ が共素数であるとする。このとき、$a^{{phi(N)} \mod N = 1 Γmod N$である。

これは驚くべき結果だが、最初は少し混乱する。それを理解するために例を挙げてみよう。

a = 5$ と $N = 7$ とする。これらはオイラーの定理が求める通り、確かに共素数である。7が素数であることから、7の位数は6に等しいことがわかる（**命題1**参照）。

オイラーの定理は、$5^6 ㎟が$1 ㎟に等しくなければならない、と言っているのである。以下は、これが本当に正しいことを示す計算である。


- 5^6 ╱ 7 = 15,625 ╱ 7 = 1 ╱モッド N$.

整数7は15,624を合計2,233回割る。したがって、16,625を7で割った余りは1である。

次に、オイラーのファイ関数、**定理2**を用いて、以下の**命題5**を導くことができる。

**命題5**である。任意の正の整数$a$と$b$に対して、$phi(a \cdot b) = ˶(a) ˶(b)$ である。

なぜそうなるかは示さない。ただ、**命題2**で述べたように、$p$と$q$が素数のとき、$phi(p \cdot q) = \phi(p) \cdot (q - 1)$ = (p - 1) \cdot (q - 1)$となることで、この命題の証拠をすでに見ていることに注意してください。

オイラーの定理と**命題5**は重要な意味を持つ。例えば、$a$と$N$が共素数の次の式を見てみよう。


- a^{2 \cdot \phi(N)}  \mod N = a^{2 \cdot a^{2 \cdot a^{2 \cdot a^{2 \cdot a^{2 }  \mod N = 1 Γ
- a^{phi(N) + 1}\(N)＝a^{φ(N)}φ(N)＝1φ(N)＝aφ(N)
- a^{8 \cdot \phi(N) + 3}  \mod N = a^{8 \cdot \phi(N)} ╱a^3 ╱mod N = 1 ╱a^3 ╱mod N = a^3 ╱mod N$.

したがって、オイラーの定理と**命題5**の組み合わせにより、単純に多くの式を計算することができる。一般的には、**命題6**のようにまとめることができる。

**命題6a^x ゙N = a^{x ゙mod ゙phi(N)}$ である。

さて、トリッキーな最後のステップですべてをまとめなければならない。

N$が集合$C_N$の要素を含む次数$phi(N)$を持つように、整数$phi(N)$も次数と共素数の集合を持たなければならないことがわかる。ここで、$phi(N) = R$とする。すると、$phi(R)$にも値があり、共素数の集合$C_R$があることがわかる。

ここで、集合 $C_R$ から整数 $e$ を選ぶとする。この整数 $e$ は $R$ より小さい一意な正の逆数を1つだけ持つことが **命題3** からわかっている。つまり、 $e$ は集合 $C_R$ から一意な逆数を1つだけ持つ。この逆数を $d$ と呼ぶことにする。逆数の定義から考えると、 $e \cdot d = 1 \mod R$ となる。

この結果を使って、元の整数$N$について声明を出すことができる。これは**命題7**にまとめられている。

**命題 7**.ここで、 $e ⊖d ⊖mod ⊖phi(N) = 1 ⊖mod ⊖phi(N)$ とする。このとき、集合 $C_N$ の任意の要素 $a$ に対して、 $a^{e \cdot d  \mod ˶(N)} = a^{1 ˶(N)} = a ˶mod N$ である必要がある。

これで、RSA問題を明確に記述するのに必要な数論的結果はすべて揃った。

## RSA暗号システム

<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>

これでRSA問題を述べる準備ができた。p$、$q$、$N$、$fi(N)$、$e$、$d$、$y$からなる変数集合を作ったとする。この集合を$Pi$と呼ぶ。以下のように作成する：

1.同じ大きさの2つのランダムな素数$p$と$q$を生成し、その積$N$を計算せよ。

2.N$の次数$phi(N)$を、次の積$(p - 1) \cdot (q - 1)$で計算せよ。

3.e＞2$で、$ephi(N)$より小さく、かつ$ephi(N)$とコプライムであるものを選ぶ。

4.e ⊖d ⊖mod⊖phi(N) = 1$ として $d$ を計算する。

5.N$より小さく、$N$のコプライムであるランダムな値$y$を選ぶ。

RSA問題は、$N$、$e$、$y$という$Pi$に関する情報の一部だけを与えられながら、$x^e=y$となる$x$を求める問題である。p$と$q$が非常に大きい場合、典型的には1024ビットの大きさが推奨されるが、RSA問題は難しいと考えられている。前述の議論から、なぜそうなるかはおわかりいただけるだろう。

x^e ゙ N = y ゙ N$ のときの $x$ を簡単に計算するには、$y^d ゙ N$ を計算すればよい。y^d Γ N=x Γ N$ は次の計算でわかる：

y^d  \mod N = x^{e Γcdot d} Γmod N = x^{e Γcdot d\y^mod N = x^{e Γcdot d Γcdot d} Γcdot N = x^{1 Γcdot Γcdot d} Γcdot N = x Γcdot N $$.

問題は、問題で与えられていないため、値$d$がわからないことである。したがって、 $y^d \mod N$ を直接計算して $x \mod N$ を出すことはできない。

しかし、 $e \cdot d \mod \phi(N) = 1 \mod \phi(N)$ ということが分かっているので、 $N$ の次数 $phi(N)$ から間接的に $d$ を計算できるかもしれない。しかし、この問題では、仮定によって$phi(N)$の値も与えられない。

最後に、素因数 $p$ と $q$ を使って間接的に次数を計算することで、最終的に $d$ を計算することができた。しかし、前提として、$p$と$q$の値も我々には与えられていない。

厳密に言えば、RSA問題の中の因数分解問題が難しいとしても、RSA問題も難しいとは証明できない。つまり、RSA問題を解くには、因数分解以外の方法があるかもしれない。しかし、RSA問題の中の因数分解問題が難しいのであれば、RSA問題自体も難しいというのが一般的な考え方である。

RSA問題が本当に難しいなら、トラップドアを持つ一方向性関数が生成される。この関数は$f(g) = g^e \mod N$である。f(g)$の知識があれば、特定の$g = x$に対する値$y$を誰でも簡単に計算できる。しかし、値 $y$ と関数 $f(g)$ を知っているだけでは、特定の値 $x$ を計算することは現実的に不可能である。ただし、トラップドアと呼ばれる情報 $d$ が与えられた場合は例外である。この場合は、$y^d$を計算するだけで$x$を求めることができる。

RSA問題を説明するために具体的な例を挙げてみよう。数字が扱いにくくなるので、上記の条件で難しいと思われるRSA問題を選ぶことはできない。その代わり、この例はRSA問題が一般的にどのように機能するかを説明するためのものである。

手始めに、13と31の2つの素数を無作為に選んだとする。つまり、$p = 13$と$q = 31$である。この2つの素数の積$N$は403に等しい。403の次数は簡単に計算できる。これは $(13 - 1) ㏄ (31 - 1) = 360$ と等価である。

次に、RSA問題のステップ3で指示されているように、2より大きく360より小さい360の共素数を選ぶ必要がある。この値をランダムに選ぶ必要はない。仮に103を選ぶとしよう。これは103との最大公約数が1なので、360の共素数である。

ステップ4では、$103 ㏄d ㏄mod 360 = 1$となるような値$d$を計算する必要がある。N$の値が大きい場合、手計算でこれを行うのは容易ではない。そのため、**拡張ユークリッドアルゴリズム**と呼ばれる手順を使う必要がある。

ここでは手順を示しませんが、 $e = 103$ のとき、値 7 が得られます。103と7の組の値が、確かに一般条件 $e \cdot d \mod \phi(n) = 1$ を満たしていることは、以下の計算で確認できます。


- 103 ㏄ 7 ㏄ 360 ＝ 721 ㏄ 360 ＝ 1 ㏄ 360$.

重要なのは、命題4*を考えると、$d$が1から360の間の他の整数では、$103 ㏄d = 1 ㏄mod 360$という結果は得られないということである。さらに、この命題は、$e$に異なる値を選ぶと、$d$に異なる一意な値が得られることを意味しています。

RSA問題のステップ5では、403の小さい共素数である正の整数$y$を選ぶ必要がある。仮に $y = 2^{103}$ とする。2を103で指数化すると、次のようになる。


- $2^{103}\403$ = 10,141,204,801,825,835,211,973,625,643,008

この例のRSA問題は次のようになる：N = 403$, $e = 103$, $y = 349 ゙mod 403$ が与えられている。ここで、$x^{103} = 349 ⊖403$となるような$x$を計算しなければならない。つまり、103 で指数化する前の元の値が 2 であることを求めなければならない。

d = 7$ とわかっていれば、$x$ を計算するのは（少なくともコンピュータにとっては）簡単だ。その場合は、次のように $x$ を決めればいい。


- x = y^7  \mod 403 = 349^7 ∵mod 403 = 630,634,881,591,804,949 ∵mod 403 = 2 ∵mod 403$.

問題は、$d = 7$という情報が与えられていないことです。もちろん、$103 ㎤ d = 1 ㎤ 360$であることから$d$を計算することはできます。問題は、 $N の次数 = 360$ という情報も与えられていないことです。最後に、 $(p - 1) \cdot (q - 1)$ という積を計算して、403 の次数を計算することもできます。しかし、 $p = 13$, $q = 31$ ということも知らされていません。

もちろん、この例では素数が大きくないので、コンピュータは比較的簡単にRSA問題を解くことができる。しかし、素数が非常に大きくなると、事実上不可能な作業に直面する。

ここまで、RSA問題、それが難しい条件、そしてその基礎となる数学を紹介してきた。これらは非対称暗号にどのように役立つのだろうか。具体的には、ある条件下でのRSA問題の難しさを、どのようにして暗号化方式や電子署名方式に変えることができるのだろうか？

一つのアプローチは、RSA問題を取り上げ、素直な方法でスキームを構築することである。例えば、$p$と$q$が十分に大きいことを保証するために、RSA問題で説明したような変数$Pi$の集合を生成したとする。公開鍵を$(N, e)$とし、この情報を世界と共有する。上述したように、$p$, $q$, $phi(n)$と$d$の値は秘密にする。実際には$d$が秘密鍵である。

C_N$の要素であるメッセージ$m$を送りたい人は、単に次のように暗号化すればよい：この暗号文$c$はRSA問題の値$y$と等価である。

同じ方法でデジタル署名方式を作ろうとするかもしれない。ある人に電子署名$S$を付けたメッセージ$m$を送りたいとする。S = m^d \mod N$とし、そのペア$(m,S)$を相手に送ればよい。S^e ゙mod N = m ゙mod N$かどうかを調べるだけで、誰でも電子署名を検証できる。しかし、攻撃者は$d$を持っていないため、メッセージに有効な$S$を作成するのは非常に困難である。

残念ながら、RSA問題というそれ自体難しい問題を暗号化するのは、それほど簡単ではない。素直な暗号化方式では、$N$の共素数をメッセージとして選ぶことしかできない。これでは可能なメッセージの数が少なく、標準的な通信には十分ではない。さらに、これらのメッセージはランダムに選択しなければならない。これはいささか非現実的である。最後に、2度選択されたメッセージは、全く同じ暗号文になります。これはどのような暗号化方式においても極めて望ましくないことであり、暗号化における安全性についての厳密な現代標準の概念にも合致しない。

私たちの素直なデジタル署名方式では、問題はさらに悪化する。このままでは、$N$の共素数を署名として選び、それに対応する元のメッセージを計算するだけで、どんな攻撃者でも簡単にデジタル署名を偽造できてしまう。これは明らかに、存在的な偽造不可能性の要件を破ることになる。

とはいえ、少し巧妙な複雑さを加えるだけで、RSA問題は安全な公開鍵暗号化方式や安全なデジタル署名方式を作るのに使うことができる。ここではそのような構成の詳細には立ち入らない。[4]しかし、重要なことは、このような複雑さを追加しても、これらのスキームが基づいている基本的なRSA問題は変わらないということである。

**注：**。

[4] 例えば、Jonathan Katz and Yehuda Lindell, _Introduction to Modern Cryptography_, CRC Press (Boca Raton, FL: 2015), pp.410-32 on RSA encryption and pp.444-41 for RSA digital signatureを参照。

# まとめ

<partId>e538fb79-bf28-40cd-a5c3-badf864d8567</partId>

## レビューと評価

<chapterId>366d6fd0-ceb2-4299-bf37-8c6dfcb681d5</chapterId>
<isCourseReview>true</isCourseReview>
 
## ファイナル・テスト

<chapterId>44882d2b-63cd-4fde-8485-f76f14d8b2fe</chapterId>
<isCourseExam>true</isCourseExam>

## まとめ

<chapterId>f1905f78-8cf7-5031-949a-dfa8b76079b4</chapterId>
<isCourseConclusion>true</isCourseConclusion>
