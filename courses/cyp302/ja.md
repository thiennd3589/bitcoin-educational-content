---
name: 形式的な暗号学への導入
goal: 暗号学の科学と実践に深く潜るための導入。
objectives:
  - ビール暗号と現代の暗号化方法を探求し、暗号学の基本的かつ歴史的な概念を理解する。
  - 数論、群、および体に深く潜り、暗号学の基礎となる主要な数学的概念を習得する。
  - RC4ストリーム暗号と128ビットキーを使用したAESを学び、対称暗号化アルゴリズムについて理解を深める。
  - RSA暗号システム、鍵配布、およびハッシュ関数を調査し、非対称暗号化を探究する。

---
# 暗号学への深い潜入

暗号学教育において、良い中間地点を提供する資料を見つけることは難しい。

一方で、数学、論理学、またはその他の形式的な分野に強い背景を持つ人々にしかアクセスできない長大で形式的な論文がある。他方で、少しでも好奇心がある人には多くの詳細を隠してしまう非常に高度な導入がある。

この暗号学への導入は、その中間地点を捉えることを目指している。暗号学に新しい人にとっては比較的挑戦的で詳細であるべきだが、典型的な基礎論文のような深い穴ではない。

+++

# 導入
<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## 短い説明
<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

この本は、暗号学の科学と実践への深い潜入を提供する。可能な限り、形式的な展開よりも概念的な展開に焦点を当てる。

> このコースは[JWBurgers's repo](https://github.com/JWBurgers/An_Introduction_to_Cryptography)に基づいています。すべての権利は彼にあります。コンテンツはまだ完成しておらず、JWburger'sが同意すれば、どのように統合できるかを示すためにここにあります。

### 動機と目的

暗号学教育において、良い中間地点を提供する資料を見つけることは難しい。

一方で、数学、論理学、またはその他の形式的な分野に強い背景を持つ人々にしかアクセスできない長大で形式的な論文がある。他方で、少しでも好奇心がある人には多くの詳細を隠してしまう非常に高度な導入がある。

この暗号学への導入は、その中間地点を捉えることを目指している。暗号学に新しい人にとっては比較的挑戦的で詳細であるべきだが、典型的な基礎論文のような深い穴ではない。

### 対象読者

開発者から知的好奇心旺盛な人まで、暗号学について表面的な理解以上を求めるすべての人にとって有用な本です。暗号学の分野をマスターすることが目標であれば、この本も良い出発点です。

### 読書ガイド

現在、この本には7章が含まれています。「暗号学とは何か？」（第1章）、「暗号学の数学的基礎 I」（第2章）、「暗号学の数学的基礎 II」（第3章）、「対称暗号」（第4章）、「RC4とAES」（第5章）、「非対称暗号」（第6章）、そして「RSA暗号システム」（第7章）。最終章「実践における暗号学」はまだ追加されます。これは、トランスポート層セキュリティ、オニオンルーティング、ビットコインの価値交換システムを含むさまざまな暗号学的アプリケーションに焦点を当てています。
数学の強いバックグラウンドを持っていない場合、この本で最も難しいトピックはおそらく数論です。第3章でその概要を提供しており、第5章のAESの解説や第7章のRSA暗号システムでも登場します。
この本のこれらの部分の形式的な詳細に本当に苦労している場合は、最初はそれらを高いレベルで読むことに落ち着くことをお勧めします。

### 謝辞

この本を形作る上で最も影響力のある書籍は、Jonathan KatzとYehuda Lindellの「_Introduction to Modern Cryptography_」、CRC Press（フロリダ州ボカラトン）、2015年です。Courseraで「Cryptography」というコースが利用可能です。

この本の概要を作成する上で役立った主な追加の情報源は、Simon Singhの「_The Code Book_」、Fourth Estate（ロンドン、1999年）; Christof PaarとJan Pelzlの「_Understanding Cryptography_」、Springer（ハイデルベルク、2010年）および[Paarによる本に基づいたコース「Introduction to Cryptography」](https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg); そしてBruce SchneierのApplied Cryptography、第2版、2015年（インディアナ州インディアナポリス：John Wiley & Sons）です。

これらの情報源から非常に具体的な情報と結果を引用するだけですが、ここで一般的な負債を認めたいと思います。

この導入後に暗号学に関するより高度な知識を求めたい読者には、KatzとLindellの本を強くお勧めします。CourseraのKatzのコースは、本よりもややアクセスしやすいです。

### 貢献

プロジェクトをサポートする方法に関するいくつかのガイドラインについては、[リポジトリ内の貢献ファイル](https://github.com/JWBurgers/An_Introduction_to_Cryptography/blob/master/Contributions.md)をご覧ください。

### 表記法

**キー用語:**

プライマーのキー用語は、太字で導入されます。例えば、Rijndael暗号のキー用語の導入は次のようになります：**Rijndael暗号**。

キー用語は、固有名詞であるか議論から明らかな意味でない限り、明確に定義されます。

定義は通常、キー用語の導入時に与えられますが、時には後の時点まで定義を残す方が便利な場合もあります。

**強調された単語やフレーズ:**

単語やフレーズはイタリック体で強調されます。例えば、「パスワードを覚えておいてください」は次のようになります：*パスワードを覚えておいてください*。

**形式的な表記法:**

形式的な表記法は主に変数、ランダム変数、および集合に関するものです。

* 変数：これらは通常、小文字の文字（例：「x」または「y」）で示されます。明確さのために時々大文字になることもあります（例：「M」または「K」）。
* ランダム変数：これらは常に大文字の文字（例：「X」または「Y」）で示されます。
* 集合：これらは常に太字の大文字（例：**S**）で示されます。

# 暗号学とは何か？
<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

## ビール暗号
<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>
暗号学の分野への探求を、その歴史の中でより魅力的で楽しいエピソードの一つであるビール暗号の話から始めましょう。[1]
私の意見では、ビール暗号の話は現実よりもフィクションである可能性が高いです。しかし、次のように起こったとされています。

1820年と1822年の冬に、トーマス・J・ビールという男性がバージニア州リンチバーグにあるロバート・モリスが経営する宿に滞在しました。ビールが2回目の滞在を終えた際、彼は貴重な書類が入った鉄の箱をモリスに預けました。

数ヶ月後、モリスは1822年5月9日付けのビールからの手紙を受け取りました。その手紙では鉄の箱の中身の大きな価値を強調し、モリスにいくつかの指示を関連付けていました：もしビールや彼の関係者が箱を請求しに来なかった場合、彼は手紙の日付からちょうど10年後（つまり、1832年5月9日）に箱を開けるべきです。箱の中には通常のテキストで書かれた書類がいくつかありますが、他のいくつかは「鍵がなければ理解できない」ものでした。この「鍵」は、1832年6月にビールの名前のない友人によってモリスに届けられることになっていました。

明確な指示にもかかわらず、モリスは1832年5月に箱を開けず、ビールの謎の友人もその年の6月には現れませんでした。1845年になってようやく宿屋の主人は箱を開けることに決めました。その中には、ビールと彼の関係者が西部で金と銀を発見し、それを宝石と共に安全のために埋めたことを説明するメモが入っていました。さらに、箱には3つの**暗号文**が含まれていました。つまり、秘密の**暗号鍵**やそれに伴うアルゴリズムがなければ解読できないコードで書かれたテキストです。この暗号文を解読するプロセスは**復号**と呼ばれ、暗号化するプロセスは**暗号化**と呼ばれます。（第3章で説明されているように、cipherという用語は様々な意味を持つことがあります。「ビール暗号」の名前では、暗号文を短縮しています。）

モリスが鉄の箱で見つけた3つの暗号文は、それぞれカンマで区切られた一連の数字で構成されています。ビールのメモによると、これらの暗号文は別々に宝の場所、宝の内容、そして宝の正当な相続人とその分け前のリストを提供します（後者の情報は、ビールと彼の関係者が箱を請求しに来なかった場合に関連します）。

モリスは20年間にわたって3つの暗号文を解読しようと試みました。鍵があれば簡単だったでしょう。しかし、モリスは鍵を持っておらず、元のテキスト、つまり暗号学で一般的に呼ばれる**平文**を回復する試みに成功しませんでした。

人生の終わりに近づいたモリスは、1862年に箱を友人に渡しました。この友人は後に1885年にJ.B. Wardという偽名でパンフレットを出版しました。それには箱の（推定される）歴史、3つの暗号文、そして彼が見つけた2番目の暗号文の解決策が含まれていました。（どうやら、各暗号文ごとに1つの鍵があり、モリスへの手紙でビールが当初示唆していたように、3つの暗号文すべてに作用する1つの鍵があるわけではないようです。）

*図2*以下で2番目の暗号文を見ることができます。[2] この暗号文の鍵はアメリカ独立宣言です。復号手順は、以下の2つのルールを適用することによります：
暗号文中の任意の数nについて、アメリカ独立宣言のn番目の単語を見つけ出し、見つけた単語の最初の文字で数nを置き換えます。

*図1: ビール暗号 No. 2*

![図1: ビール暗号 No. 2](assets/Figure1-1.webp "図1: ビール暗号 No. 2")

例えば、2番目の暗号文の最初の数は115です。独立宣言の115番目の単語は「instituted」なので、平文の最初の文字は「i」です。暗号文は単語の間隔や大文字化を直接示していません。しかし、最初の数単語を解読した後、平文の最初の単語が単純に「I」であったことを論理的に推測できます。（平文は「I have deposited in the county of Bedford.」というフレーズで始まります。）

解読後、2番目のメッセージは宝物（金、銀、宝石）の詳細な内容を提供し、それがバージニア州ベッドフォード郡に鉄の鍋に入れて岩で覆われて埋められていることを示唆しています。人々は良いミステリーが大好きなので、他の2つのビール暗号、特に宝の場所を記述しているものの解読に多大な努力が払われてきました。さまざまな著名な暗号学者もそれらに挑戦してきました。しかし、現時点では、他の2つの暗号文を解読できた人はいません。

**注釈:**

[1] 物語の良い要約については、Simon Singhの*The Code Book*、Fourth Estate（ロンドン、1999年）、pp. 82-99を参照してください。この物語の短編映画が2010年にAndrew Allenによって制作されました。「The Thomas Beale Cipher」という映画は[そのウェブサイト](http://www.thomasbealecipher.com/)で見ることができます。

[2] この画像はビール暗号のWikipediaページで利用可能です。

## 現代の暗号学
<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

ビール暗号のようなカラフルな物語は、私たちが暗号学と結びつけるもののほとんどです。しかし、現代の暗号学は、これらの歴史的な例と少なくとも4つの重要な点で異なります。

まず、歴史的に暗号学は**秘密性**（または機密性）にのみ関心を持っていました。[3] 暗号文は、ビール暗号の場合のように、特定の当事者のみが平文の情報を知ることができるように作成されました。暗号化スキームがこの目的をうまく果たすためには、鍵を持っている場合にのみ暗号文を解読することが可能であるべきです。

現代の暗号学は、秘密性だけでなく、より幅広いテーマに関心を持っています。これらのテーマには主に、(1) **メッセージの完全性**—つまり、メッセージが変更されていないことを保証すること、(2) **メッセージの真正性**—つまり、メッセージが特定の送信者から実際に送られたことを保証すること、および(3) **否認防止**—つまり、送信者が後になってメッセージを送ったことを偽って否定できないようにすること、が含まれます。[4]

したがって、心に留めておくべき重要な区別は、**暗号化スキーム**と**暗号スキーム**の間です。暗号化スキームは秘密性にのみ関心があります。暗号化スキームは暗号スキームですが、その逆は真ではありません。暗号スキームは、完全性、真正性、および否認防止を含む暗号学の他の主要なテーマも果たすことができます。
整合性と誠実性のテーマは、秘密保持と同じくらい重要です。現代の通信システムは、通信の整合性と誠実性に関する保証がなければ機能することができません。否認防止も重要な懸念事項です。例えばデジタル契約においてはそうですが、秘密保持、整合性、誠実性に比べて、暗号化アプリケーションで広く必要とされるわけではありません。

第二に、ベール暗号のような古典的な暗号化スキームは常に全ての関係者間で共有される一つの鍵を含んでいます。しかし、多くの現代の暗号化スキームは一つではなく、二つの鍵、つまり**プライベート**鍵と**パブリック鍵**を関与させます。前者はどのアプリケーションでもプライベートのままであるべきですが、後者は通常公知の情報です（したがって、それぞれの名前があります）。暗号化の領域では、パブリック鍵を使ってメッセージを暗号化し、プライベート鍵を使って復号化することができます。

全ての当事者が一つの鍵を共有するスキームを扱う暗号学の分野は**対称暗号化**として知られています。このようなスキームの単一の鍵は通常、**プライベート鍵**（または秘密鍵）と呼ばれます。プライベート鍵とパブリック鍵のペアが必要なスキームを扱う暗号学の分野は**非対称暗号化**として知られています。これらの分野は、それぞれ**プライベート鍵暗号化**と**パブリック鍵暗号化**としても言及されることがあります（ただし、パブリック鍵暗号化スキームにもプライベート鍵があるため、混乱を招くことがあります）。

1970年代後半の非対称暗号化の出現は、暗号学の歴史において最も重要な出来事の一つでした。これがなければ、Bitcoinを含むほとんどの現代の通信システムは不可能であったか、少なくとも非常に非現実的であったでしょう。

重要なことに、現代の暗号学は対称および非対称鍵暗号化スキームの研究だけではありません（それが分野の大部分を占めていますが）。例えば、暗号学はハッシュ関数や擬似乱数生成器も関心の対象であり、これらの原始的なものに基づいて対称または非対称鍵暗号化とは関係ないアプリケーションを構築することができます。

第三に、ベール暗号で使用されるような古典的な暗号化スキームは、科学よりも芸術でした。その知覚されたセキュリティは、主にその複雑さに関する直感に基づいていました。新しい攻撃が学習されたとき、または攻撃が特に深刻であった場合は完全に放棄されるまで、通常は修正されました。しかし、現代の暗号学は、暗号化スキームの開発と分析の両方に対する形式的で数学的なアプローチを持つ厳密な科学です。[5]

具体的には、現代の暗号学はセキュリティの形式的な**証明**に焦点を当てています。暗号化スキームのセキュリティ証明は、次の三つのステップで進行します：

1. **セキュリティの暗号学的定義**の声明、つまり、セキュリティ目標のセットと攻撃者によってもたらされる脅威。
2. スキームの計算複雑性に関する数学的仮定の声明。例えば、暗号化スキームには擬似乱数生成器が含まれるかもしれません。これらが存在することを証明することはできませんが、存在すると仮定することができます。
3. 形式的なセキュリティの概念と任意の数学的仮定に基づいて、スキームのセキュリティの数学的**証明**の展示。

第四に、歴史的に暗号学は主に軍事設定で利用されていましたが、デジタル時代においては私たちの日常活動に浸透してきました。オンラインバンキングをするとき、ソーシャルメディアに投稿するとき、クレジットカードでAmazonから商品を購入するとき、または友人にビットコインをチップするときなど、暗号学は私たちのデジタル時代の必需品です。

これらの四つの側面を持つ現代の**暗号学**は、敵対的な攻撃に対してデジタル情報を保護するための暗号化スキームの形式的な開発と分析に関心を持つ科学として特徴づけることができます。[6] ここでのセキュリティは、通信における秘密保持、整合性、認証、および/または否認防止の損害を防ぐこととして広く理解されるべきです。
暗号学は、コンピュータシステムの盗難、損傷、悪用を防ぐことに関心を持つ**サイバーセキュリティ**の一分野として最もよく理解されます。多くのサイバーセキュリティ上の懸念は、暗号学とは少しまたは部分的にしか関連がないことに注意してください。
たとえば、会社が高価なサーバーをローカルに設置している場合、そのハードウェアを盗難や損傷から守ることに関心を持つかもしれません。これはサイバーセキュリティの懸念事項ですが、暗号学とはあまり関係がありません。

別の例として、**フィッシング攻撃**は現代において一般的な問題です。これらの攻撃は、人々をだましてEメールやその他のメッセージ媒体を通じて、パスワードやクレジットカード番号などの機密情報を手放させようと試みます。暗号学はある程度、フィッシング攻撃に対処するのに役立つかもしれませんが、包括的なアプローチには暗号学を使用するだけでは不十分です。

**メモ:**

[3] 正確に言うと、暗号スキームの重要な応用は秘密保持に関係しています。例えば、子供たちはしばしば「楽しみ」のために単純な暗号スキームを使用します。これらの場合、秘密保持は実際には問題ではありません。

[4] ブルース・シュナイアー、*Applied Cryptography*、第2版、2015年（インディアナポリス、IN: John Wiley & Sons）、p. 2。

[5] ジョナサン・カッツとイェフダ・リンデル、*Introduction to Modern Cryptography*、CRC Press（ボカラトン、FL: 2015年）、特にpp. 16–23を参照してください。良い説明があります。

[6] カッツとリンデル、前掲書、p. 3。彼らの特徴付けにはいくつかの問題があると思うので、ここでは彼らの声明のやや異なるバージョンを提示します。

## オープンコミュニケーション
<chapterId>cb23d0a6-ba9a-5dc6-a55a-258405ae4117</chapterId>

現代の暗号学は、**オープンコミュニケーション**環境でのセキュリティ保証を提供するように設計されています。もし私たちの通信チャネルが盗聴者が私たちのメッセージを操作したり、観察したりすることができないほどよく保護されているなら、暗号学は余分なものです。しかし、ほとんどの通信チャネルは、このように十分に保護されているわけではありません。

現代世界における通信の背骨は、巨大な光ファイバーケーブルのネットワークです。現代の家庭での電話の使用、テレビの視聴、ウェブの閲覧は、一般的にこの光ファイバーケーブルのネットワークに依存しています（ごく少数が純粋に衛星に依存する場合もあります）。自宅には同軸ケーブル、（非対称）デジタル加入者線、光ファイバーケーブルなど、異なるデータ接続があるかもしれませんが、少なくとも先進国では、これらの異なるデータ媒体は家の外で迅速にノードに接続され、全世界をつなぐ巨大な光ファイバーケーブルのネットワークに合流します。例外は、アメリカやオーストラリアなどの先進国の一部の遠隔地で、データトラフィックが伝統的な銅製の電話線を通じてもかなりの距離を移動する場合もあります。

このケーブルネットワークとその支援インフラストラクチャへの物理的なアクセスを潜在的な攻撃者から防ぐことは不可能です。実際、私たちのデータのほとんどが、インターネットの重要な交差点でさまざまな国家情報機関によって傍受されていることはすでに知られています。[7] これには、Facebookメッセージから訪問したウェブサイトのアドレスまで、あらゆるものが含まれます。

大規模なデータを監視するには、国家情報機関のような強力な敵が必要ですが、資源が少ない攻撃者でも、よりローカルな規模で簡単に盗聴を試みることができます。これはワイヤーのタッピングレベルで起こることがありますが、単に無線通信を傍受する方がはるかに簡単です。
私たちのローカルネットワークデータのほとんどは、現在、物理的なケーブルを通じてではなく、オールインワンルーター上の無線アクセスポイントへ無線波を介して移動します。これは、自宅、オフィス、またはカフェにおいても同様です。そのため、攻撃者はあなたのローカルトラフィックを傍受するためにほとんどリソースを必要としません。これは、ほとんどの人がローカルネットワークを介して移動するデータを保護するためにほとんど何もしていないため、特に懸念されます。さらに、潜在的な攻撃者は、3G、4G、5Gなどのモバイルブロードバンド接続も標的にすることができます。これらの無線通信は攻撃者にとって簡単な標的です。
したがって、通信チャネルを保護することによって通信を秘密に保つという考えは、現代の世界の多くにとって絶望的な幻想です。私たちが知っているすべては、重度の偏執病を正当化します：常に誰かが聞いていると仮定すべきです。そして、暗号学は、この現代の環境である種のセキュリティを得るために私たちが持っている主要なツールです。

**注釈:**

[7] 例えば、Olga Khazan, “The creepy, long-standing practice of undersea cable tapping”, *The Atlantic*, 2013年7月16日 ( [The Atlantic](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/) で利用可能)を参照してください。

# 暗号学の数学的基礎 1
<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

## 乱数変数
<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

暗号学は数学に依存しています。そして、暗号学の表面的な理解以上を構築したい場合、その数学に慣れる必要があります。

この章では、暗号学を学ぶ際に出会う基本的な数学のほとんどを紹介します。トピックには乱数変数、モジュロ演算、XOR演算、擬似乱数が含まれます。これらのセクションの素材をマスターすることは、暗号学の非表面的な理解のために必要です。

次のセクションでは、はるかに難しい数論に取り組みます。

### 乱数変数

乱数変数は通常、太字でない大文字で示されます。したがって、例えば、乱数変数 $X$、乱数変数 $Y$、または乱数変数 $Z$ について話すかもしれません。これは、ここから先も私が使用する表記です。

**乱数変数**は、それぞれが一定の正の確率を持つ2つ以上の可能な値を取ることができます。可能な値は**結果セット**にリストされています。

乱数変数を**サンプリング**するたびに、定義された確率に従ってその結果セットから特定の値を引き出します。

簡単な例に移りましょう。次のように定義された変数 $X$ を仮定します：

- $X$ の結果セットは $\{1,2\}$ です

$$
Pr[X = 1] = 0.5
$$

$$
Pr[X = 2] = 0.5
$$

$X$ が乱数変数であることは容易にわかります。まず、$X$ が取り得る2つ以上の可能な値、すなわち $1$ と $2$ があります。次に、$X$ をサンプリングするたびに、それぞれの可能な値が発生する正の確率があります、すなわち $0.5$ です。
ランダム変数に必要なのは、サンプリング時に発生する可能性がある2つ以上の結果セットで、各可能性が正の確率を持つことです。原則として、ランダム変数は抽象的に定義することができ、どんな文脈からも切り離されます。この場合、「サンプリング」とは、ランダム変数の値を決定するために何らかの自然実験を行うことと考えるかもしれません。
上記の変数 $X$ は抽象的に定義されました。したがって、変数 $X$ のサンプリングを、公平なコインを投げて、表が出た場合は「2」を、裏が出た場合は「1」を割り当てることと考えるかもしれません。$X$ の各サンプルに対して、コインを再度投げます。

または、公平なサイコロを振って、サイコロが $1$、$3$、または $4$ の場合は「2」を、$2$、$5$、または $6$ の場合は「1」を割り当てることとして、$X$ のサンプリングを考えることもできます。$X$ をサンプルするたびに、サイコロを再度振ります。

実際には、$X$ の可能な値の確率を定義することができる任意の自然実験を、図面に関して想像することができます。

しかし、しばしばランダム変数は抽象的に導入されるだけではありません。代わりに、可能な結果値のセットには、単なる数字としてではなく、明確な現実世界の意味があります。さらに、これらの結果値は、その値に対する任意の自然実験ではなく、特定のタイプの実験に対して定義されることがあります。

抽象的に定義されていない変数 $X$ の例を考えてみましょう。$X$ は、2つのチームのどちらがサッカーゲームを開始するかを決定するために次のように定義されます：

- $X$ の結果セットは {赤がキックオフ、青がキックオフ}
- 特定のコイン $C$ を投げる：裏 = 「赤がキックオフ」；表 = 「青がキックオフ」

$$
Pr [X = \text{赤がキックオフ}] = 0.5
$$

$$
Pr [X = \text{青がキックオフ}] = 0.5
$$

この場合、X の結果セットには具体的な意味が与えられています。つまり、サッカーゲームでどちらのチームが開始するかです。さらに、可能な結果とそれらの関連する確率は、特定のコイン $C$ を投げるという具体的な実験によって決定されます。

暗号論の議論では、ランダム変数は通常、現実世界の意味を持つ結果セットに対して導入されます。これは、暗号化される可能性のあるすべてのメッセージのセット、つまりメッセージ空間、または暗号化を使用する当事者が選択できるすべての鍵のセット、つまり鍵空間である可能性があります。

しかし、暗号論におけるランダム変数の議論では、通常、特定の自然実験に対してではなく、正しい確率分布をもたらす可能性のある任意の実験に対して定義されます。

ランダム変数には、離散または連続の確率分布があります。**離散確率分布**を持つランダム変数、つまり離散ランダム変数は、有限数の可能な結果を持ちます。これまでに与えられた例のランダム変数 $X$ は離散でした。

**連続ランダム変数**は代わりに一つ以上の区間で値を取ることができます。たとえば、サンプリング時にランダム変数が0から1の間の任意の実数値を取り、この区間内の各実数が等しく可能性があると言うかもしれません。この区間内には無限に可能な値があります。

暗号論の議論では、離散ランダム変数を理解するだけで十分です。ここから先のランダム変数の議論は、特に別途明記されていない限り、離散ランダム変数を指すと理解されるべきです。

### ランダム変数のグラフ化
確率変数の可能な値とそれに関連する確率は、グラフを通じて簡単に視覚化することができます。例えば、前のセクションからの確率変数 $X$ で、結果セットが $\{1, 2\}$ であり、$Pr [X = 1] = 0.5$ および $Pr [X = 2] = 0.5$ である場合を考えてみましょう。このような確率変数は通常、*図1* のような棒グラフの形で表示されます。
*図1: 確率変数 X*

![図1: 確率変数 X。](assets/Figure2-1.webp)

*図1* の広い棒は、確率変数 $X$ が実際に連続であることを示唆するものではありません。代わりに、棒はより視覚的に魅力的にするために広く作られています（ただ真っ直ぐに上がる線は直感的な視覚化を提供しにくいです）。

### 一様変数

「確率変数」という表現において、「確率的」という意味で「ランダム」を意味します。言い換えると、変数の2つ以上の可能な結果が特定の確率で発生することを意味します。これらの結果が*必ずしも*等しい確率で発生する必要はありません（ただし、「ランダム」という用語は他の文脈ではそのような意味を持つことが確かにあります）。

**一様変数**は確率変数の特別なケースです。それは等しい確率で2つ以上の値を取ることができます。*図1* に描かれた確率変数 $X$ は明らかに一様変数であり、両方の可能な結果が確率 $0.5$ で発生します。しかし、一様変数の例ではない多くの確率変数があります。

例として、確率変数 $Y$ を考えてみましょう。それは結果セット $\{1, 2, 3, 8, 10\}$ を持ち、以下の確率分布を持っています：

$$
\Pr[Y = 1] = 0.25
$$

$$
\Pr[Y = 2] = 0.35
$$

$$
\Pr[Y = 3] = 0.1
$$

$$
\Pr[Y = 8] = 0.25
$$

$$
\Pr[Y = 10] = 0.05
$$

2つの可能な結果が確かに等しい確率で発生する一方で、$Y$ はサンプリング時に $0.25$ と異なる確率で特定の値を取ることもできます。したがって、$Y$ は確かに確率変数ですが、一様変数ではありません。

$Y$ のグラフィカルな描写は*図2*に提供されています。

*図2: 確率変数 Y*

![図2: 確率変数 Y。](assets/Figure2-2.webp "図2: 確率変数 Y")

最後の例として、確率変数 Z を考えてみましょう。それは結果セット {1,3,7,11,12} を持ち、以下の確率分布を持っています：

$$
\Pr[Z = 2] = 0.2
$$

$$
\Pr[Z = 3] = 0.2
$$

$$
\Pr[Z = 9] = 0.2
$$

$$
\Pr[Z = 11] = 0.2
$$

$$
\Pr[Z = 12] = 0.2
$$

*図3* に描かれているように、サンプリング時の可能な値の確率がすべて等しいため、確率変数 Z は Y とは対照的に、一様変数です。

*図3: 確率変数 Z*
![図3: 確率変数Z.](assets/Figure2-3.webp "Figure 3: Random variable Z")

### 条件付き確率

昨年のカレンダーから均等に日を選ぶつもりのボブを想定してみましょう。選ばれた日が夏である確率はどれくらいだと結論付けるべきでしょうか？

ボブの選択プロセスが本当に均等であると考える限り、ボブが夏の日を選ぶ確率は1/4であると結論付けるべきです。これは、ランダムに選ばれた日が夏である**無条件の確率**です。

今度は、カレンダーの日を均等に引き出す代わりに、ボブがニュージャージー州のクリスタルレイクで正午の気温が21度セルシウス以上だった日の中からのみ均等に選ぶと仮定しましょう。この追加情報を踏まえて、ボブが夏の日を選ぶ確率について何を結論付けることができるでしょうか？

昨年のカレンダーの各日の正午の気温など、さらに具体的な情報がなくても、以前とは異なる結論を出すべきです。

クリスタルレイクがニュージャージー州にあることを知っているならば、冬に正午の気温が21度セルシウス以上になることは確かに期待されません。代わりに、春や秋の暖かい日、または夏のどこかの日である可能性がはるかに高いです。したがって、選択された日のクリスタルレイクでの正午の気温が21度セルシウス以上だったことを知っている場合、ボブが夏の日を選ぶ確率ははるかに高くなります。これが、クリスタルレイクでの正午の気温が21度セルシウス以上だったことを条件とした、ランダムに選ばれた日が夏である**条件付き確率**です。

前の例とは異なり、2つのイベントの確率も完全に無関係である場合があります。その場合、それらは**独立している**と言います。

たとえば、ある公正なコインが表を出したとします。この事実を踏まえると、明日雨が降る確率はどれくらいでしょうか？この場合の条件付き確率は、コインの投げ方が一般的に天気に影響を与えないため、明日雨が降る無条件の確率と同じであるべきです。

条件付き確率の記述には"|"記号を使用します。例えば、イベント$B$が起こったことを条件とするイベント$A$の確率は次のように書けます：

$$
Pr[A|B]
$$

したがって、2つのイベント、$A$と$B$が独立している場合：

$$
Pr[A|B] = Pr[A] \text{ および } Pr[B|A] = Pr[B]
$$

独立の条件は次のように簡略化できます：

$$
Pr[A, B] = Pr[A] \cdot Pr[B]
$$

確率論の重要な結果の一つに**ベイズの定理**があります。基本的には、$Pr[A|B]$を次のように書き換えることができます：

$$
Pr[A|B] = \frac{Pr[B|A] \cdot Pr[A]}{Pr[B]}
$$

特定のイベントに対する条件付き確率を使用する代わりに、可能なイベントのセットにわたる2つ以上の確率変数の条件付き確率を見ることもできます。2つの確率変数、$X$と$Y$を仮定します。$X$の任意の可能な値を$x$、$Y$の任意の可能な値を$y$で表すことができます。それでは、次の声明が成り立つ場合、2つの確率変数は独立していると言えます：

$$
Pr[X = x, Y = y] = Pr[X = x] \cdot Pr[Y = y]
$$

すべての$x$と$y$に対して。

この声明が何を意味するのかもう少し具体的に説明しましょう。
$X$と$Y$の結果セットが以下のように定義されているとします：**X** = $\{x_1, x_2, \ldots, x_i, \ldots, x_n\}$ および **Y** = $\{y_1, y_2, \ldots, y_i, \ldots, y_m\}$。（値のセットを太字の大文字で示すのが一般的です。）
次に、$Y$をサンプリングして$y_1$を観測したとします。上記の声明は、$Y$から$y_1$を観測したことがなかったとしても、$X$から$x_1$をサンプリングして得る確率が全く同じであることを私たちに教えています。これは、$Y$の初期サンプリングから引き出すことができた任意の$y_i$に対して真です。最後に、これは$x_1$だけでなく、任意の$x_i$にも当てはまります。$Y$のサンプリング結果によって、発生する確率は影響を受けません。これは、$X$が最初にサンプリングされた場合にも適用されます。

少し哲学的な点で議論を終えましょう。実際の状況では、何らかのイベントの確率は常に特定の情報セットに対して評価されます。「無条件の確率」という言葉の非常に厳密な意味で、そのようなものは存在しません。

例えば、2030年までに豚が飛ぶ確率を尋ねたとします。さらなる情報を提供しないにもかかわらず、あなたは世界について多くのことを知っており、それがあなたの判断に影響を与えることを明らかに知っています。豚が飛ぶのを見たことがありません。ほとんどの人がそれらが飛ぶことを期待しないことを知っています。彼らが本当に飛ぶために作られていないことも知っています。などなど。

したがって、「無条件の確率」という言葉を実世界の文脈で話すとき、その用語は「さらなる明示的な情報なしの確率」というような意味でしか意味を持つことができません。したがって、「条件付き確率」の理解は、常に特定の情報ピースに対して理解されるべきです。

例えば、ニュージーランドのいくつかのヤギが数年間の訓練の後に飛ぶことを学んだという証拠を提供した後、2030年までに豚が飛ぶ確率を尋ねるかもしれません。この場合、2030年までに豚が飛ぶ確率についてのあなたの判断をおそらく調整するでしょう。したがって、2030年までに豚が飛ぶ確率は、ニュージーランドのヤギに関するこの証拠に基づいて条件付けられます。

## モジュロ演算
<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

### モジュロ

**モジュロ演算**の最も基本的な表現は次の形式です：$x \mod y$。

変数$x$は被除数と呼ばれ、変数$y$は除数と呼ばれます。正の被除数と正の除数でモジュロ演算を行うには、単に除算の余りを決定します。

例えば、式$25 \mod 4$を考えてみましょう。数4は数25に合計6回入ります。その除算の余りは1です。したがって、$25 \mod 4$は1に等しいです。同様の方法で、以下の式を評価することができます：

* $29 \mod 30 = 29$（30が29に合計0回入り、余りが29であるため）
* $42 \mod 2 = 0$（2が42に合計21回入り、余りが0であるため）
* $12 \mod 5 = 2$（5が12に2回入り、余りが2であるため）
* $20 \mod 8 = 4$（8が20に2回入り、余りが4であるため）

被除数または除数が負の場合、プログラミング言語によってモジュロ演算の扱い方が異なることがあります。

暗号学では、被除数が負の場合に遭遇することが確実です。これらの場合、一般的なアプローチは以下の通りです：

* 最初に、除数が余りゼロで割り切れる被除数以下の最も近い値を決定します。その値を$p$と呼びます。
* 被除数が$x$である場合、モジュロ演算の結果は$x – p$の値です。

例えば、被除数が$–20$で除数が3の場合、3が均等に割り切れる$–20$以下の最も近い値は$–21$です。この場合の$x – p$の値は$–20 – (–21)$です。これは1に等しく、したがって$–20 \mod 3$は1になります。同様の方法で、以下の式を評価できます：

* $–8 \mod 5 = 2$
* $–19 \mod 16 = 13$
* $–14 \mod 6 = 4$

表記に関しては、通常以下のタイプの式を見ることになります：$x = [y \mod z]$。括弧があるため、この場合モジュロ演算は式の右側にのみ適用されます。例えば、$y$が25で$z$が4の場合、$x$は1と評価されます。

括弧がない場合、モジュロ演算は式の*両側*に作用します。例えば、次の式を考えてみましょう：$x = y \mod z$。$y$が25で$z$が4の場合、$x \mod 4$が1と評価されることだけがわかります。これは$x$の値が集合$\{\ldots,–7, –3, 1, 5, 9,\ldots\}$からの任意の値と一致することと一致します。

数値や式に対するモジュロ演算を含む数学の分野は**モジュラー算術**と呼ばれます。この分野は、数直線が無限に長くない場合の算術と考えることができます。通常、暗号学内で（正の）整数に対するモジュロ演算に遭遇しますが、任意の実数を使用してモジュロ演算を実行することもできます。

### シフト暗号

モジュロ演算は暗号学内で頻繁に遭遇します。例を挙げると、最も有名な歴史的暗号化スキームの一つであるシフト暗号を考えてみましょう。

まずそれを定義しましょう。英語のアルファベットのすべての文字を順番に数値の集合$\{0, 1, 2, \ldots, 25\}$と等価とする辞書*D*を想定します。メッセージ空間**M**を仮定します。**シフト暗号**は、次のように定義される暗号化スキームです：

- キースペース**K**から、一様にキー$k$を選択します。ここで**K** = $\{0, 1, 2, \ldots, 25\}$ [1]
- 次のようにしてメッセージ$m \in \mathbf{M}$を暗号化します：
    - $m$を個々の文字$m_0, m_1, \ldots, m_i, \ldots, m_l$に分割します
- 各$m_i$を*D*に従って数字に変換します
    - 各$m_i$について、$c_i = [(m_i + k) \mod 26]$とします
    - 各$c_i$を*D*に従って文字に変換します
    - そして、$c_0, c_1, \ldots, c_l$を組み合わせて暗号文$c$を生成します
- 暗号文$c$を次のように復号します：
    - 各$c_i$を*D*に従って数字に変換します
    - 各$c_i$について、$m_i = [(c_i – k) \mod 26]$とします
    - 各$m_i$を*D*に従って文字に変換します
    - そして、$m_0, m_1, \ldots, m_l$を組み合わせて元のメッセージ$m$を生成します

シフト暗号におけるモジュロ演算子は、文字がラップアラウンドすることを保証し、すべての暗号文の文字が定義されるようにします。例として、「DOG」という単語にシフト暗号を適用した場合を考えてみましょう。

鍵の値を17と一様に選択したとします。「O」は15に相当します。モジュロ演算がなければ、この平文の数値と鍵を加算した結果は暗号文の数値32になります。しかし、その暗号文の数値は、英語のアルファベットには26文字しかないため、暗号文の文字に変換することはできません。モジュロ演算により、暗号文の数値は実際には6（$32 \mod 26$の結果）となり、これは暗号文の文字「G」に相当します。

鍵の値を17とした「DOG」という単語の全暗号化は以下の通りです：

* メッセージ = DOG = D,O,G = 3,15,6
* $c_0 = [(3 + 17) \mod 26] = [(20) \mod 26] = 20 = U$
* $c_1 = [(15 + 17) \mod 26] = [(32) \mod 26] = 6 = G$
* $c_2 = [(6 + 17) \mod 26] = [(23) \mod 26] = 23 = X$
* $c = UGX$

誰もが直感的にシフト暗号の仕組みを理解し、おそらく自分自身で使用することができます。しかし、暗号学の知識を進めるためには、より複雑になるスキームに対応するため、形式化に慣れることが重要です。そのため、シフト暗号の手順が形式化されました。

**注釈：**

[1] 前のセクションからの用語を使用して、この声明を正確に定義することができます。一様変数$K$が可能な結果のセットとして$K$を持つとします。そうすると：

$$
Pr[K = 0] = \frac{1}{26}
$$

$$
Pr[K = 1] = \frac{1}{26}
$$

...と続きます。一様変数$K$を一度サンプリングして、特定の鍵を生成します。

## XOR演算
<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

すべてのコンピュータデータは、ビットレベルで処理、保存、およびネットワークを介して送信されます。コンピュータデータに適用されるすべての暗号スキームも、ビットレベルで操作されます。

たとえば、電子メールアプリケーションに電子メールを入力したとします。適用する暗号化は、直接的には電子メールのASCII文字には行われません。代わりに、電子メールの文字やその他の記号のビット表現に適用されます。
現代暗号学で理解するための重要な数学的操作には、モジュロ演算の他に、**XOR演算**、または「排他的論理和」があります。この演算は2つのビットを入力として受け取り、別のビットを出力として生成します。XOR演算は単に「XOR」と表記されます。2つのビットが同じ場合は0を、異なる場合は1を生成します。以下に4つの可能性を示します。記号 $\oplus$ は「XOR」を表します：
* $0 \oplus 0 = 0$
* $0 \oplus 1 = 1$
* $1 \oplus 0 = 1$
* $1 \oplus 1 = 0$

例を挙げて説明しましょう。メッセージ $m_1$ (01111001) とメッセージ $m_2$ (01011001) があるとします。これら2つのメッセージのXOR演算は以下のようになります。

* $m_1 \oplus m_2 = 01111001 \oplus 01011001 = 00100000$

このプロセスは直接的です。まず、$m_1$ と $m_2$ の最も左のビットをXORします。この場合、それは $0 \oplus 0 = 0$ です。次に、左から2番目のビットのペアをXORします。この場合、それは $1 \oplus 1 = 0$ です。このプロセスを、最も右のビットに対してXOR演算を行うまで続けます。

XOR演算が交換可能であること、つまり $m_1 \oplus m_2 = m_2 \oplus m_1$ であることは容易にわかります。さらに、XOR演算は結合的でもあります。つまり、$(m_1 \oplus m_2) \oplus m_3 = m_1 \oplus (m_2 \oplus m_3)$ です。

異なる長さの2つの文字列に対するXOR演算は、文脈に応じて異なる解釈を持つことがあります。ここでは、異なる長さの文字列に対するXOR演算には関与しません。

XOR演算は、ビットの加算に対して除数が2の場合のモジュロ演算を行う特別なケースに相当します。以下の結果で等価性を確認できます：

* $(0 + 0) \mod 2 = 0 \oplus 0 = 0$
* $(1 + 0) \mod 2 = 1 \oplus 0 = 1$
* $(0 + 1) \mod 2 = 0 \oplus 1 = 1$
* $(1 + 1) \mod 2 = 1 \oplus 1 = 0$

## 擬似乱数性
<chapterId>20463fc5-3e92-581f-a1b7-3151279bd95e</chapterId>

ランダム変数と一様変数についての議論では、「ランダム」と「一様」の間に特定の区別を行いました。この区別は実際にランダム変数を記述する際に通常維持されます。しかし、現在の文脈では、この区別を取り除き、「ランダム」と「一様」を同義語として使用します。このセクションの最後にその理由を説明します。

始めるにあたり、長さ $n$ の二進文字列がランダム（または一様）であると呼ぶことができます。それは、各二進文字列に同じ選択確率を与える一様変数 $S$ のサンプリング結果であった場合です。
たとえば、長さ8のすべてのバイナリ文字列の集合を考えてみましょう：$\{0000\ 0000, 0000\ 0001, \ldots, 1111\ 1111\}$。（8ビットの文字列は通常、**ニブル**と呼ばれる2つのクァルテットに分けて書かれます。）この文字列の集合を**$S_8$**と呼ぶことにしましょう。
上記の定義に従って、特定の長さ8のバイナリ文字列がランダム（または一様）であると呼ぶことができます。それは、集合**$S_8$**内の各文字列に等しい選択確率を与える一様変数$S$のサンプリング結果であった場合です。集合**$S_8$**が$2^8$の要素を含むことを考えると、サンプリング時の選択確率は集合内の各文字列に対して$1/2^8$でなければなりません。

バイナリ文字列のランダムさの重要な側面は、それが選択されたプロセスに関して定義されることです。したがって、特定のバイナリ文字列の形式自体は、選択のランダムさについて何も明らかにしません。

例えば、多くの人々は直感的に、$1111\ 1111$のような文字列がランダムに選択された可能性はないと考えがちです。しかし、これは明らかに誤りです。

長さ8のすべてのバイナリ文字列に対して一様変数$S$を定義すると、集合**$S_8$**から$1111\ 1111$を選択する可能性は、$0111\ 0100$のような文字列を選択する可能性と同じです。したがって、文字列自体を分析するだけでは、文字列のランダムさについて何も判断できません。

また、バイナリ文字列に限定せずにランダムな文字列についても話すことができます。たとえば、ランダムな16進文字列$AF\ 02\ 82$について話すことがあります。この場合、文字列は長さ6のすべての16進文字列の集合からランダムに選択されたものです。これは、各16進数が4ビットを表すため、長さ24のバイナリ文字列をランダムに選択することと同等です。

通常、「ランダムな文字列」という表現は、特定の長さを持つすべての文字列の集合からランダムに選択された文字列を指します。これが上で説明した方法です。もちろん、長さ$n$の文字列は、すべての長さ$n$の文字列のサブセットのみを構成する集合など、異なる集合からランダムに選択されることもあります。しかし、その場合は「ランダムな文字列」とは言わず、「ある集合**S**からランダムに選択された文字列」と言います。

暗号学内の重要な概念の一つに、擬似ランダム性があります。長さ$n$の**擬似ランダム文字列**は、集合**$S_n$**内の各文字列に等しい選択確率を与える一様変数$S$のサンプリング結果であるかのように見えます。しかし実際には、文字列は必ずしもすべての可能な結果に対して等しい確率を定義するわけではない確率分布を定義する一様変数$S'$のサンプリング結果です。ここでの重要な点は、多くのサンプルを取っても、$S$からのサンプルと$S'$からのサンプルを実際に区別することができないということです。
たとえば、ランダム変数 $S$ を考えてみましょう。その結果セットは **$S_{256}$** で、これは長さ256のすべてのバイナリ文字列のセットです。このセットには $2^{256}$ の要素があります。サンプリング時に、各要素が選択される確率は $1/2^{256}$ と等しいです。
さらに、ランダム変数 $S'$ を想定します。その結果セットは長さ256のバイナリ文字列のうち $2^{128}$ のみを含みます。これらの文字列に対して何らかの確率分布がありますが、この分布が必ずしも一様であるとは限りません。

今、$S$ から1000のサンプルと $S'$ から1000のサンプルを取り、その2つの結果セットをあなたに渡したとします。どの結果セットがどのランダム変数に関連しているかをあなたに伝えます。次に、2つのランダム変数のいずれかからサンプルを取ります。しかし、この時はどのランダム変数からサンプルを取ったかをあなたには伝えません。もし $S'$ が擬似ランダムであれば、私がどのランダム変数からサンプルを取ったかについて正しい推測をするあなたの確率は、実質的に $1/2$ より良くないというのが考え方です。

通常、長さ $n$ の擬似ランダム文字列は、サイズが $n – x$ の文字列をランダムに選択し、それを拡張アルゴリズムの入力として使用することによって生成されます。ここで、$x$ は正の整数です。このサイズが $n – x$ のランダム文字列は **シード** として知られています。

擬似ランダム文字列は、暗号学を実用的にするための重要な概念です。たとえば、ストリーム暗号を考えてみましょう。ストリーム暗号では、ランダムに選択されたキーが拡張アルゴリズムに入力され、はるかに大きな擬似ランダム文字列を生成します。この擬似ランダム文字列は、プレーンテキストとXOR演算を組み合わせて暗号文を生成するために使用されます。

もし、ストリーム暗号のためにこのタイプの擬似ランダム文字列を生成できなかったら、そのセキュリティのためにはメッセージと同じ長さのキーが必要になります。これはほとんどの場合、非常に実用的なオプションではありません。

このセクションで議論された擬似ランダム性の概念は、より正式に定義することができます。また、他の文脈にも拡張されます。しかし、ここではその議論に深入りする必要はありません。暗号学の多くについて直感的に理解するために本当に必要なのは、ランダム文字列と擬似ランダム文字列の違いです。[2]

「ランダム」と「一様」の区別を議論から省略する理由も、今はっきりしているはずです。実際には、一様変数 $S$ のサンプリング結果であるかのように見える文字列を指すために、誰もが擬似ランダムという用語を使用します。厳密に言えば、以前からの言葉を借りて、そのような文字列を「擬似一様」と呼ぶべきです。しかし、「擬似一様」という用語は不格好で誰も使っていないため、ここでは明確さのために導入しません。代わりに、現在の文脈で「ランダム」と「一様」の区別を省略します。

**注釈**

[2] これらの問題についてより正式な解説に興味がある場合は、KatzとLindellの*Introduction to Modern Cryptography*、特に第3章を参照してください。

# 暗号学の数学的基礎 2
<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>

## 数論とは何か？
<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>
この章では、暗号学の数学的基礎に関するより高度なトピックである数論について説明します。数論は対称暗号（例えばRijndael Cipherなど）にとって重要ですが、公開鍵暗号方式において特に重要です。

数論の詳細を扱うことが煩わしいと感じる場合は、最初は高いレベルでの読み進めをお勧めします。後でいつでも戻ってくることができます。

___

**数論**は、整数と整数で動作する数学関数の性質を研究すると特徴づけることができます。

例えば、任意の二つの数 $a$ と $N$ が、それらの最大公約数が1である場合、**互いに素**（または**相対素**）であると考えられます。特定の整数 $N$ を考えてみましょう。$N$ より小さい整数のうち、$N$ と互いに素であるものはいくつありますか？この質問に対する答えについて一般的な声明を出すことはできますか？これらは数論が答えを求めようとする典型的なタイプの質問です。

現代の数論は抽象代数のツールに依存しています。**抽象代数**の分野は、主な分析対象が代数構造として知られる抽象的なオブジェクトである数学のサブディシプリンです。**代数構造**は、一つ以上の操作が結合され、特定の公理を満たす要素の集合です。代数構造を通じて、数学者はその詳細から抽象化することにより、特定の数学的問題についての洞察を得ることができます。

抽象代数の分野は時に現代代数とも呼ばれます。また、**抽象数学**（または**純粋数学**）という概念にも遭遇するかもしれません。この後者の用語は抽象代数を指すものではなく、数学をそのもののために、そして潜在的な応用に目を向けるだけでなく研究することを意味します。

抽象代数からの集合は、正三角形の形状を保持する変換から壁紙のパターンまで、多くの種類のオブジェクトを扱うことができます。数論においては、整数または整数で動作する関数を含む要素の集合のみを考慮します。

## グループ
<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

数学における基本的な概念は、要素の集合です。集合は通常、要素がコンマで区切られた中括弧で示されます。

例えば、すべての整数の集合は $\{…, -2, -1, 0, 1, 2, …\}$ です。ここでの省略符は、特定のパターンが特定の方向に続くことを意味します。したがって、すべての整数の集合には、$3, 4, 5, 6$ なども含まれ、また $-3, -4, -5, -6$ なども含まれます。このすべての整数の集合は通常 $\mathbb{Z}$ と表されます。

別の集合の例は $\mathbb{Z} \mod 11$、つまり11で割った余りのすべての整数の集合です。全体の集合 $\mathbb{Z}$ とは対照的に、この集合には有限数の要素、すなわち $\{0, 1, \ldots, 9, 10\}$ のみが含まれます。
よくある間違いは、集合 $\mathbb{Z} \mod 11$ が実際には $\{-10, -9, \ldots, 0, \ldots, 9, 10\}$ であると考えることです。しかし、以前に定義したように、モジュロ演算を考慮すると、この考えは正しくありません。モジュロ 11 で削減された任意の負の整数は $\{0, 1, \ldots, 9, 10\}$ にラップされます。例えば、式 $-2 \mod 11$ は $9$ に、式 $-27 \mod 11$ は $5$ にラップされます。
数学のもう一つの基本概念は、二項演算です。これは、二つの要素を取って第三の要素を生成する任意の演算です。例えば、基本的な算数や代数から、四つの基本的な二項演算：加算、減算、乗算、除算に馴染みがあるでしょう。

これら二つの基本的な数学概念、集合と二項演算は、抽象代数における最も基本的な構造である群の概念を定義するために使用されます。

具体的には、ある二項演算 $\circ$ を仮定します。さらに、その演算で装備された要素の集合 **S** を仮定します。ここで「装備された」とは、集合 **S** 内の任意の二つの要素間で演算 $\circ$ を実行できることを意味します。

組み合わせ $\langle \mathbf{S}, \circ \rangle$ は、四つの特定の条件、いわゆる群の公理を満たす場合に、**群** です。

1. $\mathbf{S}$ の任意の要素 $a$ と $b$ に対して、$a \circ b$ もまた $\mathbf{S}$ の要素です。これは **閉包条件** として知られています。
2. $\mathbf{S}$ の任意の要素 $a$、$b$、および $c$ に対して、$(a \circ b) \circ c = a \circ (b \circ c)$ が成り立ちます。これは **結合条件** として知られています。
3. $\mathbf{S}$ 内に一意の要素 $e$ が存在し、$\mathbf{S}$ の任意の要素 $a$ に対して次の方程式が成り立ちます：$e \circ a = a \circ e = a$。$e$ が唯一の要素であるため、これは **単位元** と呼ばれます。この条件は **単位条件** として知られています。
4. $\mathbf{S}$ の各要素 $a$ に対して、次の方程式が成り立つ $\mathbf{S}$ の要素 $b$ が存在します：$a \circ b = b \circ a = e$、ここで $e$ は単位元です。ここでの要素 $b$ は **逆元** として知られ、一般に $a^{-1}$ と表記されます。この条件は **逆条件** または **可逆条件** として知られています。

群についてもう少し探求しましょう。全ての整数の集合を $\mathbb{Z}$ と表します。この集合は標準的な加算と組み合わせた $\langle \mathbb{Z}, + \rangle$ は、上記の四つの公理を満たすため、明らかに群の定義に適合します。

1. $\mathbb{Z}$ の任意の要素 $x$ と $y$ に対して、$x + y$ もまた $\mathbb{Z}$ の要素です。したがって、$\langle \mathbb{Z}, + \rangle$ は閉包条件を満たします。
2. 任意の$x$、$y$、および$z$が$\mathbb{Z}$の要素である場合、$(x + y) + z = x + (y + z)$です。したがって、$\langle \mathbb{Z}, + \rangle$は結合律を満たします。
3. $\langle \mathbb{Z}, + \rangle$には、単位元が存在し、それは0です。$\mathbb{Z}$の任意の$x$に対して、$0 + x = x + 0 = x$が成り立ちます。したがって、$\langle \mathbb{Z}, + \rangle$は単位元の条件を満たします。
4. 最後に、$\mathbb{Z}$の各要素$x$に対して、$x + y = y + x = 0$となるような$y$が存在します。例えば、$x$が10の場合、$y$は$-10$になります（$x$が0の場合、$y$も0です）。したがって、$\langle \mathbb{Z}, + \rangle$は逆元の条件を満たします。

重要なことは、整数の集合が加算によって群を構成するということは、それが乗算によって群を構成するという意味ではないということです。$\langle \mathbb{Z}, \cdot \rangle$を4つの群の公理に対してテストすることによって、これを確認することができます（ここで$\cdot$は標準的な乗算を意味します）。

最初の2つの公理は明らかに成り立ちます。さらに、乗算の下で、要素1は単位元として機能します。任意の整数$x$に1を乗算すると、$x$が得られます。しかし、$\langle \mathbb{Z}, \cdot \rangle$は逆元の条件を満たしません。つまり、$\mathbb{Z}$の各$x$に対して、$x \cdot y = 1$となるような一意の要素$y$が$\mathbb{Z}$に存在しないのです。

例えば、$x = 22$と仮定します。$x$に乗算された$\mathbb{Z}$の集合からのどの値$y$が単位元1を生み出すでしょうか？$1/22$の値なら機能しますが、これは$\mathbb{Z}$の集合にはありません。実際、1と-1の値を除く任意の整数$x$に対して、この問題に直面します（この場合、$y$はそれぞれ1と-1でなければなりません）。

私たちが集合として実数を許可した場合、問題は大部分が消えます。集合の任意の要素$x$に対して、$1/x$による乗算は1を生み出します。分数は実数の集合に含まれているため、すべての実数に対して逆が見つかります。例外はゼロで、ゼロによる任意の乗算は決して単位元1を生み出しません。したがって、乗算を備えた非ゼロの実数の集合は確かに群です。

いくつかの群は、**交換律**として知られる第5の一般的な条件を満たします。この条件は以下の通りです：

* 群$G$が集合**S**と二項演算子$\circ$を持つと仮定します。$a$と$b$が**S**の要素であるとします。**S**の任意の2つの要素$a$と$b$に対して、$a \circ b = b \circ a$が成り立つ場合、$G$は交換律の条件を満たします。
交換法則を満たす任意の群は、**可換群**または**アーベル群**（ニールス・ヘンリック・アーベルにちなんで）として知られています。加法における実数の集合と加法における整数の集合がアーベル群であることを確認するのは容易です。乗法における整数の集合はそもそも群ではないため、当然アーベル群にはなり得ません。対照的に、乗法における非ゼロ実数の集合もまたアーベル群です。

記法に関して二つの重要な慣習に注意すべきです。第一に、符号「+」または「×」は、要素が実際には数でない場合でも、群の演算を象徴するために頻繁に使用されます。これらの場合、これらの符号を標準的な算術加法や乗法として解釈してはいけません。代わりに、これらは算術演算と抽象的な類似性のみを持つ演算です。

特に算術加法や乗法を指しているのでなければ、$\circ$ や $\diamond$ のような記号を群の演算に使用する方が簡単です。これらは文化的に深く根付いた意味合いを持っていません。

第二に、「+」や「×」が非算術演算を示すためによく使用されるのと同じ理由で、群の単位元は「0」と「1」によって頻繁に象徴されますが、これらの群の要素が数でない場合でもです。群の単位元を数である群について言及しているのでなければ、「$e$」のようなより中立的な記号を使用して単位元を示す方が簡単です。

数学において、特定の二項演算を備えた多くの異なる非常に重要な値の集合が群です。しかし、暗号学的アプリケーションは、整数の集合、または少なくとも整数によって記述される要素、つまり数論の領域内でのみ機能します。したがって、整数以外の実数を含む集合は、暗号学的アプリケーションで使用されません。

整数ではないが「整数によって記述される」要素の例を挙げて終わりにしましょう。良い例は楕円曲線の点です。楕円曲線上の任意の点は明らかに整数ではありませんが、実際には二つの整数によって記述されます。

例えば、楕円曲線はビットコインにとって非常に重要です。任意の標準的なビットコインの秘密鍵と公開鍵のペアは、以下の楕円曲線によって定義される点の集合から選択されます：

$$
x^3 + 7 = y^2 \mod 2^{256} – 2^{32} – 29 – 28 – 27 – 26 - 24 - 1
$$

（$2^{256}$ より小さい最大の素数）。$x$座標が秘密鍵であり、$y$座標が公開鍵です。

ビットコインの取引は通常、何らかの方法で一つ以上の公開鍵に出力をロックすることを含みます。これらの取引からの価値は、対応する秘密鍵でデジタル署名を行うことによって、解除することができます。

## 循環群
<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

私たちが引き出せる主な区別は、**有限群**と**無限群**の間です。前者は有限数の要素を持ち、後者は無限数の要素を持ちます。任意の有限群の要素の数は、**群の位数**として知られています。群を使用する実用的な暗号学は、有限（数論的）群に依存しています。

公開鍵暗号学の中で、特定のクラスの有限アーベル群である循環群は特に重要です。循環群を理解するためには、まず群要素の指数化の概念を理解する必要があります。
群 $G$ とその群演算 $\circ$ を考え、$a$ が $G$ の要素であるとします。このとき、式 $a^n$ は、要素 $a$ が自身と合計で $n - 1$ 回結合されたものと解釈されるべきです。例えば、$a^2$ は $a \circ a$ を意味し、$a^3$ は $a \circ a \circ a$ を意味し、以降同様です。（ここでの冪乗は、標準的な算術の意味での冪乗とは必ずしも同じではないことに注意してください。）

例を挙げてみましょう。$G = \langle \mathbb{Z} \mod 7, + \rangle$ であり、$a$ の値が 4 であるとします。この場合、$a^2 = [4 + 4 \mod 7] = [8 \mod 7] = 1 \mod 7$ となります。また、$a^4$ は $[4 + 4 + 4 + 4 \mod 7] = [16 \mod 7] = 2 \mod 7$ を表します。

いくつかのアーベル群には、継続的な冪乗を通じて他のすべての群要素を生成できる要素が一つまたは複数存在します。これらの要素は **生成元** または **原始元** と呼ばれます。

このような群の重要なクラスは $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ であり、ここで $N$ は素数です。記号 $\mathbb{Z}^*$ は、群が $N$ より小さいすべての非ゼロの正の整数を含むことを意味します。したがって、このような群には常に $N - 1$ の要素があります。

例として、$G = \langle \mathbb{Z}^* \mod 11, \cdot \rangle$ を考えてみましょう。この群には次の要素があります：$\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}$。この群の位数は10です（これは実際に $11 - 1$ に等しい）。

この群から要素2を冪乗してみましょう。$2^{12}$ までの計算を以下に示します。方程式の左側の指数は群要素の冪乗を指します。私たちの特定の例では、これは実際に方程式の右側での算術冪乗を含んでいます（しかし、例えば加算を含むこともあり得ました）。明確にするために、右側での指数形式ではなく、繰り返し操作を書き出しました。

* $2^1 = 2 \mod 11$
* $2^2 = 2 \cdot 2 \mod 11 = 4 \mod 11$
* $2^3 = 2 \cdot 2 \cdot 2 \mod 11 = 8 \mod 11$
* $2^4 = 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 16 \mod 11 = 5 \mod 11$
* $2^5 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 32 \mod 11 = 10 \mod 11$
* $2^6 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 64 \mod 11 = 9 \mod 11$
* $2^7 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 128 \mod 11 = 7 \mod 11$
* $2^8 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 256 \mod 11 = 3 \mod 11$
* $2^9 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 512 \mod 11 = 6 \mod 11$
* $2^{10} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 1024 \mod 11 = 1 \mod 11$
* $2^{11} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 2048 \mod 11 = 2 \mod 11$
* $2^{12} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 4096 \mod 11 = 4 \mod 11$

慎重に観察すると、要素2に対して指数演算を行うと、$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ の全ての要素を次の順序で循環することがわかります：2, 4, 8, 5, 10, 9, 7, 3, 6, 1。$2^{10}$ の後、要素2の指数演算を続けると、全ての要素を再び同じ順序で循環します。したがって、要素2は $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ における生成元です。

$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ には複数の生成元がありますが、この群の全ての要素が生成元であるわけではありません。例えば、要素3を考えてみましょう。最初の10回の指数演算を行い、煩雑な計算を示さずに結果を以下に示します：

* $3^1 = 3 \mod 11$
* $3^2 = 9 \mod 11$
* $3^3 = 5 \mod 11$
* $3^4 = 4 \mod 11$
* $3^5 = 1 \mod 11$
* $3^6 = 3 \mod 11$
* $3^7 = 9 \mod 11$
* $3^8 = 5 \mod 11$
* $3^9 = 4 \mod 11$
* $3^{10} = 1 \mod 11$
$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$の全ての値を順に計算する代わりに、要素3の累乗を行うと、これらの値のサブセットである3、9、5、4、そして1のみが得られます。5回の累乗後、これらの値は繰り返し始めます。
これで、少なくとも1つの生成元を持つ任意の群を**巡回群**として定義することができます。つまり、累乗を通じて他の全ての群の要素を生成できる少なくとも1つの群の要素が存在します。

上記の例でお気づきかもしれませんが、$2^{10}$と$3^{10}$は共に$1 \mod 11$と等しくなります。実際、計算は行いませんが、群$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$内の任意の要素を10で累乗すると、$1 \mod 11$が得られます。これはなぜでしょうか？

これは重要な質問ですが、答えるにはいくつかの作業が必要です。

まず、2つの正の整数$a$と$N$を想定します。数論における重要な定理は、$a$が$N$に対する乗法的逆数（つまり、$a \cdot b = 1 \mod N$となる整数$b$）を持つのは、$a$と$N$の最大公約数が1である場合、つまり$a$と$N$が互いに素である場合に限られると述べています。

したがって、$N$に対する乗法を備えた整数の群では、$N$と互いに素な小さい整数のみがセットに含まれます。このセットを$\mathbb{Z}^c \mod N$と表すことができます。

例えば、$N$が10であると仮定します。1、3、7、9の整数のみが10と互いに素です。したがって、セット$\mathbb{Z}^c \mod 10$は$\{1, 3, 7, 9\}$のみを含みます。1から10までの他の整数を使用して、10に対する整数の乗法を用いた群を作ることはできません。この特定の群では、逆数のペアは1と9、そして3と7です。

$N$自体が素数である場合、1から$N – 1$までの全ての整数は$N$と互いに素です。したがって、そのような群は$N – 1$の順序を持ちます。先ほどの表記を使用すると、$N$が素数の場合、$\mathbb{Z}^c \mod N$は$\mathbb{Z}^* \mod N$と等しくなります。私たちが以前に選んだ群、$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$は、このクラスの群の特定の例です。

次に、関数$\phi(N)$は、数$N$までの互いに素な数の数を計算し、**オイラーのファイ関数**として知られています。[1] **オイラーの定理**によると、2つの整数$a$と$N$が互いに素である場合、以下が成り立ちます：

* $a^{\phi(N)} \mod N = 1 \mod N$
このことは、群 $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ のクラスにとって重要な意味を持ちます。ここで $N$ は素数です。これらの群において、群要素のべき乗は算術的なべき乗を表します。つまり、$a^{\phi(N)} \mod N$ は算術操作 $a^{\phi(N)} \mod N$ を表します。これらの乗法群の任意の要素 $a$ が $N$ と互いに素であるため、$a^{\phi(N)} \mod N = a^{N – 1} \mod N = 1 \mod N$ となります。
オイラーの定理は非常に重要な結果です。まず、$\langle \mathbb{Z}^* \mod N, \cdot \rangle$ の全要素が、$N – 1$ に割り切れる数値を通じてのみべき乗によって循環することを意味します。$\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ の場合、これは各要素が2、5、または10の要素を通じてのみ循環することを意味します。べき乗によって任意の要素が循環する群の値は、**要素の位数**として知られています。群の位数に等しい位数を持つ要素は生成元です。

さらに、オイラーの定理は、$N$ が素数である任意の群 $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ において、$a^{N – 1} \mod N$ の結果を常に知ることができることを意味します。これは、実際の計算がどれほど複雑であってもそうです。

例えば、私たちの群が $\mathbb{Z}^* \mod 160,481,182$（ここで160,481,182は確かに素数です）であるとします。1から160,481,181までの全整数がこの群の要素でなければならず、$\phi(n) = 160,481,181$ であることを知っています。計算の全ステップを行うことはできませんが、$514^{160,481,181}$、$2,005^{160,481,181}$、および $256,212^{160,481,181}$ などの表現がすべて $1 \mod 160,481,182$ と評価されることを知っています。

**ノート:**

[1] この関数は次のように機能します。任意の整数 $N$ は素数の積に因数分解することができます。特定の $N$ が次のように因数分解されるとします：$p_1^{e1} \cdot p_2^{e2} \cdot \ldots \cdot p_m^{em}$ ここで、全ての $p$ は素数であり、全ての $e$ は1以上の整数です。すると：

$$
\phi(N) = \sum_{i=1}^m \left[p_i^{e_i} - p_i^{e_i - 1}\right]
$$

$N$ の素因数分解のためのオイラーのファイ関数の式です。

## フィールド
<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

群は抽象代数学における基本的な代数構造ですが、それ以外にも多くの代数構造が存在します。実践で遭遇する主な対称暗号方式であるAdvanced Encryption Standardなど、暗号学で頻繁に使用される代数構造として知っておくべきものは、**フィールド**、特に**有限フィールド**の構造です。
フィールドは、群の概念から派生しています。具体的には、**フィールド**は二つの二項演算子 $\circ$ と $\diamond$ を備えた要素の集合 **S** であり、以下の条件を満たします：
1. 集合 **S** は $\circ$ を備えるとアーベル群になります。
2. 集合 **S** は $\diamond$ を備えると「非ゼロ」要素に対してアーベル群になります。
3. 集合 **S** は二つの演算子を備えると、分配条件として知られるものを満たします：$a$、$b$、および $c$ を **S** の要素とします。その場合、二つの演算子を備えた **S** は $a \circ (b \diamond c) = (a \circ b) \diamond (a \circ c)$ のとき分配法則を満たします。

群と同様に、フィールドの定義は非常に抽象的です。**S** の要素の種類や演算 $\circ$ と $\diamond$ については何も主張していません。ただ、二つの演算を持つ任意の要素の集合が上記の三つの条件を満たす場合、それはフィールドであると述べています。（第二のアーベル群の「ゼロ」要素は抽象的に解釈できます。）

では、フィールドの例は何でしょうか？良い例は、標準的な加算（上記の $\circ$ の代わりに）と標準的な乗算（上記の $\diamond$ の代わりに）で定義された集合 $\mathbb{Z} \mod 7$、または $\{0, 1, \ldots, 7\}$ です。

まず、$\mathbb{Z} \mod 7$ は加算に関してアーベル群である条件を満たし、非ゼロ要素のみを考慮した場合に乗算に関してアーベル群である条件を満たします。次に、二つの演算子を備えた集合は分配条件を満たします。

これらの主張を特定の値を使用して探求することは教育的に価値があります。集合 $\mathbb{Z} \mod 7$ からランダムに選択された要素である 5、2、および 3 の実験値を取り、フィールド $\langle \mathbb{Z} \mod 7, +, \cdot \rangle$ を検証しましょう。特定の条件を探求するために、必要に応じてこれら三つの値を順番に使用します。

まず、$\mathbb{Z} \mod 7$ が加算でアーベル群であるかどうかを探ります。

1. **閉包条件**：5 と 2 を値として取りましょう。その場合、$[5 + 2] \mod 7 = 7 \mod 7 = 0$ です。これは $\mathbb{Z} \mod 7$ の要素であり、閉包条件と一致しています。
2. **結合条件**：5、2、および 3 を値として取りましょう。その場合、$[(5 + 2) + 3] \mod 7 = [5 + (2 + 3)] \mod 7 = 10 \mod 7 = 3$ です。これは結合条件と一致しています。
3. **単位元条件**：5 を値として取りましょう。その場合、$[5 + 0] \mod 7 = [0 + 5] \mod 7 = 5$ です。したがって、0 は加算のための単位元であると考えられます。
4. **逆条件**: 5の逆を考えます。ある値$d$に対して、$[5 + d] \mod 7 = 0$である必要があります。この場合、この条件を満たす$\mathbb{Z} \mod 7$からの唯一の値は2.5です。**交換条件**: 値として5と3を取りましょう。その場合、$[5 + 3] \mod 7 = [3 + 5] \mod 7 = 1$です。これは交換条件と一致しています。

加法によって装備された集合$\mathbb{Z} \mod 7$は明らかにアーベル群であるように見えます。次に、乗法によって装備された$\mathbb{Z} \mod 7$が、非ゼロ要素に対してアーベル群であるかどうかを探りましょう。

1. **閉包条件**: 値として5と2を取りましょう。その場合、$[5 \cdot 2] \mod 7 = 10 \mod 7 = 3$です。これも$\mathbb{Z} \mod 7$の要素なので、結果は閉包条件と一致しています。
2. **結合条件**: 値として5、2、そして3を取りましょう。その場合、$[(5 \cdot 2) \cdot 3] \mod 7 = [5 \cdot (2 \cdot 3)] \mod 7 = 30 \mod 7 = 2$です。これは結合条件と一致しています。
3. **単位元条件**: 値として5を取りましょう。その場合、$[5 \cdot 1] \mod 7 = [1 \cdot 5] \mod 7 = 5$です。従って、1は乗法における単位元であると見られます。
4. **逆条件**: 5の逆を考えます。ある値$d$に対して、$[5 \cdot d] \mod 7 = 1$である必要があります。この条件を満たす$\mathbb{Z} \mod 7$からの唯一の値は3です。これは逆条件と一致しています。
5. **交換条件**: 値として5と3を取りましょう。その場合、$[5 \cdot 3] \mod 7 = [3 \cdot 5] \mod 7 = 15 \mod 7 = 1$です。これは交換条件と一致しています。

集合$\mathbb{Z} \mod 7$は、非ゼロ要素に対して加法または乗法を結合した場合、アーベル群であるという規則を明らかに満たしているようです。

最終的に、この集合は両方の演算子を組み合わせた場合、分配条件を満たしているようです。値として5、2、そして3を取りましょう。$[5 \cdot (2 + 3)] \mod 7 = [5 \cdot 2 + 5 \cdot 3] \mod 7 = 25 \mod 7 = 4$となることがわかります。

特定の値でテストした場合、$\mathbb{Z} \mod 7$が加法と乗法によって装備された場合、有限体の公理を満たしていることが見られました。もちろん、一般的にもそれを示すことができますが、ここでは行いません。

重要な区別は、二つのタイプの体、有限体と無限体の間にあります。
無限体は、集合 **S** が無限に大きい場合の体を指します。加算と乗算で装備された実数の集合 $\mathbb{R}$ は、無限体の一例です。**有限体**、または **ガロア体** としても知られているのは、集合 **S** が有限である体です。上記の例である $\langle \mathbb{Z} \mod 7, +, \cdot \rangle$ は有限体です。
暗号学では、主に有限体に関心があります。一般に、ある要素の集合 **S** が $p^m$ 個の要素を持つ場合（ただし、$p$ は素数で、$m$ は1以上の正の整数）、その集合が有限体であることが示されます。言い換えると、ある集合 **S** の順序が素数（$p^m$ で $m = 1$）または素数のべき乗（$p^m$ で $m > 1$）である場合、二つの演算子 $\circ$ と $\diamond$ を見つけることができ、体の条件が満たされます。

ある有限体が素数の要素を持つ場合、それは **素体** と呼ばれます。有限体の要素の数が素数のべき乗である場合、その体は **拡張体** と呼ばれます。暗号学では、素体と拡張体の両方に関心があります。[2]

暗号学において関心のある主な素体は、すべての整数の集合がある素数で調整され、演算子が標準の加算と乗算であるものです。このクラスの有限体には、$\mathbb{Z} \mod 2$、$\mathbb{Z} \mod 3$、$\mathbb{Z} \mod 5$、$\mathbb{Z} \mod 7$、$\mathbb{Z} \mod 11$、$\mathbb{Z} \mod 13$ などが含まれます。任意の素体 $\mathbb{Z} \mod p$ において、その体の整数の集合は次のようになります：$\{0, 1, \ldots, p – 2, p – 1\}$。

暗号学では、特に $2^m$ 要素（$m > 1$）を持つ拡張体にも関心があります。このような有限体は、例えば、Advanced Encryption Standard の基礎を形成する Rijndael Cipher で使用されています。素体は比較的直感的ですが、これらの基数2の拡張体は、抽象代数に慣れていない人にとってはおそらくそうではありません。

始めに、$2^m$ 要素を持つ整数の任意の集合には、その組み合わせが体になるように二つの演算子を割り当てることができるのは確かです（$m$ が正の整数である限り）。しかし、体が存在するからといって、それが特定のアプリケーションにとって容易に発見されるか、特に実用的であるとは限りません。

特に、暗号学において適用可能な $2^m$ の拡張体は、整数のある集合ではなく、特定の多項式表現の集合に定義されたものです。

例えば、$2^3$（つまり、8）要素を持つ拡張体を望む場合を考えてみましょう。そのサイズの体に使用できるさまざまな集合があるかもしれませんが、一つの集合には、各係数 $a_i$ が0または1である形式の $a_2x^2 + a_1x + a_0$ のすべてのユニークな多項式が含まれます。したがって、この集合 **S** には次の要素が含まれます：
1. $0$: $a_2 = 0$、$a_1 = 0$、そして$a_0 = 0$の場合。
2. $1$: $a_2 = 0$、$a_1 = 0$、そして$a_0 = 1$の場合。
3. $x$: $a_2 = 0$、$a_1 = 1$、そして$a_0 = 0$の場合。
4. $x + 1$: $a_2 = 0$、$a_1 = 1$、そして$a_0 = 1$の場合。
5. $x^2$: $a_2 = 1$、$a_1 = 0$、そして$a_0 = 0$の場合。
6. $x^2 + 1$: $a_2 = 1$、$a_1 = 0$、そして$a_0 = 1$の場合。
7. $x^2 + x$: $a_2 = 1$、$a_1 = 1$、そして$a_0 = 0$の場合。
8. $x^2 + x + 1$: $a_2 = 1$、$a_1 = 1$、そして$a_0 = 1$の場合。

したがって、**S**は集合$\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$です。この要素の集合に対して、その組み合わせが体を形成することを保証するために定義できる2つの操作は何ですか？

集合**S**上の最初の操作($\circ$)は、標準的な多項式の加算モジュロ2として定義できます。通常どおりに多項式を加算し、その結果の多項式の各係数にモジュロ2を適用するだけです。以下に例を示します：

* $[(x^2) + (x^2 + x + 1)] \mod 2 = [2x^2 + x + 1] \mod 2 = x + 1$
* $[(x^2 + x) + (x)] \mod 2 = [x^2 + 2x] \mod 2 = x^2$
* $[(x + 1) + (x^2 + x + 1)] \mod 2 = [x^2 + 2x + 2] \mod 2 = x^2 + 1$

集合**S**上の2番目の操作($\diamond$)は、体を作成するために必要なもので、より複雑です。これは算術からの標準的な乗算ではなく、特定の種類の乗算です。代わりに、各要素をベクトルとして見て、それら2つのベクトルの乗算を既約多項式モジュロで理解する必要があります。

まず、既約多項式の概念について説明しましょう。**既約多項式**とは、因数分解できない多項式のことです（素数が1とその素数自身以外の成分に因数分解できないのと同じように）。私たちの目的では、すべての整数に関して既約である多項式に興味があります。（例えば、整数を使って因数分解できない場合でも、実数や複素数を使って特定の多項式を因数分解できるかもしれません。）
例として、多項式 $x^2 - 3x + 2$ を考えてみましょう。これは $(x – 1)(x – 2)$ と書き換えることができます。したがって、これは既約ではありません。次に、多項式 $x^2 + 1$ を考えてみましょう。整数のみを使用して、この式をさらに因数分解する方法はありません。したがって、これは整数に関して既約な多項式です。

次に、ベクトルの乗算の概念について考えてみましょう。このトピックを深く掘り下げることはありませんが、基本的なルールを理解する必要があります：被除数の次数が除数の次数以上である限り、任意のベクトルの除算が行えます。被除数の次数が除数の次数より低い場合、被除数はもはや除数によって割ることができません。

例えば、式 $x^6 + x + 1 \mod x^5 + x^2$ を考えてみましょう。これは明らかにさらに簡約されます。なぜなら、被除数の次数6は除数の次数5よりも高いからです。次に、式 $x^5 + x + 1 \mod x^5 + x^2$ を考えてみましょう。これもさらに簡約されます。なぜなら、被除数の次数5と除数の次数5が等しいからです。

しかし、式 $x^4 + x + 1 \mod x^5 + x^2$ を考えると、これはさらに簡約されません。なぜなら、被除数の次数4は除数の次数5よりも低いからです。

この情報に基づいて、私たちは今、集合 $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$ に対する第二の演算を見つける準備ができました。

私は既に、第二の演算はある既約多項式に関するベクトル乗算のモジュロとして理解されるべきだと述べました。この既約多項式は、第二の演算が **S** 上のアーベル群を定義し、分配条件と一致することを保証するべきです。では、その既約多項式は何であるべきでしょうか？

集合内のすべてのベクトルが次数2以下であるため、既約多項式は次数3であるべきです。集合内の2つのベクトルの乗算が次数3以上の多項式を生む場合、次数3の多項式によるモジュロは常に次数2以下の多項式を生むことを私たちは知っています。これは、次数3以上の任意の多項式は常に次数3の多項式によって割り切れるためです。さらに、除数として機能する多項式は既約でなければなりません。

次数3の既約多項式はいくつかあり、私たちの集合 **S** と2による加算のモジュロと組み合わせることで異なる体を定義します。これは、暗号学で拡張体 $2^m$ を使用する際に複数のオプションがあることを意味します。

例として、多項式 $x^3 + x + 1$ を選択したとします。これは実際には既約であり、整数を使用して因数分解することはできません。さらに、2つの要素の乗算は常に次数2以下の多項式を生むことを保証します。
例として、多項式 $x^3 + x + 1$ を除数として使用し、2番目の操作がどのように機能するかを説明しましょう。集合 **S** の中で、要素 $x^2 + 1$ と $x^2 + x$ を乗算するとします。次に、式 $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1$ を計算する必要があります。これは以下のように簡略化できます：
* $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1 =$
* $[x^2 \cdot x^2 + x^2 \cdot x + 1 \cdot x^2 + 1 \cdot x] \mod x^3 + x + 1 =$
* $[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$

私たちは、$[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$ が、被除数が除数（3）よりも高い次数（4）を持つため、簡約化できることを知っています。

始めるにあたり、式 $x^3 + x + 1$ が $x^4 + x^3 + x^2 + x$ に合計 $x$ 回入ることがわかります。これは、$x^3 + x + 1$ を $x$ で乗算することによって確認できます。これは $x^4 + x^2 + x$ となり、後者の項は被除数と同じ次数、つまり 4 であるため、これが機能することがわかります。この除算の余りは次のように計算できます：

* $[(x^4 + x^3 + x^2 + x) - (x^4 + x^2 + x)] \mod x^3 + x + 1 =$
* $[x^3] \mod x^3 + x + 1 =$
* $x^3$

従って、$x^4 + x^3 + x^2 + x$ を $x^3 + x + 1$ で合計 $x$ 回割った後、余りは $x^3$ になります。これをさらに $x^3 + x + 1$ で割ることができるでしょうか？

直感的には、後者の項がより大きいように見えるため、$x^3$ を $x^3 + x + 1$ でこれ以上割ることはできないと言いたくなるかもしれません。しかし、以前にベクトル除算についての議論を思い出してください。被除数が除数と同じかそれ以上の次数を持つ限り、式はさらに簡約化できます。具体的には、式 $x^3 + x + 1$ は $x^3$ に正確に 1 回入ります。余りは次のように計算されます：

$$
[(x^3) - (x^3 + x + 1)] \mod x^3 + x + 1 = [x + 1] \mod x^3 + x + 1 = x + 1
$$

$(x^3) - (x^3 + x + 1)$ が $x + 1$ と評価され、$-x - 1$ ではない理由を疑問に思うかもしれません。私たちのフィールドの最初の操作がモジュロ 2 で定義されていることを思い出してください。したがって、2つのベクトルの減算は、2つのベクトルの加算とまったく同じ結果をもたらします。
$x^2 + 1$ と $x^2 + x$ の乗算をまとめると：これら二つの項を乗算すると、4次の多項式 $x^4 + x^3 + x^2 + x$ が得られ、これを $x^3 + x + 1$ で剰余を取る必要があります。4次の多項式は、$x^3 + x + 1$ でちょうど $x + 1$ 回割り切れます。$x^4 + x^3 + x^2 + x$ を $x^3 + x + 1$ でちょうど $x + 1$ 回割った後の余りは $x + 1$ です。これは確かに私たちの集合 $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$ の要素です。
上記の例のように、多項式の集合を基にした2の拡張体が暗号学にとってなぜ有用か？その理由は、そのような集合の多項式の係数を、特定の長さのバイナリ文字列の要素として、0または1と見なすことができるからです。例えば、上記の例の集合 **S** は、代わりに長さ3のすべてのバイナリ文字列（000から111まで）を含む集合 **S** として見ることができます。したがって、**S** 上の操作は、これらのバイナリ文字列上で操作を実行し、同じ長さのバイナリ文字列を生成するためにも使用できます。

**ノート:**

[2] 拡張体は非常に直感に反します。整数の要素を持つ代わりに、多項式の集合を持っています。さらに、ある既約多項式による剰余で操作が行われます。

## 実践における抽象代数
<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>

議論の形式的な言語と抽象性にもかかわらず、群の概念を理解するのはそれほど難しくないはずです。それは単に、二項演算を伴う要素の集合であり、その二項演算の実行が四つの一般的な条件を満たす場合です。アーベル群は、交換可能性として知られる追加の条件を持つだけです。巡回群は、特に生成元を持つアーベル群の特別な種類です。一方、体は基本的な群の概念からより複雑な構造です。

しかし、実用的な人であれば、この時点で疑問に思うかもしれません：誰が気にするのか？ある要素の集合と演算子が群、またはアーベル群や巡回群であることを知っていることが、実際の世界で何か関連性があるのか？何かが体であることを知っていることは？

あまり詳しくは述べませんが、答えは「はい」です。群は最初、19世紀にフランスの数学者エヴァリスト・ガロアによって作られました。彼はそれらを使用して、五次以上の多項式方程式を解くことについての結論を導き出しました。

それ以来、群の概念は数学やその他の分野の多くの問題を解明するのに役立ってきました。例えば、物理学者マレー・ゲルマンは、実験で実際に観測される前に粒子の存在を予測することができました。[3] 別の例として、化学者は群論を使用して分子の形を分類します。数学者は、壁紙という具体的なものについて結論を導くために群の概念を使用してさえいます。
一連の要素とある演算子が群を形成していることを示すことは、説明しているものが特定の対称性を持っていることを意味します。これは一般的な意味での対称性ではなく、より抽象的な形での対称性です。そして、これは特定のシステムや問題への重要な洞察を提供することができます。抽象代数からのより複雑な概念は、私たちに追加情報を与えてくれます。
最も重要なことは、数論的群や体の実践における重要性を、特に公開鍵暗号法の応用を通じて見ることになるでしょう。たとえば、フィールドの議論で、拡張フィールドがRijndael Cipherでどのように使用されているかを既に見てきました。その例は*第5章*で詳しく説明します。

抽象代数についてさらに議論するためには、Socraticaによる抽象代数に関する優れたビデオシリーズをお勧めします。[4] 特にお勧めするビデオは「What is abstract algebra?」、「Group definition (expanded)」、「Ring definition (expanded)」、そして「Field definition (expanded)」です。これら4つのビデオは、上記の議論の多くに追加の洞察を与えてくれます。（リングについては議論しませんでしたが、フィールドはリングの特別なタイプに過ぎません。）

現代数論についてさらに議論するためには、暗号学に関する多くの高度な議論を参照することができます。Jonathan KatzとYehuda Lindellの*Introduction to Modern Cryptography*やChristof PaarとJan Pelzlの*Understanding Cryptography*をさらに議論するための提案として挙げます。[5]

**ノート:**

[3] [YouTubeビデオ](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be)を参照

[4] Socratica, [Abstract Algebra](https://www.socratica.com/subject/abstract-algebra)

[5] Katz and Lindell, *Introduction to Modern Cryptography*, 第2版, 2015年 (CRC Press: Boca Raton, FL)。Paar and Pelzl, *Understanding Cryptography*, 2010年 (Springer-Verlag: Berlin)。

# 対称暗号
<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

## アリスとボブ
<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

暗号学の二つの主要な分野の一つが対称暗号です。これには暗号化スキームだけでなく、認証や完全性に関するスキームも含まれます。1970年代まで、暗号学はすべて対称暗号化スキームで構成されていました。

主な議論は、対称暗号化スキームを見て、ストリーム暗号とブロック暗号という重要な区別を行うことから始まります。次に、メッセージの完全性と真正性を保証するスキームであるメッセージ認証コードについて説明します。最後に、対称暗号化スキームとメッセージ認証コードを組み合わせて、安全な通信を保証する方法を探ります。

この章では、実際の対称暗号化スキームについて様々なものが簡単に議論されます。次の章では、実際のストリーム暗号とブロック暗号、具体的にはRC4とAESを使用した暗号化について詳細な説明が提供されます。

対称暗号についての議論を始める前に、この章および後続の章でのアリスとボブのイラストについて簡単にコメントしたいと思います。

___

暗号学の原理を説明する際、人々はしばしばアリスとボブを関わる例を頼りにします。私もそうします。

暗号学に新しい方は、これらのアリスとボブの例が、単純化された環境での暗号学の原理と構造を説明するためのものに過ぎないことを理解することが重要です。しかし、これらの原理と構造は、実生活のはるかに広範な文脈に適用可能です。
暗号学におけるアリスとボブを例に挙げた5つの重要なポイントは以下の通りです：
1. これらの例は、企業や政府機関など他のタイプのアクターに簡単に置き換えることができます。
2. 3人以上のアクターを含めるように簡単に拡張することができます。
3. 例では、ボブとアリスは通常、各メッセージの作成とそのメッセージに対する暗号化スキームの適用において積極的な参加者です。しかし実際には、電子通信は大部分が自動化されています。例えば、トランスポート層セキュリティを使用してウェブサイトを訪問する場合、暗号化は通常、あなたのコンピュータとウェブサーバーによって全て処理されます。
4. 電子通信の文脈では、通信チャネルを通じて送信される「メッセージ」は通常、TCP/IPパケットです。これらは、電子メール、Facebookメッセージ、電話会話、ファイル転送、ウェブサイト、ソフトウェアのアップロードなどに属することがあります。これらは伝統的な意味でのメッセージではありません。それでも、暗号学者はしばしば、メッセージは例えば電子メールであると単純化して述べます。
5. 例は通常、電子通信に焦点を当てていますが、手紙などの伝統的な通信形態にも拡張することができます。

## 対称暗号化スキーム
<chapterId>41bfdbe1-6d41-5272-98bb-81f24b2fd6af</chapterId>

**対称暗号化スキーム**を、3つのアルゴリズムを持つ任意の暗号化スキームとして緩く定義することができます：

1. **鍵生成アルゴリズム**、プライベートキーを生成します。
2. **暗号化アルゴリズム**、プライベートキーと平文を入力として受け取り、暗号文を出力します。
3. **復号アルゴリズム**、プライベートキーと暗号文を入力として受け取り、元の平文を出力します。

通常、暗号化スキーム（対称であれ非対称であれ）は、正確な仕様ではなく、コアアルゴリズムに基づいた暗号化のテンプレートを提供します。

例えば、対称暗号化スキームであるSalsa20を考えてみましょう。これは128ビットおよび256ビットの鍵長で使用することができます。鍵長に関する選択は、アルゴリズムのいくつかの細かい詳細（具体的にはアルゴリズムのラウンド数）に影響を与えます。

しかし、128ビットの鍵を使用してSalsa20を使用することが、256ビットの鍵を使用する場合と異なる暗号化スキームであるとは言わないでしょう。コアアルゴリズムは同じままです。コアアルゴリズムが変更された場合のみ、本当に2つの異なる暗号化スキームについて話すでしょう。

対称暗号化スキームは、通常、2種類のケースで特に有用です：(1) 2人以上のエージェントが距離を置いて通信し、その通信の内容を秘密に保ちたい場合、および(2) 1人のエージェントがメッセージの内容を時間をかけて秘密に保ちたい場合。

状況(1)の描写は下の*図1*で見ることができます。ボブは距離を置いてアリスにメッセージ$M$を送りたいが、他の人にそのメッセージを読まれたくありません。

ボブは最初にプライベートキー$K$を使ってメッセージ$M$を暗号化します。それから、暗号文$C$をアリスに送ります。アリスが暗号文を受け取ると、キー$K$を使用してそれを復号し、平文を読むことができます。良い暗号化スキームでは、暗号文$C$を傍受した攻撃者は、メッセージ$M$について実質的に重要なことを何も学ぶことができないはずです。

状況(2)の描写は下の*図2*で見ることができます。ボブは、特定の情報を他人が閲覧するのを防ぎたいと考えています。典型的な状況は、ボブが従業員であり、外部の人や同僚に読まれるべきではない機密データをコンピュータに保存している場合です。
Bobは、時刻$T_0$にメッセージ$M$を鍵$K$で暗号化して暗号文$C$を生成します。時刻$T_1$になり、彼は再びメッセージが必要になり、鍵$K$で暗号文$C$を復号します。その間に暗号文$C$を見つけたかもしれない攻撃者は、それから$M$について何か重要なことを推測できないようにする必要があります。

*図1: 空間を越えた秘密*

![図1: 空間を越えた秘密](assets/Figure4-1.webp "Figure 1: Secrecy across space")

*図2: 時間を越えた秘密*

![図2: 時間を越えた秘密](assets/Figure4-2.webp "Figure 2: Secrecy across time")

## 例: シフト暗号
<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

第2章では、非常に単純な対称暗号化方式の例としてシフト暗号について学びました。ここで再び見てみましょう。

英語のアルファベットのすべての文字を順番に数値の集合$\{0,1,2,\dots,25\}$と等価とする辞書*D*を想定します。可能なメッセージの集合**M**を仮定します。シフト暗号は、次のように定義される暗号化方式です：

- 可能な鍵の集合**K**、ここで**K** = $\{0,1,2,\dots,25\}$からランダムに鍵$k$を選択します
- メッセージ$m \in$ **M**を次のように暗号化します：
    - $m$を個々の文字$m_0, m_1,\dots, m_i, \dots, m_l$に分割します
    - *D*に従って各$m_i$を数値に変換します
    - 各$m_i$について、$c_i = [(m_i + k) \mod 26]$
    - *D*に従って各$c_i$を文字に変換します
    - それから$c_0, c_1,\dots, c_l$を組み合わせて暗号文$c$を生成します
- 暗号文$c$を次のように復号します：
    - *D*に従って各$c_i$を数値に変換します
    - 各$c_i$について、$m_i = [(c_i - k) \mod 26]$
    - *D*に従って各$m_i$を文字に変換します
    - それから$m_0, m_1,\dots, m_l$を組み合わせて元のメッセージ$m$を生成します

シフト暗号が対称暗号化方式であることの特徴は、暗号化と復号の両方のプロセスに同じ鍵が使用されることです。例えば、シフト暗号を使用してメッセージ「DOG」を暗号化し、ランダムに"24"という鍵を選択したとします。この鍵でメッセージを暗号化すると「BME」が得られます。元のメッセージを取り出す唯一の方法は、復号プロセスにも同じ鍵"24"を使用することです。

このシフト暗号は**単一換字式暗号**の一例です：暗号文アルファベットが固定されている（つまり、1つのアルファベットのみが使用される）暗号化方式です。復号アルゴリズムが決定的であると仮定すると、置換暗号文の各記号は、平文の1つの記号に最大で関連付けられます。
1700年代まで、多くの暗号化の応用は単一換字式暗号に大きく依存していましたが、これらはしばしばシフト暗号よりもはるかに複雑でした。例えば、元のテキストの各文字に対してアルファベットからランダムに文字を選択し、その文字が暗号文のアルファベット内で一度しか出現しないという制約の下で行うことができます。これは、プライベートキーが階乗26、つまり非常に多くの可能性があることを意味し、これはコンピューター以前の時代には膨大な数でした。
暗号学では**cipher（暗号）**という用語に頻繁に出会うことになりますが、この用語には様々な意味があることに注意してください。実際、私は暗号学の中でこの用語の少なくとも5つの異なる意味を知っています。

場合によっては、シフト暗号や単一換字式暗号のように、暗号化スキームを指すことがあります。しかし、この用語は特に暗号化アルゴリズム、プライベートキー、またはそのような暗号化スキームの任意の暗号文を指すこともあります。

最後に、cipherという用語は、暗号化スキームを構築することができるコアアルゴリズムを指すこともあります。これには様々な暗号化アルゴリズムだけでなく、他のタイプの暗号化スキームも含まれます。この用語の意味は、ブロック暗号のコンテキスト（下記の「ブロック暗号」セクションを参照）で関連してきます。

また、**encipher（暗号化する）**や**decipher（復号する）**という用語に出会うこともあります。これらの用語は単に暗号化と復号の同義語です。

## Brute force attacks and Kerckhoff's principle
<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

シフト暗号は、少なくとも現代の世界では、非常に安全性の低い対称暗号化スキームです。[1] 攻撃者は、意味のある結果が得られるまで、26の可能なキーすべてで暗号文の復号を試みることができます。このタイプの攻撃、つまり攻撃者が何が機能するかを見るためにキーを順番に試すことは、**brute force attack（ブルートフォース攻撃）**または**exhaustive key search（徹底的なキー検索）**として知られています。

任意の暗号化スキームが最小限のセキュリティ概念を満たすためには、ブルートフォース攻撃が非現実的なほど大きなキーのセット、または**keyspace（キースペース）**を持っていなければなりません。すべての現代の暗号化スキームはこの基準を満たしています。これは**sufficient key space principle（十分なキースペースの原則）**として知られています。類似の原則は、異なるタイプの暗号化スキームにも通常適用されます。

現代の暗号化スキームの膨大なキースペースのサイズを感じるために、ファイルが128ビットキーを使用して高度な暗号化標準で暗号化されたと仮定します。これは、攻撃者がブルートフォース攻撃のために通過する必要がある$2^{128}$のキーセットを持っていることを意味します。この戦略で0.78%の成功率を得るには、攻撃者はおよそ$2.65 \times 10^{36}$のキーを通過する必要があります。

攻撃者が1秒あたり$10^{16}$キー（つまり、10京キー）を試みることができると楽観的に仮定した場合、キースペース内のすべてのキーの0.78%をテストするには、彼女の攻撃は$2.65 \times 10^{20}$秒続く必要があります。これは約8.4兆年に相当します。したがって、現代の128ビット暗号化スキームでは、非常に強力な敵によるブルートフォース攻撃も現実的ではありません。これが十分なキースペースの原則が機能している例です。

暗号化アルゴリズムを攻撃者が知らない場合、シフト暗号はより安全ですか？おそらくそうですが、それほどではありません。
いずれにせよ、現代の暗号学では、あらゆる対称暗号方式のセキュリティが秘密鍵を秘密に保つことのみに依存していると常に仮定されます。攻撃者は、メッセージ空間、鍵空間、暗号文空間、鍵選択アルゴリズム、暗号化アルゴリズム、および復号アルゴリズムを含む、他のすべての詳細を知っていると常に仮定されます。
対称暗号方式のセキュリティが秘密鍵の秘密にのみ依存できるという考え方は、**ケルクホフスの原則**として知られています。

ケルクホフスが当初意図したように、この原則は対称暗号方式にのみ適用されます。しかし、より一般的なバージョンの原則は、他のすべての現代の暗号方式にも適用されます：あらゆる暗号方式の設計は、それが安全であるために秘密である必要はなく、秘密は典型的には秘密鍵といった情報の文字列にのみ及ぶことができます。

ケルクホフスの原則は、四つの理由から現代の暗号学にとって中心的なものです。[2] 第一に、特定のタイプのアプリケーションに対する暗号方式の数は限られています。たとえば、ほとんどの現代の対称暗号アプリケーションはRijndael暗号を使用しています。したがって、方式の設計に関するあなたの秘密は非常に限られています。しかし、Rijndael暗号のいくつかの秘密鍵を秘密に保つことには、はるかに多くの柔軟性があります。

第二に、情報の文字列を交換することは、暗号方式全体を交換することよりも簡単です。会社の従業員全員が同じ暗号化ソフトウェアを持ち、二人の従業員ごとに機密通信のための秘密鍵を持っていると仮定します。このシナリオでは鍵の妥協は面倒ですが、少なくとも会社はそのようなセキュリティ違反のソフトウェアを保持できます。会社が方式の秘密に依存していた場合、その秘密の違反はすべてのソフトウェアを交換することを要求します。

第三に、ケルクホフスの原則は、暗号方式のユーザー間の標準化と互換性を可能にします。これは効率に大きな利点をもたらします。たとえば、そのセキュリティが暗号方式を秘密に保つことを要求した場合、毎日何百万人もの人々がGoogleのWebサーバーに安全に接続することがいかに困難かを想像するのは難しいです。

第四に、ケルクホフスの原則は、暗号方式の公開検証を可能にします。このタイプの検証は、安全な暗号方式を達成するために絶対に必要です。例示的に、対称暗号学の主要なコアアルゴリズムであるRijndael暗号は、1997年から2000年にかけて国立標準技術研究所によって組織されたコンペティションの結果でした。

**セキュリティ・バイ・オブスキュリティ（曖昧さによるセキュリティ）**を達成しようとするあらゆるシステムは、その設計および/または実装の詳細を秘密に保つことに依存するシステムです。暗号学において、これは具体的には暗号方式の設計の詳細を秘密に保つことに依存するシステムです。したがって、セキュリティ・バイ・オブスキュリティはケルクホフスの原則と直接対立します。

オープンネスの能力が品質とセキュリティを強化することは、暗号学だけでなくデジタル世界全体にも広がります。たとえば、DebianのようなフリーでオープンソースのLinuxディストリビューションは、プライバシー、安定性、セキュリティ、柔軟性の点でWindowsやMacOSの対応物よりもいくつかの利点を一般的に持っています。それには複数の原因があるかもしれませんが、エリック・レイモンドが彼の有名なエッセイ「大聖堂とバザール」で述べたように、最も重要な原則はおそらく「十分な数の目があれば、すべてのバグは浅い」というものです。[3] これは群衆の知恵のタイプの原則であり、Linuxに最大の成功をもたらしました。
暗号化スキームが「安全」または「不安全」と断定的に言えることは決してありません。代わりに、暗号化スキームにはさまざまなセキュリティの概念が存在します。**暗号セキュリティの定義**は、(1) セキュリティ目標と、(2) 攻撃者の能力を指定する必要があります。特定のセキュリティ概念に対する暗号化スキームの分析は、そのアプリケーションと制限への洞察を提供します。
暗号セキュリティのさまざまな概念の詳細には踏み込みませんが、対称および非対称スキーム（および他の暗号プリミティブの形式でも）に関連するすべての現代の暗号セキュリティ概念に共通する2つの仮定を知っておくべきです：

* 攻撃者のスキームに関する知識は、ケルクホッフスの原則に準拠しています。
* 攻撃者は、スキームに対して実行可能な形でのブルートフォース攻撃を行うことができません。具体的には、暗号セキュリティの概念の脅威モデルは、これらが関連する考慮事項ではないと仮定して、ブルートフォース攻撃を許可すらしません。

**注釈:**

[1] スエトニウスによると、ジュリアス・シーザーは軍事通信において、常にキー値が3であるシフト暗号を使用しました。したがって、Aは常にDに、Bは常にEに、Cは常にFになります。この特定のシフト暗号のバージョンは、キー値が一定であるため、現代の言葉の意味での暗号とは実際には異なりますが、**シーザー暗号**として知られるようになりました。シーザー暗号は紀元前1世紀において、ローマの敵が暗号化に非常に不慣れであれば、安全だったかもしれません。しかし、現代では非常に安全なスキームとは言えません。

[2] Jonathan KatzとYehuda Lindell, _Introduction to Modern Cryptography_, CRC Press (Boca Raton, FL: 2015), p. 7f.

[3] Eric Raymond, “The Cathedral and the Bazaar,” はLinux Kongressで発表された論文です, Würzburg, Germany (1997年5月27日)。後にいくつかのバージョンが利用可能になり、また本も出版されました。私の引用は本の30ページからです: Eric Raymond, _The Cathedral and the Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary_, 改訂版. (2001), O’Reilly: Sebastopol, CA.

## ストリーム暗号
<chapterId>479aa6f4-45c4-59ca-8616-8cf8e61fc871</chapterId>

対称暗号化スキームは標準的に**ストリーム暗号**と**ブロック暗号**の2つのタイプに分類されます。しかし、この区別はやや問題があります。なぜなら、人々はこれらの用語を一貫性のない方法で使用するからです。次の数節で、私が最も適切だと思う方法でこの区別を説明します。しかし、多くの人が私が説明する方法とは異なる方法でこれらの用語を使用することに注意してください。

まず、ストリーム暗号について説明しましょう。**ストリーム暗号**は、暗号化が2つのステップで構成される対称暗号化スキームです。

最初に、プレーンテキストの長さの文字列がプライベートキーを介して生成されます。この文字列は**キーストリーム**と呼ばれます。

次に、キーストリームはプレーンテキストと数学的に組み合わされて暗号文を生成します。この組み合わせは通常、XOR操作です。復号化には、単に操作を逆にすることができます。（$A \oplus B = B \oplus A$の場合、$A$と$B$がビット文字列であるため、ストリーム暗号のXOR操作の順序は結果に影響しません。この性質は**交換性**として知られています。）
*図3: XORストリーム暗号*

典型的なXORストリーム暗号は、*図3*に示されています。まず、秘密鍵$K$を取り、それを使用して鍵ストリームを生成します。次に、この鍵ストリームを平文とXOR演算で組み合わせて、暗号文を生成します。暗号文を受け取ったエージェントは、鍵$K$を持っていれば簡単にそれを復号できます。彼女が必要とするのは、指定された手順に従って暗号文と同じ長さの鍵ストリームを作成し、それを暗号文とXORすることだけです。

*図3: XORストリーム暗号*

![図3: XORストリーム暗号](assets/Figure4-3.webp "図3: XORストリーム暗号")

暗号化スキームは通常、同じコアアルゴリズムを使用した暗号化のテンプレートであり、正確な仕様ではないことに注意してください。同様に、ストリーム暗号も異なる長さの鍵を使用できる暗号化のテンプレートです。鍵の長さはスキームの一部の細かい詳細に影響を与えるかもしれませんが、その本質的な形には影響を与えません。

シフト暗号は、非常に単純で安全でないストリーム暗号の一例です。単一の文字（秘密鍵）を使用して、メッセージの長さの文字列（鍵ストリーム）を生成できます。次に、この鍵ストリームを平文と組み合わせて、モジュロ演算を使用して暗号文を生成します。（このモジュロ演算は、文字をビットで表現する場合にXOR演算に簡略化できます）。

ストリーム暗号のもう一つの有名な例は、16世紀の終わりにブレーズ・ド・ヴィジェネールが完全に開発した**ヴィジェネール暗号**です（他の多くの人々が先行して多くの作業を行っていました）。これは**多表式換字暗号**の一例です：平文記号の暗号文アルファベットがテキスト内の位置に応じて変化する暗号化スキームです。単表式換字暗号とは対照的に、暗号文記号は複数の平文記号と関連付けられることがあります。

暗号化がルネッサンス期のヨーロッパで人気を博するにつれて、**暗号解読**も特に**頻度分析**を使用して暗号文を解読することが、特に軍事およびセキュリティ設定において、1700年代のヨーロッパで頻度分析に対してもはや十分ではなくなった最も洗練された単表式換字暗号でさえも、特に人気を博しました。ヴィジェネール暗号は安全性において大きな進歩を提供したため、この時期に人気を博し、1700年代後半には広く普及しました。

非公式には、暗号化スキームは次のように機能します：

1. 私的鍵として複数文字の単語を選択します。
2. 任意のメッセージに対して、鍵単語の対応する文字をシフトとして使用して、メッセージの各文字にシフト暗号を適用します。
3. 鍵単語を一巡したが、まだ平文を完全に暗号化していない場合は、再び鍵単語の文字をテキストの残りの対応する文字にシフト暗号として適用します。
4. このプロセスを続けて、メッセージ全体が暗号化されるまで続けます。

例として、あなたの秘密鍵が「GOLD」であり、メッセージ「CRYPTOGRAPHY」を暗号化したい場合、ヴィジェネール暗号に従って次のように進めます：

- $c_0  = [(2 + 6) \mod 26] = 8 = I$
- $c_1  = [(17 + 14) \mod 26] = 5 = F$
- $c_2  = [(24 + 11) \mod 26] = 9 = J$
- $c_3 = [(15 + 3) \mod 26] = 18 = S$
- $c_4 = [(19 + 6) \mod 26] = 25 = Z$
- $c_5 = [(14 + 14) \mod 26] = 2 = C$
- $c_6 = [(6 + 11) \mod 26] = 17 = R$
- $c_7 = [(17 + 3) \mod 26] = 20 = U$
- $c_8 = [(0 + 6) \mod 26] = 6 = G$
- $c_9 = [(15 + 14) \mod 26] = 3 = D$
- $c_{10} = [(7 + 11) \mod 26] = 18 = S$
- $c_{11} = [(24 + 3) \mod 26] = 1 = B$

したがって、暗号文 $c$ = "IFJSZCRUGDSB" です。

ストリーム暗号のもう一つの有名な例は、**ワンタイムパッド**です。ワンタイムパッドでは、平文メッセージと同じ長さのランダムビットの文字列を単純に作成し、XOR演算を通じて暗号文を生成します。したがって、ワンタイムパッドではプライベートキーとキーストリームが等価です。

シフト暗号やヴィジュネル暗号は現代では非常に安全ではありませんが、ワンタイムパッドは正しく使用された場合には非常に安全です。ワンタイムパッドの最も有名な応用例は、少なくとも1980年代までは、**ワシントン-モスクワホットライン**でした。[4]

ホットラインは、キューバ危機の後に設置された、緊急事態におけるワシントンとモスクワ間の直接通信リンクです。この技術は年々変化しており、現在では直接の光ファイバーケーブルと2つの衛星リンク（冗長性のため）を含み、電子メールやテキストメッセージングが可能です。リンクの終点はアメリカの様々な場所にあります。ペンタゴン、ホワイトハウス、レイブンロック山が知られている終点です。一般的な意見とは異なり、ホットラインは電話を使用したことがありません。

本質的に、ワンタイムパッドの仕組みは次のように機能しました。ワシントンとモスクワは、ランダムな数字の2セットを持っていました。ロシア人によって作成されたランダムな数字の1セットは、ロシア語のメッセージの暗号化と復号化に関連していました。アメリカ人によって作成されたランダムな数字の1セットは、英語のメッセージの暗号化と復号化に関連していました。時々、信頼できる宅配便によって他方により多くのランダムな数字が届けられました。

それから、ワシントンとモスクワは、これらのランダムな数字を使用してワンタイムパッドを作成し、秘密裏に通信することができました。通信する必要があるたびに、メッセージのためにランダムな数字の次の部分を使用します。

非常に安全であるにもかかわらず、ワンタイムパッドは実用的な制約に直面しています：キーはメッセージと同じ長さでなければならず、ワンタイムパッドの一部を再利用することはできません。これは、ワンタイムパッドのどこにいるかを追跡し、大量のビットを保存し、時々相手とランダムビットを交換する必要があることを意味します。その結果、ワンタイムパッドは実際には頻繁に使用されません。

代わりに、実際に使用される主流のストリーム暗号は**擬似ランダムストリーム暗号**です。Salsa20とその密接に関連する変種であるChaChaは、一般的に使用される擬似ランダムストリーム暗号の例です。
これらの擬似乱数ストリーム暗号では、まず平文の長さよりも短い鍵Kをランダムに選択します。このようなランダム鍵Kは通常、ネットワークメッセージ間の時間、マウスの動きなど、予測不可能なデータを基にして私たちのコンピュータによって作成されます。
このランダム鍵$K$は、メッセージと同じ長さの擬似乱数鍵ストリームを生成する拡張アルゴリズムに挿入されます。鍵ストリームの正確な長さを指定することができます（例：500ビット、1000ビット、1200ビット、29,117ビットなど）。

擬似乱数鍵ストリームは、同じ長さのすべての文字列のセットから完全にランダムに選ばれたかのように*見えます*。したがって、擬似乱数鍵ストリームを使用した暗号化は、ワンタイムパッドで行われたかのように見えます。しかし、もちろんそうではありません。

私たちの秘密鍵は鍵ストリームよりも短く、暗号化/復号化プロセスが機能するためには拡張アルゴリズムが決定論的である必要があるため、その特定の長さの鍵ストリームが私たちの拡張操作から出力として得られたわけではありません。

例えば、私たちの秘密鍵が128ビットの長さを持ち、それを拡張アルゴリズムに挿入してはるかに長い鍵ストリーム、例えば2500ビットを作成できるとします。拡張アルゴリズムが決定論的である必要があるため、私たちのアルゴリズムは最大で$1/2^{128}$の2500ビットの長さの文字列を選択できます。したがって、そのような鍵ストリームは同じ長さのすべての文字列から完全にランダムに選択されることは決してありません。

ストリーム暗号の定義には2つの側面があります：(1) 私鍵の助けを借りて平文と同じ長さの鍵ストリームが生成されること、および(2) この鍵ストリームが平文と組み合わされ、通常はXOR操作を介して暗号文を生成すること。

時々、人々は条件(1)をより厳密に定義し、鍵ストリームは特に擬似乱数でなければならないと主張します。これは、シフト暗号やワンタイムパッドがストリーム暗号と見なされないことを意味します。

私の見解では、条件(1)をより広く定義することは、暗号化スキームを整理するためのより簡単な方法を提供します。さらに、特定の暗号化スキームが擬似乱数鍵ストリームに実際に依存していないことがわかったとしても、それをストリーム暗号と呼ぶのをやめる必要がないことを意味します。

**ノート:**

[4] Crypto Museum, "Washington-Moscow hotline," 2013, [https://www.cryptomuseum.com/crypto/hotline/index.htm](https://www.cryptomuseum.com/crypto/hotline/index.htm)で入手可能。

## ブロック暗号
<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

**ブロック暗号**が一般的に理解される最初の方法は、ストリーム暗号よりも原始的なものとしてです：適切な長さの文字列に対して鍵の助けを借りて長さを保持する変換を実行するコアアルゴリズム。このアルゴリズムは、暗号化スキームの作成や他の種類の暗号スキームの作成に使用できます。
ブロック暗号は、64ビット、128ビット、または256ビットなど、さまざまな長さの入力文字列を取り扱うことができるほか、128ビット、192ビット、または256ビットなど、さまざまな長さの鍵も扱うことができます。アルゴリズムのいくつかの詳細はこれらの変数に応じて変更されるかもしれませんが、コアアルゴリズム自体は変わりません。もし変わるのであれば、それは異なる二つのブロック暗号について話していることになります。ここでのコアアルゴリズムという用語の使用は、暗号化スキームにおけるそれと同じです。

ブロック暗号の動作方法は、以下の*図4*で見ることができます。長さ$L$のメッセージ$M$と鍵$K$がブロック暗号への入力として与えられます。それは長さ$L$のメッセージ$M'$を出力します。ほとんどのブロック暗号において、鍵は$M$および$M'$と同じ長さである必要はありません。

*図4: ブロック暗号*

![図4: ブロック暗号](assets/Figure4-4.webp "図4: ブロック暗号")

ブロック暗号自体は暗号化スキームではありません。しかし、ブロック暗号は様々な**動作モード**と組み合わせることで、異なる暗号化スキームを生成することができます。動作モードは単にブロック暗号の外側でいくつかの追加操作を加えるものです。

これがどのように機能するかを説明するために、128ビットの入力文字列と128ビットの秘密鍵を必要とするブロック暗号(BC)を想定してみましょう。以下の図5は、そのブロック暗号を**電子コードブックモード**（**ECBモード**）と組み合わせて暗号化スキームを作成する方法を示しています。（右側の省略符は、必要な限りこのパターンを繰り返すことができることを示しています）。

*図5: ECBモードを使用したブロック暗号*

![図5: ECBモードを使用したブロック暗号](assets/Figure4-5.webp "図5: ECBモードを使用したブロック暗号")

ブロック暗号を使用した電子コードブック暗号化のプロセスは次のとおりです。プレーンテキストメッセージを128ビットブロックに分割できるか確認してください。できない場合は、メッセージに**パディング**を追加して、結果が128ビットのブロックサイズで均等に分割できるようにします。これが暗号化プロセスに使用されるデータです。

次に、データを128ビット文字列（$M_1$、$M_2$、$M_3$、など）のチャンクに分割します。各128ビット文字列を128ビット鍵でブロック暗号を通して実行し、128ビットの暗号テキストチャンク（$C_1$、$C_2$、$C_3$、など）を生成します。これらのチャンクを再結合すると、完全な暗号テキストが形成されます。

復号はただの逆プロセスですが、受信者は復号化されたデータからパディングを取り除き、元のプレーンテキストメッセージを生成するための認識可能な方法が必要です。

比較的単純であるにもかかわらず、電子コードブックモードを使用したブロック暗号はセキュリティが欠けています。これは、**決定論的暗号化**につながるためです。同一の128ビットデータ文字列が全く同じ方法で暗号化されます。その情報は悪用される可能性があります。

代わりに、ブロック暗号から構築された任意の暗号化スキームは**確率的**であるべきです：つまり、任意のメッセージ$M$、または$M$の特定のチャンクの暗号化は、通常、毎回異なる結果をもたらすべきです。[5]

**暗号ブロック連鎖モード**（**CBCモード**）は、ブロック暗号で最も一般的に使用されるモードかもしれません。正しく組み合わせると、確率的な暗号化スキームが生成されます。この動作モードの描写は、以下の*図6*で見ることができます。

*図6: CBCモードを使用したブロック暗号*
![Figure 6: CBCモードを使用したブロック暗号](assets/Figure4-6.webp "図6: CBCモードを使用したブロック暗号")
ブロックサイズが再び128ビットであると仮定します。したがって、開始するには、元の平文メッセージが必要なパディングを受け取ることを再度確認する必要があります。

その後、平文の最初の128ビット部分を128ビットの**初期化ベクトル**とXORします。その結果はブロック暗号に入れられ、最初のブロックの暗号文を生成します。128ビットの2番目のブロックについては、最初に平文を最初のブロックの暗号文とXORし、それをブロック暗号に挿入します。このプロセスを、平文メッセージ全体を暗号化するまで続けます。

終了したら、暗号化されたメッセージと暗号化されていない初期化ベクトルを受信者に送信します。受信者は初期化ベクトルを知る必要があります。そうでなければ、暗号文を復号できません。

この構造は、正しく使用された場合、電子コードブックモードよりもはるかに安全です。まず、初期化ベクトルがランダムまたは擬似ランダム文字列であることを確認する必要があります。さらに、この暗号化スキームを使用するたびに異なる初期化ベクトルを使用するべきです。

言い換えれば、初期化ベクトルはランダムまたは擬似ランダムのnonceであるべきです。ここで、**nonce**は「一度だけ使用される数」を意味します。この習慣を守れば、ブロック暗号をCBCモードで使用すると、同一の平文ブロックが毎回異なって暗号化されることが保証されます。

最後に、**出力フィードバックモード**（**OFBモード**）に注目しましょう。このモードの描写は*図7*で見ることができます。

*図7: OFBモードを使用したブロック暗号*

![図7: OFBモードを使用したブロック暗号](assets/Figure4-7.webp "図7: OFBモードを使用したブロック暗号")

OFBモードでは、初期化ベクトルも選択します。しかし、ここでは最初のブロックについて、初期化ベクトルがあなたの鍵とともに直接ブロック暗号に挿入されます。その結果得られる128ビットは、キーストリームとして扱われます。このキーストリームは平文とXORされ、ブロックの暗号文を生成します。次のブロックについては、前のブロックのキーストリームをブロック暗号に入力として使用し、手順を繰り返します。

注意深く見ると、OFBモードのブロック暗号から実際に作成されたのはストリーム暗号です。平文の長さになるまで128ビットのキーストリーム部分を生成し（最後の128ビットキーストリーム部分から必要ないビットを破棄します）、その後、キーストリームを平文メッセージとXORして暗号文を得ます。

前のセクションのストリーム暗号について述べたように、秘密鍵の助けを借りてキーストリームを生成します。正確には、秘密鍵だけでなく、初期化ベクトルのサポートを受けてキーストリームが生成されることもあります。

CBCモードと同様に、OFBモードでブロック暗号を使用するたびに、初期化ベクトルに対して擬似ランダムまたはランダムnonceを選択することが重要です。そうでなければ、異なる通信で送信された同じ128ビットメッセージ文字列が同じ方法で暗号化されます。これはストリーム暗号で確率的暗号化を作成する方法の一つです。
いくつかのストリーム暗号は、プライベートキーのみを使用して鍵ストリームを生成します。そのようなストリーム暗号においては、通信の各インスタンスに対してプライベートキーを選択するためにランダムなnonceを使用することが重要です。そうでない場合、それらのストリーム暗号を使用した暗号化の結果も決定論的になり、セキュリティ上の問題を引き起こします。
最も人気のある現代のブロック暗号は、**Rijndael暗号**です。これは、1997年から2000年にかけて国立標準技術研究所（NIST）が開催したコンペティションで、古い暗号化標準である**データ暗号化標準**（**DES**）の代替を目的として、15の提案の中から選ばれたものです。

Rijndael暗号は、鍵長とブロックサイズの異なる仕様、および運用モードの異なる形で使用することができます。NISTコンペティションの委員会は、128ビットのブロックサイズと、128ビット、192ビット、または256ビットの鍵長を要求するRijndael暗号の制限バージョンを、**高度暗号化標準**（**AES**）の一部として採用しました。これは、対称暗号化アプリケーションの主要な標準です。それは非常に安全で、NSAでさえも256ビットキーを使用して最高機密文書に使用することを認めています。[6]

AESブロック暗号については、*第5章*で詳しく説明されます。

**注釈:**

[5] 確率的暗号化の重要性は、Shafi GoldwasserとSilvio Micaliによって最初に強調されました。「Probabilistic encryption」、_Journal of Computer and System Sciences_、28 (1984)、270–99。

[6] NSA, "Commercial National Security Algorithm Suite"を参照、[https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm](https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm)。

## 混乱の解消
<chapterId>121c1858-27e3-5862-b0ce-4ff2f70f9f0f</chapterId>

ブロック暗号とストリーム暗号の区別についての混乱は、時々人々がブロック暗号を具体的に*暗号化のブロックモードを持つブロック暗号*として理解することから生じます。

前のセクションのECBモードとCBCモードを考えてみましょう。これらは特に、暗号化のためのデータがブロックサイズで割り切れる必要があります（つまり、元のメッセージにパディングを使用する必要があるかもしれません）。さらに、これらのモードのデータはブロック暗号によって直接操作されます（OFBモードのようにブロック暗号操作の結果と単に組み合わされるのではありません）。

したがって、代わりに、**ブロック暗号**を、一度に固定長のメッセージブロックに操作を行う任意の暗号化スキームとして定義することができます（どのブロックもバイトより長くなければならず、そうでなければストリーム暗号になってしまいます）。暗号化のためのデータと暗号文は、このブロックサイズに均等に分割されなければなりません。通常、ブロックサイズは64、128、192、または256ビットの長さです。対照的に、ストリーム暗号は、一度に1ビットまたは1バイトのチャンクで任意のメッセージを暗号化することができます。

このより具体的なブロック暗号の理解を持つことで、現代の暗号化スキームはストリーム暗号またはブロック暗号のいずれかであると確かに主張することができます。ここから先は、特に指定されていない限り、ブロック暗号という用語をより一般的な意味で使用します。
前のセクションでのOFBモードに関する議論は、もう一つ興味深い点を提起しています。一部のストリーム暗号は、OFBを使用したRijndaelのようにブロック暗号から構築されています。Salsa20やChaChaのように、ブロック暗号から作られていないものもあります。後者を**原始ストリーム暗号**と呼ぶことができます。（このようなストリーム暗号を指す標準化された用語は実際にはありません。）
人々がストリーム暗号とブロック暗号の利点と欠点について話すとき、彼らは通常、原始ストリーム暗号とブロック暗号に基づく暗号化スキームを比較しています。

ブロック暗号からストリーム暗号を簡単に構築することは常に可能ですが、原始ストリーム暗号からブロック暗号モードの暗号化（CBCモードなど）で何らかの構造を構築することは、通常非常に困難です。

この議論から、*図8*を理解するべきです。これは対称暗号化スキームの概要を提供します。私たちは3種類の暗号化スキームを使用します：原始ストリーム暗号、ブロック暗号ストリーム暗号、およびブロックモードのブロック暗号（図では「ブロック暗号」と呼ばれています）。

*図8: 対称暗号化スキームの概要*

![図8: 対称暗号化スキームの概要](assets/Figure4-8.webp "図8: 対称暗号化スキームの概要")


## メッセージ認証コード
<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>

暗号化は秘密性に関係しています。しかし、暗号学はまた、メッセージの完全性、真正性、および否認防止など、より広いテーマにも関係しています。いわゆる**メッセージ認証コード**（MAC）は、通信における真正性と完全性をサポートする対称キー暗号スキームです。

通信に秘密性以外のものがなぜ必要かというと、例えばBobが実質的に破られない暗号を使用してAliceにメッセージを送ったとします。このメッセージを傍受した攻撃者は、内容に関して有意な洞察を得ることができません。しかし、攻撃者には少なくとも他に2つの攻撃ベクトルが利用可能です：

1. 彼女は暗号文を傍受し、その内容を変更して、変更された暗号文をAliceに送信することができます。
2. 彼女はBobのメッセージを完全にブロックし、自分自身で作成した暗号文を送信することができます。

これらのケースでは、攻撃者は暗号文（1）および（2）から内容に関する洞察を持っていないかもしれません。しかし、このような方法で依然として重大な損害を引き起こすことができます。ここでメッセージ認証コードが重要になります。

メッセージ認証コードは、キー生成アルゴリズム、タグ生成アルゴリズム、および検証アルゴリズムの3つのアルゴリズムを持つ対称暗号スキームとして緩く定義されています。安全なMACは、攻撃者がプライベートキーを持っていない限り、メッセージに対して検証されるタグを成功裏に作成することができないことを保証します。これは、**実存的に偽造不可能**であることを意味します。

BobとAliceは、MACを使用して特定のメッセージの操作と戦うことができます。一時的に秘密性には関心がないと仮定します。彼らが保証したいのは、Aliceに届いたメッセージが確かにBobからのものであり、何らかの方法で変更されていないことです。

プロセスは*図9*に示されています。**MAC**（メッセージ認証コード）を使用するには、まず彼らの間で共有されるプライベートキー$K$を生成します。Bobはプライベートキー$K$を使用してメッセージに対するタグ$T$を作成します。彼はその後、メッセージとメッセージタグをAliceに送信します。彼女は、プライベートキー、メッセージ、およびタグを検証アルゴリズムを通して実行することによって、Bobが確かにタグを作成したことを検証することができます。

*図9: 対称暗号化スキームの概要*
![図9: 対称暗号化スキームの概要](assets/Figure4-9.webp "図9: 対称暗号化スキームの概要")
**存在偽造不可能性**により、攻撃者はメッセージ$M$をいかなる方法でも変更したり、有効なタグを持つ自身のメッセージを作成することができません。これは、攻撃者が同じ秘密鍵を使用してボブとアリスの間で交換される多くのメッセージのタグを観察していても同様です。攻撃者ができるのは、せいぜいアリスがメッセージ$M$を受け取るのを妨げることだけです（これは暗号学では対処できない問題です）。

MACは、メッセージが実際にボブによって作成されたことを保証します。この真正性は、自動的にメッセージの完全性を意味します。つまり、ボブが何らかのメッセージを作成した場合、そのメッセージは攻撃者によっていかなる方法でも変更されていないということです。したがって、ここから先、認証に関するあらゆる懸念は、完全性に関する懸念を自動的に意味するものと理解されるべきです。

私が議論でメッセージの真正性と完全性の区別を引いたとしても、これらの用語を同義語として使用することは一般的です。それらは、特定の送信者によって作成され、いかなる方法でも変更されていないメッセージのアイデアを指します。この精神において、メッセージ認証コードは頻繁に**メッセージ完全性コード**とも呼ばれます。

## 認証付き暗号化
<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>

通常、通信において秘密性と真正性の両方を保証したい場合があります。したがって、暗号化スキームとMACスキームは通常、一緒に使用されます。

**認証付き暗号化スキーム**は、暗号化とMACを高度に安全な方法で組み合わせたスキームです。具体的には、存在偽造不可能性の基準と、非常に強力な秘密性の概念、すなわち**選択暗号文攻撃**に対する耐性の基準を満たす必要があります。[7]

暗号化スキームが選択暗号文攻撃に耐性を持つためには、**非可塑性**の基準を満たす必要があります。つまり、攻撃者による暗号文の任意の変更は、無効な暗号文または元のものとは関係のないプレーンテキストに復号される暗号文を生じさせるべきです。[8]

認証付き暗号化スキームは、攻撃者によって作成された暗号文が常に無効であること（タグが検証されないため）を保証するため、選択暗号文攻撃に対する耐性の基準を満たします。興味深いことに、存在偽造不可能なMACと、より弱いセキュリティ概念である**選択平文攻撃セキュリティ**を満たす暗号化スキームの組み合わせから、常に認証付き暗号化スキームを作成できることが証明できます。

認証付き暗号化スキームの構築の詳細には踏み込みませんが、その構築の2つの詳細を知っておくことが重要です。

まず、認証付き暗号化スキームは最初に暗号化を処理し、次に暗号文に対してメッセージタグを作成します。プレーンテキストに対するタグと暗号文を組み合わせる方法や、最初にタグを作成してからプレーンテキストとタグの両方を暗号化する方法など、他のアプローチは安全ではないことがわかります。さらに、両方の操作にはそれぞれランダムに選択された秘密鍵が必要であり、そうでなければセキュリティが大幅に損なわれます。

前述の原則は、より一般的に適用されます：*基本的な暗号スキームを組み合わせるときは、常に異なる鍵を使用すべきです*。

認証付き暗号化スキームは*図10*で示されています。ボブは最初にランダムに選択された鍵$K_C$を使用してメッセージ$M$から暗号文$C$を作成します。次に、異なるランダムに選択された鍵$K_T$と暗号文をタグ生成アルゴリズムに通してメッセージタグ$T$を作成します。暗号文とメッセージタグの両方がアリスに送信されます。
Aliceはまず、暗号文$C$と鍵$K_T$を用いて、タグが有効かどうかを確認します。有効であれば、鍵$K_C$を使用してメッセージを復号できます。これにより、彼女は通信の非常に強力な秘密性を確信するだけでなく、メッセージがBobによって作成されたことも知ることができます。
*図10: 認証付き暗号化スキーム*

![図10: 認証付き暗号化スキーム](assets/Figure4-10.webp "図10: 認証付き暗号化スキーム")

MACはどのように作成されるのでしょうか？MACは複数の方法で作成できますが、一般的で効率的な方法の一つは、**暗号学的ハッシュ関数**を介して作成することです。

暗号学的ハッシュ関数については、*第6章*でより詳しく紹介します。今のところ、**ハッシュ関数**は任意のサイズの入力を取り、固定長の出力を生成する効率的に計算可能な関数であることを知っておいてください。例えば、人気のあるハッシュ関数**SHA-256**（セキュアハッシュアルゴリズム256）は、入力のサイズに関係なく常に256ビットの出力を生成します。SHA-256のようないくつかのハッシュ関数は、暗号学で有用な応用があります。

暗号学的ハッシュ関数で生成される最も一般的なタグのタイプは、**ハッシュベースのメッセージ認証コード**（HMAC）です。このプロセスは、*図11*で示されています。ある当事者がプライベートキー$K$から2つの異なる鍵、内部鍵$K_1$と外部鍵$K_2$を生成します。平文$M$または暗号文$C$は内部鍵と一緒にハッシュされます。その結果$T'$は外部鍵と一緒にハッシュされ、メッセージタグ$T$を生成します。

HMACを作成するために使用できるハッシュ関数のパレットがあります。最も一般的に使用されるハッシュ関数はSHA-256です。

*図11: HMAC*

![図11: HMAC](assets/Figure4-11.webp "図11: HMAC")

**注釈:**

[7] このセクションで議論されている特定の結果は、KatzとLindellのpp. 131–47からのものです。

[8] 技術的には、選択暗号文攻撃の定義は非可塑性の概念とは異なります。しかし、これら2つのセキュリティの概念が等価であることを示すことができます。

## 安全な通信セッション
<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

2つの当事者が通信セッションにあると仮定すると、彼らは複数のメッセージを行き来させます。

認証付き暗号化スキームにより、メッセージの受信者はそのメッセージが通信セッションのパートナーによって作成されたことを確認できます（プライベートキーが漏洩していない限り）。これは単一のメッセージに対しては十分に機能します。しかし、通常、2つの当事者は通信セッションでメッセージを行き来させています。そして、その設定では、前のセクションで説明された通常の認証付き暗号化スキームは、セキュリティを提供することに短所があります。

主な理由は、認証付き暗号化スキームが、メッセージが実際に通信セッション内でそれを作成したエージェントによっても送信されたことを保証しないことです。以下の3つの攻撃ベクトルを考えてみましょう：

1. **リプレイ攻撃**: 攻撃者が以前に2つの当事者の間で傍受した暗号文とタグを再送信します。
2. **並び替え攻撃**: 攻撃者が異なる時間に2つのメッセージを傍受し、それらを逆の順序で受信者に送信します。
3. **リフレクション攻撃**: 攻撃者がAからBへ送信されたメッセージを観察し、そのメッセージをAにも送信します。

攻撃者が暗号文の知識を持たず、偽の暗号文を作成できない場合でも、上記の攻撃は通信において重大な損害を引き起こす可能性があります。
例えば、二者間の特定のメッセージが金融資金の移動を伴う場合を想定してください。リプレイ攻撃は、資金を二度移動させる可能性があります。バニラ認証暗号化スキームは、このような攻撃に対して防御手段を持ちません。
幸いなことに、これらの種類の攻撃は、**識別子**と**相対時間指標**を使用して通信セッションで簡単に軽減できます。

識別子は、暗号化前にプレーンテキストメッセージに追加することができます。これにより、リフレクション攻撃を防ぐことができます。相対時間指標は、例えば、特定の通信セッション内のシーケンス番号であることができます。各当事者は、暗号化前にメッセージにシーケンス番号を追加するので、受信者はメッセージが送信された順序を知ることができます。これにより、メッセージの再順序攻撃の可能性が排除されます。また、リプレイ攻撃も排除されます。攻撃者が送信する任意のメッセージは古いシーケンス番号を持っており、受信者はそのメッセージを再び処理しないことを知ります。

安全な通信セッションがどのように機能するかを示すために、再びアリスとボブを想定してください。彼らは合計で四つのメッセージを行き来します。識別子とシーケンス番号を備えた認証暗号化スキームがどのように機能するかは、*図11*で以下のように見ることができます。

通信セッションは、ボブがメッセージタグ $T_{0,B}$ を伴う暗号文 $C_{0,B}$ をアリスに送信することから始まります。暗号文にはメッセージの他に識別子（BOB）とシーケンス番号（0）が含まれています。タグ $T_{0,B}$ は暗号文全体に対して作成されます。その後の通信で、アリスとボブはこのプロトコルを維持し、必要に応じてフィールドを更新します。

*図12: 安全な通信セッション*

![図12: 安全な通信セッション](assets/Figure4-12.webp "図12: 安全な通信セッション")

# RC4とAES
<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

## RC4ストリーム暗号
<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>

この章では、現代のプリミティブストリーム暗号であるRC4（または "Rivest cipher 4"）と、現代のブロック暗号であるAESを使用した暗号化スキームの詳細について議論します。RC4暗号は暗号化方法として不評になっていますが、AESは現代の対称暗号化の標準です。これら二つの例は、対称暗号化が内部でどのように機能するかについてより良い理解を与えるはずです。

___

現代の擬似ランダムストリーム暗号がどのように機能するかを理解するために、RC4ストリーム暗号に焦点を当てます。RC4は、WEPおよびWAPワイヤレスアクセスポイントセキュリティプロトコルやTLSで使用されていた擬似ランダムストリーム暗号です。RC4には多くの証明された弱点があるため、不評になっています。実際、インターネットエンジニアリングタスクフォースは現在、TLSのすべてのインスタンスにおいてクライアントおよびサーバーアプリケーションによるRC4スイートの使用を禁止しています。それでも、プリミティブストリーム暗号がどのように機能するかを示す例としてはうまく機能します。

始めるために、まず、プレーンテキストメッセージ「SOUP」をベビーRC4暗号で暗号化する方法を示します。それでは、ベビーRC4暗号を使用した暗号化は、以下の四つのステップで進行します。

### ステップ1
まず、配列 **S** を $S[0] = 0$ から $S[7] = 7$ まで定義します。ここでの配列とは、インデックスによって整理された値の変更可能なコレクションを意味し、一部のプログラミング言語（例えば、Python）ではリストとも呼ばれます。この場合、インデックスは0から7まで実行され、値も0から7まで実行されます。したがって、**S** は以下の通りです：
- $S = [0, 1, 2, 3, 4, 5, 6, 7]$

ここでの値はASCII数字ではなく、1バイト文字の10進値表現です。したがって、値2は $0000 \ 0011$ と等しくなります。配列 **S** の長さは、したがって、8バイトです。

### ステップ 2

次に、1バイトから8バイトの間のキーを選択して、8バイト長のキーアレイ **K** を定義します（バイトの分数は許可されません）。各バイトが8ビットであるため、キーの各バイトについて0から255までの任意の数を選択できます。

キー **k** を $[14, 48, 9]$ と選択したとします。そうすると、その長さは3バイトになります。キーアレイの各インデックスは、その特定のキー要素の10進値に従って設定されます。キー全体を通過したら、キーアレイの8スロットを埋めるまで最初から再開します。したがって、私たちのキーアレイは以下の通りです：

- $K = [14, 48, 9, 14, 48, 9, 14, 48]$

### ステップ 3

第三に、**キースケジューリング**として知られるプロセスを使用して、キーアレイ **K** を使って配列 **S** を変換します。プロセスは以下の擬似コードで示されます：

- 変数 **j** と **i** を作成する
- 変数 $j = 0$ に設定する
- 0から7までの各 $i$ に対して：
    - $j = (j + S[i] + K[i]) \mod 8$ に設定する
    - $S[i]$ と $S[j]$ を交換する

配列 **S** の変換は *表1* によって示されます。

始めるにあたり、**S** の初期状態が $[0, 1, 2, 3, 4, 5, 6, 7]$ で、**j** の初期値が0であることがわかります。これはキーアレイ $[14, 48, 9, 14, 48, 9, 14, 48]$ を使用して変換されます。

forループは $i = 0$ で始まります。上記の擬似コードに従って、**j** の新しい値は6になります（$j = (j + S[0] + K[0]) \mod 8 = (0 + 0 + 14) \mod 8 = 6 \mod 8$）。$S[0]$ と $S[6]$ を交換すると、1ラウンド後の **S** の状態は $[6, 1, 2, 3, 4, 5, 0, 7]$ になります。
次の行では、$i = 1$です。forループを再び実行すると、**j**は7の値を取得します（$j = (j + S[1] + K[1]) \mod 8 = (6 + 1 + 48) \mod 8 = 55 \mod 8 = 7 \mod 8$）。現在の**S**の状態、$[6, 1, 2, 3, 4, 5, 0, 7]$から$S[1]$と$S[7]$を交換すると、2回目のラウンド後に$[6, 7, 2, 3, 4, 5, 0, 1]$が得られます。
このプロセスを続け、配列**S**の最終行、$[6, 4, 1, 0, 3, 7, 5, 2]$を生成します。

*表1: キー配列表*

| ラウンド | i   | j   |     | S[0] | S[1] | S[2] | S[3] | S[4] | S[5] | S[6] | S[7] |
| ------- | --- | --- | --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|         |     |     |     |      |      |      |      |      |      |      |      |
| 初期     |     | 0   |     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| 1       | 0   | 6   |     | 6    | 1    | 2    | 3    | 4    | 5    | 0    | 7    |
| 2       | 1   | 7   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 3       | 2   | 2   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 4       | 3   | 3   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 5       | 4   | 3   |     | 6    | 7    | 2    | 0    | 3    | 5    | 4    | 1    |
| 6       | 5   | 6   |     | 6    | 4    | 2    | 0    | 3    | 7    | 5    | 1    |
| 7       | 6   | 1   |     | 6    | 4    | 2    | 0    | 3    | 7    | 5    | 2    |
| 8       | 7   | 2   |     | 6    | 4    | 1    | 0    | 3    | 7    | 5    | 2    |

### ステップ4
第四ステップとして、**keystream（キーストリーム）**を生成します。これは、送信したいメッセージと同じ長さの擬似ランダム文字列です。これを使用して元のメッセージ「SOUP」を暗号化します。キーストリームはメッセージと同じ長さである必要があるため、4バイトのものが必要です。
キーストリームは、以下の擬似コードによって生成されます：

- 変数 **j**、**i**、および **t** を作成します。
- $j = 0$ と設定します。
- 平文の各 $i$ に対して、$i = 1$ から始めて $i = 4$ まで進むと、キーストリームの各バイトは以下のように生成されます：
    - $j = (j + S[i]) \mod 8$
    - $S[i]$ と $S[j]$ を交換します。
    - $t = (S[i] + S[j]) \mod 8$
    - キーストリームの $i^{th}$ バイト = $S[t]$

*表2*で計算を追うことができます。

**S**の初期状態は $S = [6, 4, 1, 0, 3, 7, 5, 2]$ です。$i = 1$ と設定すると、**j** の値は4になります（$j = (j + S[i]) \mod 8 = (0 + 4) \mod 8 = 4$）。次に、$S[1]$ と $S[4]$ を交換して、**S** の変換を2行目で生成します、$[6, 3, 1, 0, 4, 7, 5, 2]$。次に、**t** の値は7になります（$t = (S[i] + S[j]) \mod 8 = (3 + 4) \mod 8 = 7$）。最終的に、キーストリームのバイトは $S[7]$、つまり2です。

次に、他のバイトを生成し続け、次の4バイトを得ます：2、6、3、および7。これらの各バイトは、平文「SOUP」の各文字を暗号化するために使用できます。

始めるにあたり、ASCIIテーブルを使用して、「SOUP」が基礎となるバイト文字列の10進値で「83 79 85 80」とエンコードされていることがわかります。キーストリーム「2 6 3 7」との組み合わせは「85 85 88 87」となり、256でのモジュロ操作後も変わりません。ASCIIでは、暗号文「85 85 88 87」は「UUXW」と等しくなります。

暗号化する単語が配列 **S** よりも長かった場合はどうなるでしょうか？その場合、上記に示された方法で配列 **S** は平文の各バイト **i** に対してこのように変換し続け、平文の文字数と等しい数のバイトをキーストリームに持つまで続けます。

*表2: キーストリーム生成*

| i   | j   | t   | キーストリーム | S[0] | S[1] | S[2] | S[3] | S[4] | S[5] | S[6] | S[7] |
| --- | --- | --- | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
以下は、**RC4ストリーム暗号**の簡易版の例です。実際のRC4ストリーム暗号では、8バイトではなく256バイトの長さの**S**配列を持ち、キーは1から8バイトの間ではなく、1から256バイトの間で設定できます。キー配列とキーストリームは、**S**配列の256バイトの長さを考慮して生成されます。計算は非常に複雑になりますが、原理は同じです。標準的なRC4暗号で同じキー[14,48,9]を使用すると、平文メッセージ"SOUP"は16進数形式で67 02 ed dfとして暗号化されます。

平文メッセージや暗号文とは独立してキーストリームが更新されるストリーム暗号は、**同期ストリーム暗号**です。キーストリームはキーにのみ依存します。明らかに、RC4は同期ストリーム暗号の例であり、キーストリームは平文や暗号文とは関係ありません。前章で述べた私たちの原始的なストリーム暗号、シフト暗号、ヴィジュネル暗号、ワンタイムパッドも、同様に同期型です。

対照的に、**非同期ストリーム暗号**は、キーと暗号文の以前の要素の両方によってキーストリームが生成されます。このタイプの暗号は、**自己同期暗号**とも呼ばれます。

重要なことに、RC4で生成されたキーストリームはワンタイムパッドとして扱うべきであり、次回まったく同じ方法でキーストリームを生成することはできません。キーを毎回変更するのではなく、実用的な解決策はキーと**ナンス**を組み合わせてバイトストリームを生成することです。

## 128ビットキーを使用したAES
<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

前章で述べたように、国立標準技術研究所（NIST）は1997年から2000年にかけて、新しい対称暗号標準を決定するためのコンペティションを開催しました。**リジンダル暗号**が優勝作品となりました。この名前は、ベルギーの創作者であるVincent RijmenとJoan Daemenの名前をもじったものです。
Rijndael暗号は**ブロック暗号**であり、異なる鍵長とブロックサイズの仕様で使用できるコアアルゴリズムがあります。それから、異なる運用モードを用いて暗号化スキームを構築することができます。
NISTコンペティションの委員会は、128ビットのブロックサイズと128ビット、192ビット、または256ビットの鍵長を要求するRijndael暗号の制限バージョンを**Advanced Encryption Standard (AES)**の一部として採用しました。この制限バージョンのRijndael暗号も、複数の運用モードの下で使用することができます。標準の仕様は、**Advanced Encryption Standard (AES)**として知られています。

Rijndael暗号の動作方法を示すために、AESのコアである128ビット鍵での暗号化プロセスを説明します。鍵サイズは、各ブロックの暗号化に必要なラウンド数に影響を与えます。128ビット鍵の場合、10ラウンドが必要です。192ビットおよび256ビットでは、それぞれ12ラウンドと14ラウンドが必要になります。

さらに、AESが**ECBモード**で使用されると仮定します。これは説明を少し簡単にし、Rijndaelアルゴリズムには影響しません。確かに、ECBモードは実際には安全ではありません。なぜなら、決定論的な暗号化につながるからです。AESで最も一般的に使用される安全なモードは**CBC**（Cipher Block Chaining）です。

鍵を$K_0$と呼びましょう。上記のパラメータを用いた構成は、*図1*のようになります。ここで、$M_i$は128ビットの平文メッセージの一部を表し、$C_i$は128ビットの暗号文の一部を表します。平文がブロックサイズで均等に分割できない場合、最後のブロックにはパディングが追加されます。

*図1: 128ビット鍵を使用したAES-ECB*

![図1: 128ビット鍵を使用したAES-ECB](assets/Figure5-1.webp "図1: 128ビット鍵を使用したAES-ECB")

各128ビットブロックのテキストは、Rijndael暗号化スキームで10ラウンドを経ます。これには、各ラウンドごとに別のラウンド鍵（$K_1$から$K_{10}$まで）が必要です。これらは、**鍵拡張アルゴリズム**を使用して、元の128ビット鍵$K_0$から各ラウンドごとに生成されます。したがって、暗号化される各ブロックのテキストには、元の鍵$K_0$と10個の別々のラウンド鍵を使用します。これら同じ11の鍵は、暗号化が必要な各128ビットブロックの平文に対して使用されます。

鍵拡張アルゴリズムは長く複雑です。それを詳しく説明することはあまり教育的な利益がありません。もしご希望であれば、鍵拡張アルゴリズムを自分で調べることができます。ラウンド鍵が生成されると、Rijndael暗号は平文の最初の128ビットブロック$M_1$を、*図2*に示されるように操作します。これらのステップをこれから説明します。

*図2: Rijndael暗号による$M_1$の操作:*

**ラウンド0:**
- $M_1$と$K_0$をXORして$S_0$を生成

---

**ラウンドn（n = {1,...,9}）:**
- $S_{n-1}$と$K_n$をXOR
- バイト置換
- 行のシフト
- 列の混合
- $S$と$K_n$をXORして$S_n$を生成

---

**ラウンド10:**
- XOR $S_9$ と $K_{10}$ - バイト置換
- 行のシフト
- XOR $S$ と $K_{10}$ を行い、$S_{10}$ を生成
- $S_{10}$ = $C_1$

### ラウンド 0

ラインダール暗号のラウンド0は直接的です。128ビットの平文と秘密鍵の間でXOR演算を行い、配列 $S_0$ が生成されます。つまり、

- $S_0 = M_1 \oplus K_0$

### ラウンド 1

ラウンド1では、まず配列 $S_0$ とラウンドキー $K_1$ をXOR演算で組み合わせます。これにより新しい状態の $S$ が生成されます。

次に、現在の $S$ の状態に対して**バイト置換**操作が実行されます。これは、16バイトの $S$ 配列の各バイトを取り、**ラインダールのSボックス**と呼ばれる配列からバイトを置換することによって機能します。各バイトはユニークな変換を持ち、その結果として新しい状態の $S$ が生成されます。ラインダールのSボックスは*図3*に表示されています。

*図3: ラインダールのSボックス*

|     | 00  | 01  | 02  | 03  | 04  | 05  | 06  | 07  | 08  | 09  | 0A  | 0B  | 0C  | 0D  | 0E  | 0F  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 00  | 63  | 7C  | 77  | 7B  | F2  | 6B  | 6F  | C5  | 30  | 01  | 67  | 2B  | FE  | D7  | AB  | 76  |
| 10  | CA  | 82  | C9  | 7D  | FA  | 59  | 47  | F0  | AD  | D4  | A2  | AF  | 9C  | A4  | 72  | C0  |
| 20  | B7  | FD  | 93  | 26  | 36  | 3F  | F7  | CC  | 34  | A5  | E5  | F1  | 71  | D8  | 31  | 15  |
| 30  | 04  | C7  | 23  | C3  | 18  | 96  | 05  | 9A  | 07  | 12  | 80  | E2  | EB  | 27  | B2  | 75  |
| 40  | 09  | 83  | 2C  | 1A  | 1B  | 6E  | 5A  | A0  | 52  | 3B  | D6  | B3  | 29  | E3  | 2F  | 84  |
このテキストは、おそらく暗号化やコンピューターセキュリティに関連するヘキサデシマル（16進数）のデータ列を示しています。各行は、特定のバイト列を表しており、これらはコンピュータプログラム、データ暗号化、またはその他の技術的なプロセスで使用される可能性があります。このようなデータは、特定のコンテキストや目的なしには、その意味を解釈することが難しいです。翻訳の文脈では、このデータ自体を翻訳することは不要であり、そのまま保持するのが適切です。
| F0  | 8C  | A1  | 89  | 0D  | BF  | E6  | 42  | 68  | 41  | 99  | 2D  | 0F  | B0  | 54  | BB  | 16  |

このS-Boxは、Rijndael暗号で抽象代数が登場する場所の一つであり、特に**ガロア体**が関係しています。

まず、可能なバイト要素00からFFを8ビットベクトルとして定義します。このような各ベクトルは、剰余演算のための既約多項式が$x^8 + x^4 + x^3 + x + 1$である**ガロア体GF(2^8)**の要素です。これらの仕様を持つガロア体は、**Rijndaelの有限体**とも呼ばれます。

次に、フィールド内の可能な各要素に対して、**Nyberg S-Box**と呼ばれるものを作成します。このボックスでは、各バイトがその**乗法逆数**（つまり、その積が1になるように）にマッピングされます。次に、これらの値をNyberg S-boxからRijndaelのS-Boxへ**アフィン変換**を使用してマッピングします。

**S**配列に対する3番目の操作は、**行のシフト**操作です。これは**S**の状態を取り、16バイトすべてを行列にリストします。行列の充填は左上から始まり、上から下へと進み、そして列が埋まるたびに、右へ一列シフトして上に戻ります。

**S**の行列が構築されると、4つの行がシフトされます。最初の行はそのままです。2行目は左に1つ移動します。3行目は左に2つ移動します。4行目は左に3つ移動します。プロセスの例は*図4*に示されています。**S**の元の状態が上に、行のシフト操作後の結果の状態が下に示されています。

*図4: 行のシフト操作*

| F1   | A0   | B1   | 23   |
|------|------|------|------|
| 59   | EF   | 09   | 82   |
| 97   | 01   | B0   | CC   |
| D4   | 72   | 04   | 21   |

| F1   | A0   | B1   | 23   |
|------|------|------|------|
| EF   | 09   | 82   | 59   |
| B0   | CC   | 97   | 01   |
| 21   | D4   | 72   | 04   |


4番目のステップでは、再び**ガロア体**が登場します。まず、**S**行列の各列が*図5*に示される4 x 4行列の列と乗算されます。しかし、通常の行列乗算ではなく、既約多項式$x^8 + x^4 + x^3 + x + 1$によるベクトル乗算です。結果として得られるベクトルの係数は、バイトの個々のビットを表します。

*図5: 列の混合行列*

| 02   | 03   | 01   | 01   |
|------|------|------|------|
| 01   | 02   | 03   | 01   |
| 01   | 01   | 02   | 03   || 03   | 01   | 01   | 02   |

**S**行列の最初の列と上記の4 x 4行列の乗算は、*図6*の結果をもたらします。

*図6: 最初の列の乗算:*

$$
\begin{matrix}
02 \cdot F1 + 03 \cdot EF + 01 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 02 \cdot EF + 03 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 01 \cdot EF + 02 \cdot B0 + 03 \cdot 21 \\
03 \cdot F1 + 01 \cdot EF + 01 \cdot B0 + 02 \cdot 21
\end{matrix}
$$

次のステップとして、行列内の全ての項を多項式に変換する必要があります。例えば、F1は1バイトを表し、$x^7 + x^6 + x^5 + x^4 + 1$になり、03は1バイトを表し、$x + 1$になります。

その後、全ての乗算は**モジュロ** $x^8 + x^4 + x^3 + x + 1$で実行されます。これにより、列の4つのセルのそれぞれに4つの多項式が加算されます。これらの加算を**モジュロ2**で実行した後、4つの多項式が得られます。これらの多項式のそれぞれは、**S**の8ビット文字列、つまり1バイトを表します。ここでは、*図6*の行列上でこれらの計算を全て実行しませんが、それは広範囲にわたるためです。

最初の列が処理された後、**S**行列の他の3列も同様の方法で処理されます。最終的に、これにより16バイトの行列が得られ、配列に変換することができます。

最終ステップとして、配列**S**は再びラウンドキーと**XOR**演算で組み合わされます。これにより状態$S_1$が生成されます。つまり、

- $S_1 = S \oplus K_0$

### 第2ラウンドから第10ラウンド

第2ラウンドから第9ラウンドは、第1ラウンドの繰り返しであり、*mutatis mutandis*です。最終ラウンドは前のラウンドと非常に似ていますが、**列の混合**ステップが省略されます。つまり、第10ラウンドは以下のように実行されます：

- $S_9 \oplus K_{10}$
- バイト置換
- 行のシフト
- $S_{10} = S \oplus K_{10}$

状態$S_{10}$は、暗号文の最初の128ビットである$C_1$に設定されます。残りの128ビットの平文ブロックを処理することで、完全な暗号文**C**が得られます。

### Rijndael暗号の操作

Rijndael暗号で見られる異なる操作の背後にある理論は何ですか？

詳細に入ることなく、暗号化スキームは、混乱と拡散の程度に基づいて評価されます。暗号化スキームが高い程度の**混乱**を持っている場合、それは暗号文が平文と大きく異なることを意味します。暗号化スキームが高い程度の**拡散**を持っている場合、それは平文の小さな変更が大きく異なる暗号文を生じさせることを意味します。
Rijndael暗号の操作の背後にある理論は、高度な混乱と拡散の両方を生み出すことです。混乱はバイト置換操作によって生み出され、拡散は行のシフトと列の混合操作によって生み出されます。
# 非対称暗号
<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

## 鍵の配布と管理の問題
<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

対称暗号と同様に、非対称方式は秘密保持と認証の両方を保証するために使用できます。しかし、これらの方式は一つではなく二つの鍵、つまり秘密鍵と公開鍵を使用します。

非対称暗号の発見についての調査を始めるにあたり、特にそれを促した問題について議論します。次に、暗号化と認証における非対称方式がどのように高レベルで機能するかについて議論します。その後、非対称認証方式を理解する上で鍵となるハッシュ関数について紹介し、第4章で議論したハッシュベースのメッセージ認証コードなど、他の暗号文脈でも関連性があることを説明します。

___

例えば、ボブが北米に数百万の顧客を持つオンラインスポーツ用品小売業者であるジムのスポーツ用品店から新しいレインコートを購入したいとします。これが彼の初めての購入であり、クレジットカードを使用したいと考えています。そこで、ボブはまず、住所やクレジットカード情報などの個人情報を送信することで、ジムのスポーツ用品店とのアカウントを作成する必要があります。その後、レインコートを購入するために必要な手順を踏むことができます。

インターネットがオープンな通信システムであることを考えると、このプロセス全体を通じて、ボブとジムのスポーツ用品店は、彼らの通信が安全であることを確認したいと思うでしょう。例えば、潜在的な攻撃者がボブのクレジットカードや住所の詳細を知ることができないようにし、潜在的な攻撃者が彼の購入を繰り返したり、彼の代わりに偽の購入を作成することができないようにしたいと思うでしょう。

前章で議論された高度な認証暗号化スキームは、確かにボブとジムのスポーツ用品店間の通信を安全にすることができます。しかし、そのようなスキームを実装するには明らかに実際的な障害があります。

これらの実際的な障害を例示するために、対称暗号のツールのみが存在する世界に住んでいたと仮定します。その場合、ジムのスポーツ用品店とボブは、安全な通信を保証するために何をすることができるでしょうか？

そのような状況下では、彼らは安全に通信するためのかなりのコストに直面するでしょう。インターネットがオープンな通信システムであるため、彼らはそれを介して鍵のセットを交換することはできません。したがって、ボブとジムのスポーツ用品店の代表者は、対面で鍵の交換を行う必要があります。

一つの可能性は、ジムのスポーツ用品店が特別な鍵交換場所を作成し、ボブや他の新規顧客が安全な通信のための鍵のセットを受け取ることができるようにすることです。これは明らかにかなりの組織的コストがかかり、新規顧客が購入を行う効率を大幅に低下させるでしょう。

または、ジムのスポーツ用品店は、非常に信頼できる宅配業者を使ってボブに一組の鍵を送ることができます。これは鍵交換場所を組織するよりも効率的かもしれません。しかし、これでも特に多くの顧客が一度や数回の購入しかしない場合、かなりのコストがかかるでしょう。

次に、認証された暗号化のための対称スキームも、ジムのスポーツ用品店がすべての顧客のために別々の鍵のセットを保管することを強制します。これは数千の顧客にとっては重大な実際的な課題であり、ましてや数百万にとってはなおさらです。
この後者の点を理解するために、例えばJim’s Sporting Goodsが各顧客に同じペアの鍵を提供していると仮定しましょう。これにより、各顧客やそのペアの鍵を入手できる他の誰もが、Jim’s Sporting Goodsとその顧客間の全ての通信を読んだり、さらには操作したりすることができます。その場合、通信に暗号化を全く使用しない方がましだと言えるでしょう。
たとえ一部の顧客に対して鍵のセットを繰り返し使用することは、非常に悪いセキュリティ慣行です。潜在的な攻撃者はその特徴を利用しようと試みるかもしれません（攻撃者は鍵を除くスキームについて全てを知っていると仮定されます。これはKerckhoffsの原則に従っています）。

したがって、Jim’s Sporting Goodsは、鍵のペアがどのように配布されるかに関わらず、各顧客ごとに鍵のペアを保管する必要があります。これは明らかにいくつかの実用的な問題を提示します。

- Jim’s Sporting Goodsは、各顧客ごとに数百万組の鍵を保管する必要があります。
- これらの鍵は適切に保護される必要があります。なぜなら、それらはハッカーにとって確実な標的になるからです。セキュリティの侵害は、特別な鍵交換場所や宅配便による、費用のかかる鍵交換の繰り返しを必要とします。
- Jim’s Sporting Goodsの任意の顧客は、自宅で鍵のペアを安全に保管する必要があります。損失や盗難が発生し、鍵交換の繰り返しが必要になります。顧客は、インターネット上で通信や取引を行いたい他のオンラインストアや他のタイプのエンティティについても、このプロセスを経る必要があります。

ここで述べた2つの主な課題は、1970年代まで非常に基本的な懸念事項でした。それらは**鍵配布問題**と**鍵管理問題**として知られていました。

もちろん、これらの問題は常に存在しており、過去にはしばしば頭痛の種となっていました。例えば、軍隊は、大きなリスクとコストを伴って、現場の人員に安全な通信のための鍵が記載された本を常に配布しなければなりませんでした。しかし、世界が長距離のデジタル通信、特に非政府組織にとってのものへと移行していくにつれて、これらの問題は悪化していました。

これらの問題が1970年代に解決されなければ、Jim’s Sporting Goodsでの効率的で安全なショッピングはおそらく存在しなかったでしょう。実際、実用的で安全な電子メール、オンラインバンキング、ショッピングのほとんどは、遠い夢でしかなかったかもしれません。Bitcoinのようなものさえ全く存在しなかったでしょう。

では、1970年代に何が起こったのでしょうか？オンラインで瞬時に購入を行い、World Wide Webを安全に閲覧することがどのように可能になったのでしょうか？スマートフォンから世界中に瞬時にBitcoinを送ることがどのように可能になったのでしょうか？

## 新しい暗号学の方向性
<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

1970年代になると、鍵配布問題と鍵管理問題は、アメリカの学術的な暗号学者のグループ、Whitfield Diffie、Martin Hellman、Ralph Merkleの注目を集めました。彼らの多くの同僚からの厳しい懐疑論に直面しながら、彼らはそれに対する解決策を考案することに挑戦しました。

彼らの冒険の少なくとも一つの主な動機は、オープンなコンピュータ通信が私たちの世界に深い影響を与えるだろうという先見の明でした。DiffieとHelmannは1976年に述べています。
コンピュータ制御の通信ネットワークの発展は、世界の反対側にいる人々やコンピュータ間の労力を要しない、低コストの接触を約束しています。これにより、多くの郵便や多くの外出がテレコミュニケーションに置き換えられます。多くのアプリケーションでは、これらの接触を盗聴や不正なメッセージの注入から保護する必要があります。しかし現在、セキュリティ問題の解決は通信技術の他の分野よりも大きく遅れています。*現代の暗号技術は要求を満たすことができず、その使用はシステムユーザーにとって非常に重大な不便を課すため、テレプロセッシングの多くの利点を無効にしてしまいます。*[1]

ディフィー、ヘルマン、メルクルの粘り強さが報われました。彼らの結果の最初の公開は、1976年にディフィーとヘルマンによって発表された「暗号学における新しい方向性」という論文でした。この中で、彼らは鍵配布と鍵管理の問題を解決するための2つの独創的な方法を提示しました。

彼らが提供した最初の解決策は、リモート*鍵交換プロトコル*でした。つまり、安全でない通信チャネル上で1つ以上の対称鍵を交換するための一連のルールです。このプロトコルは現在、*ディフィー・ヘルマン鍵交換*または*ディフィー・ヘルマン・メルクル鍵交換*として知られています。[2]

ディフィー・ヘルマン鍵交換では、2つの当事者が最初にインターネットのような安全でないチャネル上で公に情報を交換します。その情報に基づいて、彼らはそれから、安全な通信のための対称鍵（または対称鍵のペア）を独立して作成します。両方の当事者が独立して鍵を作成する一方で、公に共有した情報がこの鍵作成プロセスが両方の当事者にとって同じ結果をもたらすことを保証します。

重要なことに、安全でないチャネル上で当事者によって公に交換される情報を誰もが観察できる一方で、情報交換に参加している2つの当事者だけがそれから対称鍵を作成することができます。

もちろん、これは完全に直感に反するように聞こえます。どうして2つの当事者が公に情報を交換し、それによって彼らだけが対称鍵を作成できるのでしょうか？情報交換を観察する他の誰かが同じ鍵を作成できない理由は何でしょうか？

もちろん、これはいくつかの美しい数学に依存しています。ディフィー・ヘルマン鍵交換は、トラップドアを持つ一方向関数を介して機能します。これら2つの用語の意味について順番に議論しましょう。

ある関数$f(x)$と結果$f(a) = y$が与えられたとします。ここで、$a$は$x$の特定の値です。$f(x)$が**一方向関数**であるとは、$a$と$f(x)$が与えられたときに$y$の値を計算することは容易ですが、$y$と$f(x)$が与えられたときに$a$の値を計算することが計算上実行不可能である場合を指します。もちろん、**一方向関数**という名前は、そのような関数が一方向でのみ計算するのが実用的であるという事実に由来します。

一部の一方向関数には、**トラップドア**として知られる特定の情報$Z$があります。$y$と$f(x)$のみが与えられた状態で$a$を計算することは実際には不可能ですが、$y$から$a$を計算上実行可能にする特定の情報$Z$があります。この情報$Z$は**トラップドア**として知られています。トラップドアを持つ一方向関数は、**トラップドア関数**として知られています。
ここでは、Diffie-Helmann鍵交換の詳細には踏み込みません。しかし、基本的には各参加者が情報を生成し、その一部を公開し、一部を秘密に保ちます。その後、各当事者は、自分の秘密の情報と他方の当事者が共有した公開情報を使用して、プライベートキーを作成します。そして、何とかして、両方の当事者が同じプライベートキーを得ることになります。
Diffie Helmann鍵交換において、2つの当事者間で公開された情報のみを観察する当事者は、これらの計算を再現することができません。そうするためには、2つの当事者のうちの1つから秘密の情報が必要になります。

1976年の論文で紹介されたDiffie-Helmann鍵交換の基本バージョンは非常に安全とは言えませんが、基本プロトコルの洗練されたバージョンは今日でも確かに使用されています。最も重要なことは、トランスポート層セキュリティプロトコル（バージョン1.3）の最新バージョンのすべての鍵交換プロトコルが、本質的には1976年にDiffieとHellmanによって提示されたプロトコルの豊かなバージョンであることです。トランスポート層セキュリティプロトコルは、Webコンテンツを交換するための標準であるハイパーテキスト転送プロトコル（http）に従ってフォーマットされた情報を安全に交換するための主要なプロトコルです。

重要なことに、Diffie-Helmann鍵交換は非対称スキームではありません。厳密に言えば、それは対称鍵暗号の領域に属していると言えるでしょう。しかし、Diffie-Helmann鍵交換と非対称暗号化の両方が、トラップドアを持つ一方向数論関数に依存しているため、通常は一緒に議論されます。

DiffieとHelmannが1976年の論文で鍵の配布と管理の問題に対処するために提供した2番目の方法は、もちろん、非対称暗号化を介してでした。

Diffie-Hellman鍵交換の提示とは対照的に、彼らは非対称暗号化スキームがどのように構築される可能性があるかの一般的な輪郭のみを提供しました。彼らは、そのようなスキームで合理的なセキュリティに必要な条件を特に満たすことができる一方向関数を提供しませんでした。

しかし、非対称スキームの実用的な実装は、1年後に異なる3人の学術暗号学者と数学者によって見つかりました：Ronald Rivest、Adi Shamir、およびLeonard Adleman。彼らが導入した暗号システムは、**RSA暗号システム**（彼らの姓から）として知られるようになりました。

非対称暗号化（およびDiffie Helmann鍵交換）で使用されるトラップドア関数は、主に2つの**計算上の困難な問題**に関連しています：素因数分解と離散対数の計算。

**素因数分解**は、その名が示すように、整数をその素因数に分解することを要求します。RSA問題は、素因数分解に関連する暗号システムの中で最もよく知られた例です。

**離散対数問題**は、巡回群で発生する問題です。特定の巡回群の生成元が与えられた場合、その生成元から群内の別の要素を生成するために必要なユニークな指数を計算することを要求します。

離散対数ベースのスキームは、整数の乗法群と楕円曲線上の点を含む群という、2つの主要な種類の巡回群に依存しています。『新しい暗号学の方向性』で提示された元のDiffie Helmann鍵交換は、整数の巡回乗法群で動作します。ビットコインのデジタル署名アルゴリズムおよび最近導入されたSchnorr署名スキーム（2021）は、特定の楕円曲線巡回群の離散対数問題に基づいています。

次に、非対称設定における秘密保持と認証の概要に移ります。しかし、そうする前に、簡単な歴史的なメモをする必要があります。
イギリスの暗号学者と数学者のグループが、政府通信本部（GCHQ）のために働いていた数年前に、上記の発見を独立して行っていたと考えられるようになりました。このグループには、ジェームズ・エリス、クリフォード・コックス、マルコム・ウィリアムソンが含まれていました。
彼ら自身の証言とGCHQのそれによると、1969年に公開鍵暗号の概念を最初に考案したのはジェームズ・エリスでした。その後、クリフォード・コックスが1973年にRSA暗号システムを、マルコム・ウィリアムソンが1974年にディフィー・ヘルマン鍵交換の概念を発見したとされています。[4] しかし、これらの発見はGCHQで行われた作業の秘密性を考慮して、1997年まで公表されなかったとされています。

**注釈:**

[1] Whitfield DiffieとMartin Hellman, “New directions in cryptography,” _IEEE Transactions on Information Theory_ IT-22 (1976), pp. 644–654, p. 644にて。

[2] Ralph Merkleも、“Secure communications over insecure channels”, _Communications of the Association for Computing Machinery_, 21 (1978), 294–99にて鍵交換プロトコルについて議論しています。MerkleはDiffieとHellmanの論文よりも前にこの論文を提出しましたが、後に公開されました。Merkleの解決策はDiffie-Hellmanのものとは異なり、指数関数的に安全ではありません。

[3] Ron Rivest, Adi Shamir, Leonard Adleman, “A method for obtaining digital signatures and public-key cryptosystems”, _Communications of the Association for Computing Machinery_, 21 (1978), pp. 120–26。

[4] これらの発見の良い歴史は、Simon Singh, _The Code Book_, Fourth Estate (London, 1999), 第6章によって提供されています。

## 非対称暗号化と認証
<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

**非対称暗号化**についての概要が、ボブとアリスを用いて*図1*で提供されています。

アリスは最初に、公開鍵($K_P$)と秘密鍵($K_S$)からなる鍵のペアを作成します。ここで、$K_P$の「P」は「public（公開）」を、「K_S$の「S」は「secret（秘密）」を意味します。彼女はこの公開鍵を自由に他者に配布します。この配布プロセスの詳細については、もう少し後で戻ります。しかし今のところ、ボブを含む誰でも、アリスの公開鍵$K_P$を安全に入手できると仮定します。

後の時点で、ボブはアリスにメッセージ$M$を書きたいと思います。これには機密情報が含まれているため、アリス以外の誰にも内容が秘密にされることを望みます。そこで、ボブは最初に$K_P$を使用してメッセージ$M$を暗号化します。次に、結果として得られた暗号文$C$をアリスに送信します。アリスは$K_S$で$C$を復号して、元のメッセージ$M$を生成します。

*図1: 非対称暗号化*

![図1: 非対称暗号化](assets/Figure6-1.webp "図1: 非対称暗号化")

ボブとアリスの通信を盗聴する任意の敵は、$C$を観察することができます。彼女はまた、$K_P$と暗号化アルゴリズム$E(\cdot)$を知っています。しかし、重要なことに、この情報では暗号文$C$を実行可能に復号することはできません。復号には具体的に$K_S$が必要であり、攻撃者はこれを持っていません。
対称暗号化スキームは、一般的に、平文メッセージを有効に暗号化できる攻撃者に対して安全である必要があります（これを選択暗号文攻撃の安全性と呼びます）。しかし、攻撃者や他の誰かがそのような有効な暗号文を作成することを明示的な目的として設計されているわけではありません。
これは、非対称暗号化スキームとは対照的で、その全目的は攻撃者を含む誰でも有効な暗号文を生成できるようにすることです。したがって、非対称暗号化スキームは**複数アクセス暗号**としてラベル付けすることができます。

何が起こっているのかをよりよく理解するために、電子的にメッセージを送信する代わりに、ボブが秘密裏に物理的な手紙を送りたいと想像してみてください。秘密を保つ一つの方法は、アリスが安全な南京錠をボブに送るが、それを解錠する鍵は彼女が保持することです。手紙を書いた後、ボブはその手紙を箱に入れ、アリスの南京錠でそれを閉じることができます。その後、鍵を持つアリスに鍵のかかった箱を送ることができます。

ボブは南京錠をかけることができますが、それが本当に安全である場合、彼や箱を傍受する他の人は南京錠を解除することができません。アリスだけがそれを解除してボブの手紙の内容を見ることができます。なぜなら彼女が鍵を持っているからです。

大まかに言えば、非対称暗号化スキームはこのプロセスのデジタルバージョンです。南京錠は公開鍵に似ており、南京錠の鍵は秘密鍵に似ています。しかし、南京錠がデジタルであるため、アリスが秘密のメッセージを彼女に送りたいと思うかもしれない誰にでもそれを配布することははるかに簡単で、コストもかかりません。

非対称設定での認証には、**デジタル署名**を使用します。したがって、これらは対称設定のメッセージ認証コードと同じ機能を持っています。デジタル署名の概要は*図2*で提供されています。

ボブは最初に公開鍵($K_P$)と秘密鍵($K_S$)の鍵のペアを作成し、彼の公開鍵を配布します。アリスに認証されたメッセージを送信したいとき、彼は最初に彼のメッセージ$M$と彼の秘密鍵を取って**デジタル署名**$D$を作成します。その後、ボブは彼のメッセージとデジタル署名をアリスに送ります。

アリスはメッセージ、公開鍵、およびデジタル署名を**検証アルゴリズム**に挿入します。このアルゴリズムは、有効な署名に対しては**true**を、無効な署名に対しては**false**を生成します。

デジタル署名は、その名前が明確に示すように、手紙、契約などにおける書面による署名のデジタル版です。実際、デジタル署名は通常、はるかに安全です。ある程度の努力をすれば、書面による署名を偽造することができます。このプロセスは、書面による署名が頻繁に厳密に検証されないという事実によって容易になります。しかし、安全なデジタル署名は、安全なメッセージ認証コードと同様に、**実存的に偽造不可能**です。つまり、安全なデジタル署名スキームを使用すると、秘密鍵を持っていない限り、誰も検証手順を通過するメッセージの署名を実現可能に作成することはできません。

*図2: 非対称認証*

![図2: 非対称認証](assets/Figure6-2.webp "図2: 非対称認証")


非対称暗号化と同様に、デジタル署名とメッセージ認証コードの間には興味深い対照が見られます。後者の場合、検証アルゴリズムは安全な通信に関与する当事者の一方によってのみ使用されます。これは、秘密鍵が必要だからです。しかし、非対称設定では、誰でもボブによって作成されたデジタル署名$S$を検証できます。
これらすべてが、デジタル署名を非常に強力なツールにしています。例えば、法的な目的で検証可能な契約書上の署名を作成する基盤となります。もしボブが上記の交換で契約書に署名を行っていた場合、アリスはメッセージ$M$、契約書、そして署名$S$を法廷に提示することができます。その後、法廷はボブの公開鍵を使用して署名を検証することができます。[5]

別の例として、デジタル署名は安全なソフトウェアおよびソフトウェア更新の配布の重要な側面です。このタイプの公開検証は、メッセージ認証コードだけを使用しては決して作成できません。

デジタル署名の力の最後の例として、ビットコインを考えてみましょう。ビットコインについて、特にメディアでよくある誤解の一つは、トランザクションが暗号化されているということですが、それは違います。代わりに、ビットコインのトランザクションはセキュリティを確保するためにデジタル署名を使用しています。

ビットコインは、未使用トランザクション出力（または**UTXO**）と呼ばれるバッチで存在します。特定のビットコインアドレスで2ビットコインずつ3回の支払いを受け取ったとします。技術的には、そのアドレスに6ビットコインがあるわけではありません。代わりに、そのアドレスに関連付けられた暗号問題によってロックされた2ビットコインの3つのバッチを持っています。支払いを行う際には、トランザクションに必要な金額に応じて、これらのバッチを1つ、2つ、または全部使用できます。

未使用トランザクション出力に対する所有権の証明は、通常、一つまたは複数のデジタル署名を通じて示されます。ビットコインは、未使用トランザクション出力に対する有効なデジタル署名を、それを作成するために必要な秘密情報を持っていない限り、計算上不可能であるために正確に機能します。

現在、ビットコインのトランザクションは、トランザクションで使用される未使用トランザクション出力の起源など、ネットワークの参加者によって検証される必要があるすべての情報を透明に含んでいます。一部の情報を隠しても検証を可能にすることは可能です（例えば、モネロなどの代替暗号通貨が行っているように）、しかし、これは特定のセキュリティリスクも生み出します。

デジタル署名とデジタルで捕捉された書面の署名について混乱が生じることがあります。後者の場合、書面の署名の画像をキャプチャして、雇用契約などの電子文書に貼り付けます。しかし、これは暗号学的な意味でのデジタル署名ではありません。後者は、秘密鍵を所持していることによってのみ生成できる長い数字です。

対称鍵設定と同様に、非対称暗号化と認証スキームも一緒に使用することができます。同様の原則が適用されます。まず、暗号化とデジタル署名の作成には異なる秘密鍵・公開鍵ペアを使用するべきです。さらに、メッセージを最初に暗号化してから認証するべきです。

重要なことは、多くのアプリケーションでは、非対称暗号化が通信プロセス全体を通じて使用されるわけではないということです。代わりに、実際に通信するために当事者間で*対称鍵を交換する*ためにのみ使用されることが一般的です。

例えば、オンラインで商品を購入する場合がこれに該当します。販売者の公開鍵を知っている場合、彼女はあなたにデジタル署名されたメッセージを送信することができ、あなたはその真正性を検証することができます。この基盤の上で、安全に通信するために対称鍵を交換するための複数のプロトコルのいずれかに従うことができます。

前述のアプローチの頻度の主な理由は、非対称暗号化が特定のレベルのセキュリティを生成するには対称暗号化よりもはるかに効率が悪いということです。これは、公開鍵暗号化の隣に対称鍵暗号化がまだ必要である理由の一つです。さらに、特定のアプリケーション、例えばコンピュータユーザーが自分のデータを暗号化する場合などでは、対称鍵暗号化がはるかに自然です。

では、デジタル署名と公開鍵暗号化は、鍵配布と鍵管理の問題をどのように解決するのでしょうか？
ここに一つの答えはありません。非対称暗号化は一つのツールであり、そのツールを利用する方法は一つではありません。しかし、Jim’s Sporting Goodsの以前の例を取り上げて、この例で問題が通常どのように対処されるかを示しましょう。

まず、Jim’s Sporting Goodsはおそらく**証明書局**（certificate authority）、公開鍵配布をサポートする組織にアプローチするでしょう。証明書局はJim’s Sporting Goodsに関するいくつかの詳細を登録し、公開鍵を付与します。その後、Jim’s Sporting Goodsに**TLS/SSL証明書**として知られる証明書を送ります。この証明書には、証明書局自身の公開鍵を使用してデジタル署名されたJim’s Sporting Goodsの公開鍵が含まれています。この方法で、証明書局は特定の公開鍵が実際にJim’s Sporting Goodsに属していることを証明します。

TLS/SSL証明書のこのプロセスを理解する鍵は、一般的にあなたのコンピュータにJim’s Sporting Goodsの公開鍵が保存されていない一方で、認識された証明書局の公開鍵は実際にあなたのブラウザやオペレーティングシステムに保存されているということです。これらは**ルート証明書**と呼ばれるものに保存されています。

したがって、Jim’s Sporting GoodsがそのTLS/SSL証明書を提供すると、ブラウザやオペレーティングシステムのルート証明書を介して証明書局のデジタル署名を検証できます。署名が有効であれば、証明書の公開鍵が実際にJim’s Sporting Goodsに属していると比較的確信できます。この基礎に基づき、Jim’s Sporting Goodsとの安全な通信プロトコルを簡単に設定できます。

Jim’s Sporting Goodsにとって、鍵配布は現在非常に単純になりました。鍵管理も大幅に簡素化されたことが容易にわかります。何千もの鍵を保存する代わりに、Jim’s Sporting Goodsは、そのSSL証明書の公開鍵に対する署名を行うことができる秘密鍵を保存するだけで済みます。顧客がJim’s Sporting Goodsのサイトに来るたびに、この公開鍵から安全な通信セッションを確立できます。顧客も、オペレーティングシステムとブラウザに認識された証明書局の公開鍵以外の情報を保存する必要はありません。

**メモ:**

[5] 第1章で議論したもう一つのテーマである否認防止を達成しようとするあらゆる計画は、基本的にデジタル署名を含む必要があります。

## ハッシュ関数
<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

ハッシュ関数は暗号学において至る所に存在します。それらは対称も非対称も暗号スキームではありませんが、独自の暗号学的カテゴリに分類されます。

第4章でハッシュベースの認証メッセージの作成によってハッシュ関数に遭遇しました。デジタル署名の文脈でも重要ですが、少し異なる理由で：デジタル署名は通常、実際の（暗号化された）メッセージではなく、ある（暗号化された）メッセージのハッシュ値に対して行われます。このセクションでは、ハッシュ関数についてより詳細な紹介を行います。

ハッシュ関数を定義しましょう。**ハッシュ関数**は任意のサイズの入力を取り、固定長の出力を生成する効率的に計算可能な関数です。

**暗号学的ハッシュ関数**は単に暗号学のアプリケーションに有用なハッシュ関数です。暗号学的ハッシュ関数の出力は通常、**ハッシュ**、**ハッシュ値**、または**メッセージダイジェスト**と呼ばれます。

暗号学の文脈では、「ハッシュ関数」は通常、暗号学的ハッシュ関数を指します。ここからはその慣習を採用します。
人気のあるハッシュ関数の例として、**SHA-256**（セキュアハッシュアルゴリズム256）があります。入力のサイズ（例えば、15ビット、100ビット、または10,000ビット）に関わらず、この関数は256ビットのハッシュ値を生成します。以下に、SHA-256関数のいくつかの出力例を示します。
“Hello”: `185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969`

“52398”: `a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90`

“Cryptography is fun”: `3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c`

すべての出力は、16進数形式で正確に256ビットで書かれています（各16進数は4ビットの2進数で表現できます）。したがって、たとえトールキンの*指輪物語*をSHA-256関数に入力しても、出力は依然として256ビットになります。

SHA-256のようなハッシュ関数は、暗号学のさまざまな目的で使用されます。ハッシュ関数に求められる特性は、特定のアプリケーションの文脈によって本当に異なります。暗号学においてハッシュ関数から一般的に求められる2つの主要な特性は以下の通りです：[6]

1. 衝突耐性
2. 隠蔽性

ハッシュ関数$H$が**衝突耐性**であるとは、$x \neq y$であるにもかかわらず、$H(x) = H(y)$となるような2つの値$x$と$y$を見つけることが非現実的である場合を指します。

例えば、ソフトウェアの検証において、衝突耐性ハッシュ関数は重要です。Bitcoin Core 0.21.0のWindowsリリース（Bitcoinネットワークトラフィックを処理するサーバーアプリケーション）をダウンロードしたいと考えた場合、ソフトウェアの正当性を検証するために以下の手順を踏む必要があります：

1. まず、Bitcoin Coreの一人以上の貢献者の公開鍵をダウンロードして、デジタル署名を検証できるソフトウェア（例：Kleopetra）にインポートする必要があります。これらの公開鍵は[こちら](https://github.com/bitcoin/bitcoin/blob/master/contrib/builder-keys/keys.txt)で見つけることができます。複数の貢献者の公開鍵でBitcoin Coreソフトウェアを検証することが推奨されます。
2. 次に、インポートした公開鍵を検証する必要があります。少なくとも一つのステップとして、見つけた公開鍵が他のさまざまな場所で公開されているものと同じであることを検証するべきです。例えば、公開鍵をインポートした人々の個人的なウェブページ、Twitterページ、またはGithubページを参照することができます。通常、この公開鍵の比較は、公開鍵の短いハッシュであるフィンガープリントを比較することによって行われます。
3. 次に、[ウェブサイト](www.bitcoincore.org)からBitcoin Coreの実行可能ファイルをダウンロードする必要があります。Linux、Windows、MACオペレーティングシステム用のパッケージが利用可能になります。
4. 次に、2つのリリースファイルを探す必要があります。最初のファイルには、ダウンロードした実行可能ファイルの公式SHA-256ハッシュと、リリースされたすべての他のパッケージのハッシュが含まれています。もう一つのリリースファイルには、パッケージハッシュを含むリリースファイルに対するさまざまな貢献者からの署名が含まれます。これらのリリースファイルは、Bitcoin Coreのウェブサイトに位置しているべきです。
5. 次に、Bitcoin Coreのウェブサイトからダウンロードした実行ファイルのSHA-256ハッシュを自分のコンピュータで計算する必要があります。その後、この結果を公式パッケージのハッシュと比較します。両者は同じであるべきです。6. 最後に、公式パッケージのハッシュに対するリリースファイルのデジタル署名が、あなたがインポートした1つ以上の公開鍵に実際に対応していることを確認する必要があります（Bitcoin Coreのリリースは常に全員によって署名されるわけではありません）。これは、Kleopetraのようなアプリケーションで行うことができます。

このソフトウェア検証プロセスには2つの主な利点があります。第一に、Bitcoin Coreのウェブサイトからダウンロードする際に伝送エラーがなかったことを保証します。第二に、攻撃者がBitcoin Coreのウェブサイトをハッキングするか、トラフィックを傍受することによって、変更された悪意のあるコードをダウンロードさせることができなかったことを保証します。

上記のソフトウェア検証プロセスは、これらの問題に対してどのように保護するのでしょうか？

あなたがインポートした公開鍵を入念に検証した場合、これらの鍵が実際に彼らのものであり、侵害されていないことをかなり確信することができます。デジタル署名には存在的偽造不可能性があるため、これらの貢献者だけがリリースファイルの公式パッケージハッシュにデジタル署名を行うことができたことを知っています。

ダウンロードしたリリースファイルの署名が確認できたとします。これで、ダウンロードしたWindows実行ファイルのローカルで計算したハッシュ値を、適切に署名されたリリースファイルに含まれるハッシュ値と比較することができます。SHA-256ハッシュ関数が衝突耐性を持っていることを知っているので、一致するということは、あなたの実行ファイルが公式の実行ファイルと完全に同じであることを意味します。

次に、ハッシュ関数の2番目の一般的な特性である**隠蔽性**について考えてみましょう。任意のハッシュ関数$H$は、非常に大きな範囲からランダムに選択された任意の$x$に対して、$H(x)$のみが与えられた場合に$x$を見つけることが不可能であるという隠蔽性の特性を持っていると言われています。

以下に、私が書いたメッセージのSHA-256出力を示します。十分なランダム性を確保するために、メッセージの最後にランダムに生成された文字列が含まれています。SHA-256が隠蔽性を持っていることを考えると、誰もこのメッセージを解読することはできません。

- `b194221b37fa4cd1cfce15aaef90351d70de17a98ee6225088b523b586c32ded`

しかし、SHA-256が弱くなるまであなたを不安にさせるつもりはありません。私が書いた元のメッセージは以下の通りです：

* 「これは非常にランダムなメッセージです、まあ、ある種のランダムさです。この始まりの部分はそうではありませんが、非常に予測不可能なメッセージを保証するために、いくつかの比較的ランダムな文字で終わります。XLWz4dVG3BxUWm7zQ9qS」。

隠蔽性を持つハッシュ関数が使用される一般的な方法の一つは、パスワード管理です（衝突耐性もこのアプリケーションには重要です）。FacebookやGoogleなどのまともなオンラインアカウントベースのサービスは、アカウントへのアクセスを管理するためにパスワードを直接保存しません。代わりに、そのパスワードのハッシュのみを保存します。ブラウザにパスワードを入力するたびに、最初にハッシュが計算されます。そのハッシュのみがサービスプロバイダーのサーバーに送信され、バックエンドデータベースに保存されているハッシュと比較されます。隠蔽性は、攻撃者がハッシュ値からそれを回復することを防ぐのに役立ちます。
パスワード管理は、ユーザーが実際に難しいパスワードを選択する場合にのみ、ハッシュを介して機能します。隠蔽性は、xが非常に大きな範囲からランダムに選択されるという前提に基づいています。「1234」、「mypassword」、またはあなたの誕生日の日付のようなパスワードを選択することは、実際のセキュリティを提供しません。一般的なパスワードとそのハッシュの長いリストが存在し、攻撃者があなたのパスワードのハッシュを入手した場合、それを利用することができます。このタイプの攻撃は、**辞書攻撃**として知られています。攻撃者があなたの個人情報の一部を知っている場合、彼らはいくつかの情報に基づいた推測を試みるかもしれません。したがって、常に長く、安全なパスワード（できればパスワードマネージャーからの長くランダムな文字列）が必要です。

時には、アプリケーションが衝突抵抗性と隠蔽性の両方を持つハッシュ関数を必要とすることがありますが、必ずしもそうではありません。たとえば、私たちが議論したソフトウェア検証プロセスは、ハッシュ関数が衝突抵抗性を示すことのみを要求し、隠蔽性は重要ではありません。

衝突抵抗性と隠蔽性は、暗号学におけるハッシュ関数の主要な求められる特性ですが、特定のアプリケーションでは他のタイプの特性も望ましい場合があります。

**注釈:**

[6] 「隠蔽」用語は一般的な言葉ではありませんが、Arvind Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller, Steven Goldfederによる*Bitcoin and Cryptocurrency Technologies*、Princeton University Press (Princeton, 2016)、第1章から特に取られています。

# RSA暗号システム
<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

## 因数分解問題
<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

対称暗号は通常、ほとんどの人にとって直感的に理解しやすいものですが、非対称暗号については通常そうではありません。前のセクションで提供された高レベルの説明には快適に感じるかもしれませんが、一方向関数が正確に何であり、どのようにして非対称スキームを構築するために使用されるかについて疑問に思うかもしれません。

この章では、非対称暗号に関するいくつかの謎を解き明かすことにより、具体的な例、すなわちRSA暗号システムをより深く見ていきます。最初のセクションでは、RSA問題が基づいている因数分解問題を紹介します。その後、数論からのいくつかの重要な結果をカバーします。最後のセクションでは、この情報をまとめてRSA問題を説明し、これを使用して非対称暗号スキームを作成する方法を説明します。

この議論に深みを加えることは簡単な作業ではありません。かなりの数の数論定理と命題を紹介する必要があります。しかし、数学に嫌気がささないでください。この議論を進めることで、非対称暗号の基礎についての理解が大幅に向上し、価値のある投資となります。

では、まず因数分解問題について見ていきましょう。

___

2つの数、例えば$a$と$b$を掛け合わせるとき、$a$と$b$を**因数**と呼び、結果を**積**と呼びます。2つ以上の因数に数$N$を書き換える試みは、**因数分解**または**分解**と呼ばれます。[1] これを必要とする問題を**因数分解問題**と呼ぶことができます。

約2,500年前、アレクサンドリアのギリシャ数学者ユークリッドは、整数の因数分解に関する重要な定理を発見しました。これは一般に**一意因数分解定理**と呼ばれ、次のように述べられています：

**定理1**. 1より大きいすべての整数$N$は、素数であるか、または素因数の積として表現することができます。
この声明の後半部分が意味するのは、1より大きい任意の非素数の整数$N$を取り、それを素数の積として書き出すことができるということです。以下は、非素数の整数が素因数の積として書かれたいくつかの例です。
* $18 = 2 \cdot 3 \cdot 3 = 2 \cdot 3^2$
* $84 = 2 \cdot 2 \cdot 3 \cdot 7 = 2^2 \cdot 3 \cdot 7$
* $144 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 3 \cdot 3 = 2^4 \cdot 3^2$

上記の3つの整数について、$N$が与えられただけでも、その素因数を計算するのは比較的簡単です。最小の素数である2から始め、整数$N$がそれに何回割り切れるかを確認します。次に、$N$が3、5、7などによって割り切れるかをテストします。このプロセスを、整数$N$が素数のみの積として書かれるまで続けます。

例えば、整数84について考えてみましょう。以下では、その素因数を決定するプロセスを見ることができます。各ステップで、最小の残りの素因数（左側）を取り出し、因数分解される残りの項を決定します。残りの項も素数になるまで続けます。各ステップで、84の現在の因数分解が最も右に表示されます。

* 素因数 = 2: 残りの項 = 42 	($84 = 2 \cdot 42$)
* 素因数 = 2: 残りの項 = 21 	($84 = 2 \cdot 2 \cdot 21$)
* 素因数 = 3: 残りの項 = 7 	($84 = 2 \cdot 2 \cdot 3 \cdot 7$)
* 7は素数であるため、結果は$2 \cdot 2 \cdot 3 \cdot 7$、または$2^2 \cdot 3 \cdot 7$です。

今、$N$が非常に大きいと仮定しましょう。$N$をその素因数に分解するのはどれほど難しいでしょうか？

それは本当に$N$に依存します。例えば、$N$が50,450,400であると仮定しましょう。この数は威圧的に見えるかもしれませんが、計算はそれほど複雑ではなく、手で簡単に行うことができます。上記と同様に、2から始めて順に進めます。以下に、上記と同様の方法でこのプロセスの結果を見ることができます。

* 2: 25,225,200 	($50,450,400 = 2 \cdot 25,225,200$)
* 2: 12,612,600 	($50,450,400 = 2^2 \cdot 12,612,600$)
* 2: 6,306,300 	($50,450,400 = 2^3 \cdot 6,306,300$)
* 2: 3,153,150 	($50,450,400 = 2^4 \cdot 3,153,150$)
* 2: 1,576,575 	($50,450,400 = 2^5 \cdot 1,576,575$)
* 3: 525,525 ($50,450,400 = 2^5 \cdot 3 \cdot 525,525$)
* 3: 175,175 ($50,450,400 = 2^5 \cdot 3^2 \cdot 175,175$)
* 5: 35,035 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5 \cdot 35,035$)
* 5: 7,007 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7,007$)
* 7: 1,001 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7 \cdot 1,001$)
* 7: 143 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 143$)
* 11: 13 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$)
* 13が素数であるため、結果は $2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$ です。

この問題を手で解くには時間がかかります。もちろん、コンピューターならこれを一瞬で行うことができます。実際、コンピューターは非常に大きな整数を一瞬で因数分解することがよくあります。

しかし、例外もあります。まず、二つの非常に大きな素数をランダムに選択するとします。これらを $p$ と $q$ とラベル付けするのが一般的で、ここではその慣習に従います。

具体的に言うと、$p$ と $q$ はどちらも1024ビットの素数であり、表現するには少なくとも1024ビットが必要です（つまり、最初のビットは1でなければなりません）。例えば、37は素数の一つにはなり得ません。確かに、37を1024ビットで表現することはできます。しかし、明らかにそれほど多くのビットを使って表現する*必要はありません*。37は6ビット以上ある任意の文字列で表現できます。（6ビットでは、37は$100101$と表されます）。

$p$ と $q$ が上記の条件下で選択された場合、それらがいかに大きいかを理解することが重要です。例として、表現に少なくとも1024ビットが必要なランダムな素数を以下に選びました。
* 14,752,173,874,503,595,484,930,006,383,670,759,559,764,562,721,397,166,747,289,220,945,457,932,666,751,048,198,854,920,097,085,690,793,755,254,946,188,163,753,506,778,089,706,699,671,722,089,715,624,760,049,594,106,189,662,669,156,149,028,900,805,928,183,585,427,782,974,951,355,515,394,807,209,836,870,484,558,332,897,443,152,653,214,483,870,992,618,171,825,921,582,253,023,974,514,209,142,520,026,807,636,589

仮に、ランダムに選んだ素数 $p$ と $q$ を掛け合わせて整数 $N$ を得たとします。この整数 $N$ は、2048ビット数であり、その表現には少なくとも2048ビットが必要です。これは、$p$ や $q$ よりもはるかに大きいです。

コンピュータに $N$ を与え、$N$ の1024ビットの素因数 $p$ と $q$ を見つけるように頼んだとします。コンピュータが $p$ と $q$ を発見する確率は極めて小さいです。実用上は不可能と言ってもよいでしょう。これは、スーパーコンピュータやスーパーコンピュータのネットワークを使用したとしても同様です。

まず、コンピュータが問題を解決しようとして、1024ビット数を順に調べ、それぞれが素数であり、$N$ の因数であるかどうかをテストするとします。テストされるべき素数のセットは、およそ $1.265 \cdot 10^{305}$ です。[2]

地球上のすべてのコンピュータを使ってこの方法で1024ビットの素数を見つけてテストしようとしても、$N$ の素因数を成功裏に見つける確率が10億分の1である場合、その計算期間は宇宙の年齢よりもはるかに長くなるでしょう。

実際には、コンピュータは先に述べた粗い手順よりもうまくやれます。コンピュータがより迅速に因数分解を行うために適用できるいくつかのアルゴリズムが存在します。しかし、これらの効率的なアルゴリズムを使用しても、コンピュータのタスクは依然として計算上不可能です。[3]

重要なのは、ただ述べた条件下での因数分解の難しさは、素因数を計算するための計算効率の良いアルゴリズムが存在しないという仮定に基づいているということです。実際に効率的なアルゴリズムが存在しないことを証明することはできません。それにもかかわらず、この仮定は非常に妥当です：何百年にもわたる広範な努力にもかかわらず、我々はそのような計算効率の良いアルゴリズムをまだ見つけていません。

したがって、特定の状況下での因数分解問題は、難問であると妥当に仮定できます。具体的には、$p$ と $q$ が非常に大きな素数である場合、それらの積 $N$ を計算することは難しくありませんが、$N$ のみが与えられた場合の因数分解は実際には不可能です。

**注釈:**

[1] 因数分解は、数値以外の他の種類の数学的対象を扱う際にも重要です。例えば、$x^2 - 2x + 1$ のような多項式表現を因数分解することが有用です。私たちの議論では、特に整数の因数分解にのみ焦点を当てます。
[2] **素数定理**によると、$N$以下の素数の数はおおよそ$N/\ln(N)$であるとされています。これは、1024ビットの長さを持つ素数の数を以下のように近似できることを意味します：
$$ \frac{2^{1024}}{\ln(2^{1024})} - \frac{2^{1023}}{\ln(2^{1023})} $$

...これはおおよそ$1.265 \times 10^{305}$に等しいです。

[3] 離散対数問題についても同様です。これが、非対称暗号構造が対称暗号構造よりもはるかに大きな鍵を使用する理由です。

## 数論の結果
<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

残念ながら、因数分解問題は非対称暗号スキームに直接使用することはできません。しかし、より複雑で関連する問題を利用することで、この効果を得ることができます：RSA問題です。

RSA問題を理解するためには、数論からのいくつかの定理と命題を理解する必要があります。これらはこのセクションで3つのサブセクションに分けて紹介されています：(1) $N$の位数、(2) $N$における可逆性、(3) オイラーの定理。

この3つのサブセクションで紹介される内容の一部は、*第3章*ですでに導入されています。しかし、便宜上ここでその内容を再述します。

### $N$の位数

整数$a$が整数$N$と**互いに素**、または**相対素**であるとは、それらの間の最大公約数が1である場合を指します。1は慣習的に素数ではありませんが、すべての整数の互いに素です（$-1$も同様です）。

例えば、$a = 18$、$N = 37$の場合を考えてみましょう。これらは明らかに互いに素です。18と37の両方を割り切る最大の整数は1です。対照的に、$a = 42$、$N = 16$の場合を考えてみましょう。これらは明らかに互いに素ではありません。両方の数は2で割り切れ、これは1より大きいです。

これで、$N$の位数を次のように定義することができます。$N$が1より大きい整数であると仮定します。**$N$の位数**は、次の条件を満たす$N$と互いに素なすべての数の数です：$1 \leq a < N$。

例えば、$N = 12$の場合、1, 5, 7, 11のみが上記の要件を満たす互いに素です。したがって、12の位数は4に等しいです。

$N$が素数である場合、$N$より小さいが1以上の任意の整数はそれと互いに素です。これには次のセットのすべての要素が含まれます：$\{1,2,3,….,N - 1\}$。したがって、$N$が素数の場合、$N$の位数は$N - 1$です。これは命題1で述べられており、$\phi(N)$は$N$の位数を示します。

**命題1**。$N$が素数の場合、$\phi(N) = N - 1$です。
$N$が素数でないと仮定します。その場合、**オイラーのファイ関数**を使用してその位数を計算することができます。小さな整数の位数を計算するのは比較的簡単ですが、オイラーのファイ関数は特に大きな整数に対して重要になります。オイラーのファイ関数の提案は以下の通りです。

**定理2**。$N$を$N = p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_i^{e_i} \cdot \ldots \cdot p_n^{e_n}$とし、集合$\{p_i\}$は$N$のすべての異なる素因数を含み、各$e_i$は素因数$p_i$が$N$に対して何回発生するかを示します。すると、

$$\phi(N) = p_1^{e_1 - 1} \cdot (p_1 - 1) \cdot p_2^{e_2 - 1} \cdot (p_2 - 1) \cdot \ldots \cdot p_n^{e_n - 1} \cdot (p_n - 1)$$

**定理2**は、非素数$N$をその異なる素因数に分解すると、$N$の位数を簡単に計算できることを示しています。

例えば、$N = 270$と仮定します。これは明らかに素数ではありません。$N$をその素因数に分解すると、式$2 \cdot 3^3 \cdot 5$が得られます。オイラーのファイ関数によると、その後$N$の位数は次のようになります：

$$\phi(N) = 2^{1 - 1} \cdot (2 - 1) + 3^{3 - 1} \cdot (3 - 1) + 5^{1 - 1} \cdot (5 - 1) = 1 \cdot 1 + 9 \cdot 2 + 1 \cdot 4 = 1 + 18 + 4 = 23$$

次に、$N$が2つの素数$p$と$q$の積であると仮定します。上記の**定理2**は、その場合、$N$の位数は次のようになります：

$$p^{1 - 1} \cdot (p - 1) \cdot q^{1 - 1} \cdot (q - 1) = (p - 1) \cdot (q - 1)$$

これは特にRSA問題にとって重要な結果であり、以下の**命題2**で述べられています。

**命題2**。$N$が2つの素数$p$と$q$の積である場合、$N$の位数は積$(p - 1) \cdot (q - 1)$です。

例を挙げると、$N = 119$と仮定します。この整数は2つの素数、すなわち7と17に因数分解することができます。したがって、オイラーのファイ関数は119の位数は次のようになることを示唆しています：

$$\phi(119) = (7 - 1) \cdot (17 - 1) = 6 \cdot 16 = 96$$

言い換えると、整数119は1から119までの範囲で96個の互いに素な数を持っています。実際、この集合には7または17の倍数でない1から119までのすべての整数が含まれます。
ここから、$N$の順序を決定する互いに素な集合を$C_N$と表記しましょう。例えば、$N = 119$の場合、集合$C_{119}$は完全にリストアップするにはあまりにも大きすぎます。しかし、その要素のいくつかは以下の通りです：
$$C_{119} = \{1, 2, \dots 6, 8 \dots 13, 15, 16, 18, \dots 33, 35 \dots 96\}$$

### Nに関する可逆性

整数$a$が**Nに関する可逆性**を持つとは、少なくとも1つの整数$b$が存在し、$a \cdot b \mod N = 1 \mod N$となる場合を指します。このような任意の整数$b$は、$a$の**逆数**（または**乗法的逆数**）として、モジュロ$N$による削減で参照されます。

例えば、$a = 5$かつ$N = 11$の場合を考えてみましょう。5に乗算できる多くの整数があり、$5 \cdot b \mod 11 = 1 \mod 11$となります。例として、整数20と31を考えてみましょう。これらの整数が5の11によるモジュロ削減の逆数であることは容易にわかります。

* $5 \cdot 20 \mod 11 = 100 \mod 11 = 1 \mod 11$
* $5 \cdot 31 \mod 11 = 155 \mod 11 = 1 \mod 11$

5には11によるモジュロ削減の多くの逆数がありますが、11より小さい単一の正の逆数が存在することを示すことができます。実際、これは私たちの特定の例に限定されたものではなく、一般的な結果です。

**命題3**。整数$a$が$N$に関して可逆である場合、$a$の正の逆数が正確に1つだけ$N$より小さい必要があります。（つまり、このユニークな$a$の逆数は集合$\{1, \dots, N - 1\}$から来なければなりません）。

**命題3**からの$a$のユニークな逆数を$a^{-1}$と表記しましょう。$a = 5$かつ$N = 11$の場合、$a^{-1} = 9$であることがわかります。なぜなら、$5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$だからです。

$a$の他の逆数を11によるモジュロで削減することによっても、私たちの例で$a^{-1}$の値9を得ることができることに注意してください。例えば、$20 \mod 11 = 31 \mod 11 = 9 \mod 11$です。したがって、整数$a > N$が$N$に関して可逆である場合、$a \mod N$もまた$N$に関して可逆でなければなりません。

$a$の逆数が$N$によるモジュロ削減で存在するとは限りません。例えば、$a = 2$かつ$N = 8$の場合を想定してみてください。$2 \cdot b \mod 8 = 1 \mod 8$となるような$b$、特に$a^{-1}$は存在しません。これは、$b$の任意の値が常に2の倍数を生成するため、8で割った余りが1になることは決してありません。
整数 $a$ が与えられた $N$ に対して逆数を持つかどうかをどのようにして知ることができるのでしょうか？上記の例で気づいたかもしれませんが、2と8の最大公約数は1より大きい、つまり2です。これは実際に以下の一般的な結果を示しています：
**命題 4**。整数 $a$ が $N$ に対してモジュロ削減で逆数を持つ、特に $N$ より小さい一意の正の逆数を持つのは、$a$ と $N$ の最大公約数が1（つまり、互いに素である）の場合に限ります。

$a = 5$ および $N = 11$ の場合、$5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$ であるため、$a^{-1} = 9$ と結論付けました。逆もまた真であることに注意することが重要です。つまり、$a = 9$ および $N = 11$ の場合、$a^{-1} = 5$ です。

### オイラーの定理

RSA問題に移る前に、もう1つ重要な定理、すなわち**オイラーの定理**を理解する必要があります。それは以下のように述べています：

**定理 3**。2つの整数 $a$ と $N$ が互いに素であるとします。すると、$a^{\phi(N)} \mod N = 1 \mod N$ です。

これは注目すべき結果ですが、最初は少し混乱するかもしれません。理解するために例を挙げましょう。

$a = 5$ および $N = 7$ とします。これらはオイラーの定理が要求するように、確かに互いに素です。7の位数が6であることがわかります。なぜなら、7は素数であるためです（**命題 1**を参照）。

オイラーの定理が現在述べているのは、$5^6 \mod 7$ が $1 \mod 7$ と等しくなければならないということです。以下はこれが実際に真であることを示す計算です。

* $5^6 \mod 7 = 15,625 \mod 7 = 1 \mod N$

整数7は15,624を合計2,233回割ります。したがって、16,625を7で割った余りは1です。

次に、オイラーのファイ関数を使用して、以下の**命題 5**を導き出すことができます。

**命題 5**。任意の正の整数 $a$ と $b$ に対して、$\phi(a \cdot b) = \phi(a) \cdot \phi(b)$ です。

これがなぜかを示すことはしません。しかし、$p$ と $q$ が素数である場合に $\phi(p \cdot q) = \phi(p) \cdot \phi(q) = (p - 1) \cdot (q - 1)$ であると述べた**命題 2**によって、この命題の証拠をすでに見ていることに注意してください。

オイラーの定理と**命題 5**を組み合わせると、重要な意味があります。例えば、$a$ と $N$ が互いに素である場合の以下の式を見てみましょう。

* $a^{2 \cdot \phi(N)} \mod N = a^{\phi(N)} \cdot a^{\phi(N)} \mod N = 1 \cdot 1 \mod N = 1 \mod N$
* $a^{\phi(N) + 1} \mod N = a^{\phi(N)} \cdot a^1 \mod N = 1 \cdot a^1 \mod N = a \mod N$
* $a^{8 \cdot \phi(N) + 3} \mod N = a^{8 \cdot \phi(N)} \cdot a^3 \mod N = 1 \cdot a^3 \mod N = a^3 \mod N$

したがって、オイラーの定理と**命題5**の組み合わせにより、多くの式を単純に計算することができます。一般的に、この洞察を**命題6**としてまとめることができます。

**命題6**。$a^x \mod N = a^{x \mod \phi(N)}$

これで、最後の難しいステップで全てをまとめる必要があります。

$N$が集合$C_N$の要素を含む順序$\phi(N)$を持つように、整数$\phi(N)$もまた順序と互いに素な集合を持つことがわかります。$\phi(N) = R$としましょう。すると、$\phi(R)$の値と互いに素な集合$C_R$も存在することがわかります。

ここで、集合$C_R$から整数$e$を選択するとします。**命題3**から、この整数$e$は$R$より小さい一意の正の逆数を持つことがわかります。つまり、$e$は集合$C_R$から一意の逆数を持ちます。この逆数を$d$と呼びましょう。逆数の定義から、これは$e \cdot d = 1 \mod R$を意味します。

この結果を使って、元の整数$N$についての声明を行うことができます。これは**命題7**に要約されています。

**命題7**。$e \cdot d \mod \phi(N) = 1 \mod \phi(N)$と仮定します。すると、集合$C_N$の任意の要素$a$について、$a^{e \cdot d \mod \phi(N)} = a^{1 \mod \phi(N)} = a \mod N$でなければなりません。

これで、RSA問題を明確に述べるために必要な数論的な結果を全て得ました。

## RSA暗号システム
<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>

これで、RSA問題を述べる準備が整いました。$p$、$q$、$N$、$\phi(N)$、$e$、$d$、そして$y$からなる変数のセットを作成すると仮定します。このセットを$\Pi$と呼びます。次のようにして作成されます：

1. 同じサイズの2つのランダムな素数$p$と$q$を生成し、それらの積$N$を計算します。
2. 次の積によって$N$の順序、$\phi(N)$を計算します：$(p - 1) \cdot (q - 1)$。
3. $\phi(N)$に対して小さく、互いに素であるような$e > 2$を選択します。
4. $e \cdot d \mod \phi(N) = 1$となるように$d$を計算します。
5. $N$に対して小さく、互いに素であるランダムな値$y$を選択します。
RSA問題は、$x^e = y$ となるような $x$ を見つけることであり、$\Pi$ に関する情報の一部、すなわち変数 $N$、$e$、および $y$ のみが与えられている状態です。$p$ と $q$ が非常に大きい場合、通常はそれらが1024ビットのサイズであることが推奨されますが、RSA問題は難しいと考えられています。先行する議論を踏まえると、その理由が理解できるでしょう。

$x^e \mod N = y \mod N$ のとき $x$ を簡単に計算する方法は、単に $y^d \mod N$ を計算することです。次の計算により、$y^d \mod N = x \mod N$ であることがわかります：

$$ y^d \mod N = x^{e \cdot d} \mod N = x^{e \cdot d \mod \phi(N)} \mod N = x^{1 \mod \phi(N)} \mod N = x \mod N. $$

問題は、問題で $d$ の値が与えられていないため、直接 $y^d \mod N$ を計算して $x \mod N$ を生成することができないことです。

しかし、$e \cdot d \mod \phi(N) = 1 \mod \phi(N)$ であることを知っているため、$N$ の順序、$\phi(N)$ から間接的に $d$ を計算することができるかもしれません。しかし、仮定により問題は $\phi(N)$ の値も与えていません。

最終的に、素数 $p$ と $q$ によって間接的に順序を計算できるため、最終的に $d$ を計算できます。しかし、仮定により、$p$ と $q$ の値も私たちには提供されていませんでした。

厳密に言えば、RSA問題内の因数分解問題が難しい場合でも、RSA問題自体が難しいとは証明できません。因数分解を通じてではない他の方法でRSA問題を解決できる可能性があるからです。しかし、RSA問題内の因数分解問題が難しい場合、RSA問題自体も難しいと一般に受け入れられていると仮定されています。

RSA問題が実際に難しい場合、それはトラップドアを持つ一方向関数を生成します。ここでの関数は $f(g) = g^e \mod N$ です。$f(g)$ の知識があれば、誰でも特定の $g = x$ に対する値 $y$ を簡単に計算できます。しかし、値 $y$ と関数 $f(g)$ を知っているだけでは、特定の値 $x$ を計算することは実際には不可能です。例外は、情報 $d$、トラップドアが与えられた場合です。その場合、単に $y^d$ を計算して $x$ を得ることができます。

RSA問題を説明するために、具体的な例を通して見てみましょう。上記の条件下で難しいと考えられるRSA問題を選択することはできません。なぜなら、数字が扱いにくいからです。代わりに、この例はRSA問題が一般的にどのように機能するかを示すためのものです。

始めるために、2つのランダムな素数13と31を選択するとします。したがって $p = 13$ と $q = 31$ です。これら2つの素数の積 $N$ は403に等しいです。403の順序を簡単に計算できます。それは $(13 - 1) \cdot (31 - 1) = 360$ に相当します。
次に、RSA問題のステップ3で指示されているように、360の互いに素で、2より大きく360より小さい値を選択する必要があります。この値をランダムに選択する必要はありません。例えば、103を選択したとします。これは、103との最大公約数が1であるため、360の互いに素です。

ステップ4では、$103 \cdot d \mod 360 = 1$となるような値$d$を計算する必要があります。$N$の値が大きい場合、これは手作業では容易ではありません。**拡張ユークリッドアルゴリズム**と呼ばれる手順を使用する必要があります。

ここでは手順を示しませんが、$e = 103$の場合、この値は7になります。以下の計算を通じて、103と7の値の組み合わせが一般的な条件$e \cdot d \mod \phi(n) = 1$を満たしていることを確認できます。

* $103 \cdot 7 \mod 360 = 721 \mod 360 = 1 \mod 360$

重要なことに、*命題4*によれば、1から360の間の他の整数で$d$を選んだ場合、$103 \cdot d = 1 \mod 360$という結果を得ることはありません。さらに、この命題は、$e$に異なる値を選択すると、$d$に対して異なるユニークな値が得られることを意味しています。

RSA問題のステップ5では、403のより小さい互いに素である正の整数$y$を選択する必要があります。$y = 2^{103}$と設定するとします。2を103で累乗すると、以下の結果が得られます。

* $2^{103} \mod 403 = 10,141,204,801,825,835,211,973,625,643,008 \mod 403 = 349 \mod 403$

この特定の例でのRSA問題は次のようになります：$N = 403$、$e = 103$、そして$y = 349 \mod 403$が与えられます。あなたは$x^{103} = 349 \mod 403$となるような$x$を計算する必要があります。つまり、103で累乗する前の元の値が2であったことを見つける必要があります。

$d = 7$であることがわかっていれば（少なくともコンピュータにとっては）$x$を計算するのは簡単です。その場合、以下のように$x$を決定できます。

* $x = y^7 \mod 403 = 349^7 \mod 403 = 630,634,881,591,804,949 \mod 403 = 2 \mod 403$

問題は、$d = 7$であるという情報が提供されていないことです。もちろん、$103 \cdot d = 1 \mod 360$であることから$d$を計算することはできます。しかし、$N = 360$の順序が与えられていないという情報もありません。最後に、$(p - 1) \cdot (q - 1)$の積を計算することによって403の順序を計算することもできますが、$p = 13$および$q = 31$であるという情報も提供されていません。

もちろん、関与する素数が大きくない場合、コンピュータはこの例のRSA問題を比較的簡単に解決できます。しかし、素数が非常に大きくなると、実質的に不可能なタスクに直面します。
RSA問題、それが困難である一連の条件、およびその背景にある数学について説明しました。これらはどのようにして非対称暗号化に役立つのでしょうか？具体的には、特定の条件下でのRSA問題の困難さをどのようにして暗号化スキームやデジタル署名スキームに変換できるのでしょうか？

一つのアプローチは、RSA問題を取り、直接的な方法でスキームを構築することです。例えば、RSA問題で説明されたように変数のセット$\Pi$を生成し、$p$と$q$が十分に大きいことを確認します。公開鍵を$(N, e)$と設定し、この情報を世界中と共有します。上述のように、$p$、$q$、$\phi(n)$、および$d$の値は秘密に保ちます。実際には、$d$があなたの秘密鍵です。

メッセージ$m$（$C_N$の要素）を送りたい人は、単に次のようにして暗号化できます：$c = m^e \mod N$。（ここでの暗号文$c$は、RSA問題の値$y$に相当します。）このメッセージを解読するには、単に$c^d \mod N$を計算するだけです。

同様の方法でデジタル署名スキームを作成しようとするかもしれません。デジタル署名$S$を付けたメッセージ$m$を誰かに送りたいとします。$S = m^d \mod N$と設定し、ペア$(m,S)$を受信者に送ります。誰でもデジタル署名を検証することができます。ただし、$S^e \mod N = m \mod N$を確認するだけです。しかし、攻撃者は$d$を持っていないため、メッセージに対して有効な$S$を作成するのは非常に困難です。

残念ながら、RSA問題というそれ自体が困難な問題を、このように直接的な暗号化スキームに変換することはそれほど簡単ではありません。直接的な暗号化スキームでは、メッセージとして$N$の互いに素なもののみを選択できます。これでは、標準的な通信に十分なメッセージが得られません。さらに、これらのメッセージはランダムに選択されなければなりません。これはやや非現実的に思えます。最後に、二度選択された任意のメッセージは、全く同じ暗号文を生成します。これは、任意の暗号化スキームにおいて極めて望ましくないものであり、暗号化における厳格な現代のセキュリティ概念を満たしていません。

直接的なデジタル署名スキームにおいては、問題はさらに悪化します。現状では、攻撃者は$N$の互いに素な署名を最初に選択し、対応する元のメッセージを計算することで、簡単にデジタル署名を偽造できます。これは、存在的偽造不可能性の要件を明らかに破っています。

それでも、少しの賢い複雑さを加えることで、RSA問題を使用して安全な公開鍵暗号化スキームおよび安全なデジタル署名スキームを作成することができます。ここでは、そのような構築の詳細には入りません。[4] 重要なことは、しかし、この追加の複雑さがこれらのスキームが基づいている基本的なRSA問題を変えることはないということです。

**注釈:**

[4] 例えば、Jonathan KatzとYehuda Lindellの「_Introduction to Modern Cryptography_」、CRC Press（Boca Raton, FL: 2015）、pp. 410–32にRSA暗号化、pp. 444–41にRSAデジタル署名について参照してください。