---
name: Введение в формальную криптографию
goal: Глубокое погружение в науку и практику криптографии.
objectives:
  - Изучить шифры Била и современные криптографические методы для понимания базовых и исторических концепций криптографии.
  - Погрузиться в теорию чисел, группы и поля для освоения ключевых математических концепций, лежащих в основе криптографии.
  - Изучить потоковый шифр RC4 и AES с 128-битным ключом для изучения симметричных криптографических алгоритмов.
  - Исследовать криптосистему RSA, распределение ключей и хеш-функции для изучения асимметричной криптографии.

---
# Глубокое погружение в криптографию

Трудно найти много материалов, которые предлагали бы хорошее среднее поле в образовании по криптографии.

С одной стороны, есть длинные, формальные трактаты, доступные действительно только тем, у кого есть крепкий фон в математике, логике или какой-либо другой формальной дисциплине. С другой стороны, есть очень высокоуровневые введения, которые действительно скрывают слишком много деталей для тех, кто хотя бы немного любопытен.

Это введение в криптографию стремится захватить среднее поле. Хотя оно должно быть относительно сложным и подробным для кого-то, кто новичок в криптографии, это не кроличья нора типичного основополагающего трактата.

+++

# Введение
<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## Краткое описание
<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

Эта книга предлагает глубокое погружение в науку и практику криптографии. Где это возможно, она сосредотачивается на концептуальном, а не формальном изложении материала.

> Этот курс основан на [репозитории JWBurgers](https://github.com/JWBurgers/An_Introduction_to_Cryptography). Все права принадлежат ему. Контент еще не завершен и здесь только для демонстрации того, как мы могли бы интегрировать его, если JWburger's согласится.

### Мотивация и цели

Трудно найти много материалов, которые предлагали бы хорошее среднее поле в образовании по криптографии.

С одной стороны, есть длинные, формальные трактаты, доступные действительно только тем, у кого есть крепкий фон в математике, логике или какой-либо другой формальной дисциплине. С другой стороны, есть очень высокоуровневые введения, которые действительно скрывают слишком много деталей для тех, кто хотя бы немного любопытен.

Это введение в криптографию стремится захватить среднее поле. Хотя оно должно быть относительно сложным и подробным для кого-то, кто новичок в криптографии, это не кроличья нора типичного основополагающего трактата.

### Целевая аудитория

От разработчиков до интеллектуально любознательных, эта книга будет полезна всем, кто хочет более чем поверхностного понимания криптографии. Если ваша цель - овладеть областью криптографии, то эта книга также является хорошей отправной точкой.

### Руководство к чтению

На данный момент книга содержит семь глав: "Что такое криптография?" (Глава 1), "Математические основы криптографии I" (Глава 2), "Математические основы криптографии II" (Глава 3), "Симметричная криптография" (Глава 4), "RC4 и AES" (Глава 5), "Асимметричная криптография" (Глава 6) и "Криптосистема RSA" (Глава 7). Финальная глава, "Криптография на практике", еще будет добавлена. Она сосредоточена на различных криптографических приложениях, включая безопасность транспортного уровня, маршрутизацию через луковицу и систему обмена стоимостями Bitcoin.
Если у вас нет крепкой базы в математике, теория чисел, вероятно, будет самой сложной темой в этой книге. Я предлагаю обзор этой темы в Главе 3, она также встречается в изложении AES в Главе 5 и криптосистемы RSA в Главе 7.
Если вы действительно испытываете трудности с формальными деталями в этих частях книги, я рекомендую вам для начала ограничиться высокоуровневым чтением.

### Благодарности

Наиболее влиятельной книгой, оказавшей влияние на эту, была книга Джонатана Каца и Йехуды Линделла _Введение в современную криптографию_, CRC Press (Бока-Ратон, Флорида), 2015. Сопутствующий курс доступен на Coursera под названием "Криптография".

Основные дополнительные источники, которые помогли создать обзор в этой книге, это Саймон Сингх, _Книга шифров_, Fourth Estate (Лондон, 1999); Кристоф Паар и Ян Пельцль, _Понимание криптографии_, Springer (Гейдельберг, 2010) и [курс на основе книги Паара под названием "Введение в криптографию"](https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg); и Брюс Шнайер, Прикладная криптография, 2-е издание, 2015 (Индианаполис, Индиана: John Wiley & Sons).

Я буду цитировать только очень конкретную информацию и результаты, которые я беру из этих источников, но хочу здесь признать мою общую благодарность им.

Для тех читателей, которые хотят получить более продвинутые знания по криптографии после этого введения, я настоятельно рекомендую книгу Каца и Линделла. Курс Каца на Coursera несколько более доступен, чем книга.

### Вклад

Пожалуйста, ознакомьтесь с [файлом вкладов в репозитории](https://github.com/JWBurgers/An_Introduction_to_Cryptography/blob/master/Contributions.md) для получения рекомендаций о том, как поддержать проект.

### Обозначения

**Ключевые термины:**

Ключевые термины в вводных материалах выделяются жирным шрифтом. Например, введение шифра Рейндал как ключевого термина выглядело бы следующим образом: **шифр Рейндал**.

Ключевые термины явно определяются, если только они не являются собственными именами или их значение очевидно из обсуждения.

Определение обычно дается при введении ключевого термина, хотя иногда более удобно оставить определение до более позднего момента.

**Выделенные слова и фразы:**

Слова и фразы выделяются курсивом. Например, фраза "Помните ваш пароль" выглядела бы следующим образом: *Помните ваш пароль*.

**Формальные обозначения:**

Формальные обозначения в основном касаются переменных, случайных переменных и множеств.

* Переменные: Обычно они обозначаются просто строчной буквой (напр., "x" или "y"). Иногда они пишутся с заглавной буквы для ясности (напр., "M" или "K").
* Случайные переменные: Всегда обозначаются заглавной буквой (напр., "X" или "Y")
* Множества: Всегда обозначаются жирным, заглавными буквами (напр., **S**)

# Что такое криптография?
<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

## Шифры Била
<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>
Давайте начнем наше исследование в области криптографии с одного из наиболее очаровательных и увлекательных эпизодов в ее истории: истории шифров Била. [1]
На мой взгляд, история шифров Била скорее вымысел, чем реальность. Но, предположительно, все произошло следующим образом.

Зимой 1820 и 1822 годов мужчина по имени Томас Дж. Бил останавливался в гостинице, которой владел Роберт Моррис в Линчбурге (Вирджиния). В конце второго визита Била он передал Моррису железный ящик с ценными бумагами для хранения.

Через несколько месяцев Моррис получил от Била письмо, датированное 9 мая 1822 года. В нем подчеркивалась большая ценность содержимого железного ящика и излагались некоторые инструкции Моррису: если ни Бил, ни кто-либо из его товарищей так и не придут за ящиком, он должен открыть его ровно через десять лет с даты письма (то есть 9 мая 1832 года). Некоторые из бумаг внутри будут написаны обычным текстом. Несколько других, однако, будут "непонятны без помощи ключа". Этот "ключ" затем должен был быть доставлен Моррису неизвестным другом Била в июне 1832 года.

Несмотря на четкие инструкции, Моррис не открыл ящик в мае 1832 года, и загадочный друг Била так и не появился в июне того же года. Только в 1845 году хозяин гостиницы наконец решился открыть ящик. В нем Моррис нашел записку, объясняющую, как Бил и его товарищи нашли золото и серебро на Западе и закопали его вместе с некоторыми ювелирными изделиями для сохранности. Кроме того, в ящике содержались три **шифротекста**: то есть тексты, написанные в коде, которые требуют **криптографического ключа**, или секрета, и сопутствующего алгоритма для их расшифровки. Этот процесс расшифровки шифротекста известен как **дешифрование**, в то время как процесс кодирования известен как **шифрование**. (Как объясняется в главе 3, термин шифр может иметь различные значения. В названии "шифры Била" он означает шифротексты.)

Три шифротекста, найденные Моррисом в железном ящике, каждый состоят из серии чисел, разделенных запятыми. Согласно записке Била, эти шифротексты отдельно указывают местоположение сокровища, содержание сокровища и список имен с законными наследниками сокровища и их долями (последняя информация актуальна в случае, если Бил и его товарищи так и не придут за ящиком).

Моррис пытался расшифровать три шифротекста в течение двадцати лет. Это было бы легко с ключом. Но у Морриса не было ключа, и ему не удалось восстановить оригинальные тексты, или **открытые тексты**, как они обычно называются в криптографии.

Приближаясь к концу своей жизни, Моррис передал ящик другу в 1862 году. Этот друг впоследствии опубликовал брошюру в 1885 году под псевдонимом Дж.Б. Уорд. В ней содержалось описание (предполагаемой) истории ящика, трех шифротекстов и решение, которое он нашел для второго шифротекста. (По-видимому, существует один ключ для каждого шифротекста, а не один ключ, который работает на всех трех шифротекстах, как изначально, кажется, предполагал Бил в своем письме Моррису.)

Вы можете увидеть второй шифротекст на *Рисунке 2* ниже. [2] Ключ к этому шифротексту - Декларация независимости Соединенных Штатов. Процедура дешифрования сводится к применению следующих двух правил:
* Для любого числа n в шифротексте найдите n-ое слово в Декларации независимости Соединенных Штатов* Замените число n первой буквой найденного слова

*Рисунок 1: Шифр Била № 2*

![Рисунок 1: Шифр Била № 2](assets/Figure1-1.webp "Рисунок 1: Шифр Била № 2")

Например, первое число второго шифротекста - 115. 115-е слово Декларации независимости - “instituted”, так что первая буква открытого текста - “i”. Шифротекст напрямую не указывает на разделение слов и использование заглавных букв. Но после расшифровки первых нескольких слов, можно логически предположить, что первое слово открытого текста было просто “I.” (Открытый текст начинается с фразы “I have deposited in the county of Bedford.”)

После расшифровки, второе сообщение предоставляет детальное содержание сокровища (золото, серебро и драгоценности) и предполагает, что оно было закопано в железных горшках и покрыто камнями в округе Бедфорд (Вирджиния). Люди любят хорошие тайны, поэтому были приложены большие усилия для расшифровки двух других шифров Била, особенно того, который описывает местоположение сокровища. Даже различные выдающиеся криптографы пробовали свои силы в их расшифровке. Однако, пока никому не удалось расшифровать два других шифротекста.

**Примечания:**

[1] Для хорошего обзора истории см. Саймон Сингх, *Книга о шифрах*, Fourth Estate (Лондон, 1999), стр. 82-99. Короткометражный фильм об этой истории был сделан Эндрю Алленом в 2010 году. Фильм, “Шифр Томаса Била,” можно найти [на его веб-сайте](http://www.thomasbealecipher.com/).

[2] Это изображение доступно на странице Википедии о шифрах Била.

## Современная криптография
<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

Цветные истории, такие как о шифрах Била, это то, с чем большинство из нас ассоциирует криптографию. Тем не менее, современная криптография отличается по крайней мере в четырех важных аспектах от этих типов исторических примеров.

Во-первых, исторически криптография заботилась только о **секретности** (или конфиденциальности). [3] Шифротексты создавались для того, чтобы только определенные стороны могли быть посвящены в информацию открытых текстов, как в случае с шифрами Била. Чтобы схема шифрования хорошо служила этой цели, расшифровка шифротекста должна быть выполнима только если у вас есть ключ.

Современная криптография заботится о более широком спектре тем, чем просто секретность. Эти темы включают в первую очередь (1) **целостность сообщения** — то есть, уверенность в том, что сообщение не было изменено; (2) **подлинность сообщения** — то есть, уверенность в том, что сообщение действительно было отправлено конкретным отправителем; и (3) **невозможность отказа** — то есть, уверенность в том, что отправитель не сможет ложно отрицать позже, что он отправил сообщение. [4]

Важное различие, о котором следует помнить, таким образом, между **схемой шифрования** и **криптографической схемой**. Схема шифрования заботится только о секретности. Хотя схема шифрования является криптографической схемой, обратное не является верным. Криптографическая схема также может служить другим основным темам криптографии, включая целостность, подлинность и невозможность отказа.
Темы целостности и подлинности так же важны, как и секретность. Наши современные системы коммуникаций не смогли бы функционировать без гарантий касательно целостности и подлинности коммуникаций. Неотказуемость также является важным аспектом, например, для цифровых контрактов, но она нужна в криптографических приложениях менее универсально, чем секретность, целостность и подлинность.

Во-вторых, классические схемы шифрования, такие как шифры Била, всегда включали один ключ, который был общим для всех заинтересованных сторон. Однако многие современные криптографические схемы включают не один, а два ключа: **личный** и **публичный ключ**. При этом первый должен оставаться приватным в любых приложениях, в то время как второй обычно является общедоступным (отсюда и их соответствующие названия). В области шифрования публичный ключ может использоваться для шифрования сообщения, в то время как личный ключ может использоваться для дешифрования.

Отрасль криптографии, которая занимается схемами, где все стороны используют один ключ, известна как **симметричная криптография**. Единственный ключ в такой схеме обычно называется **личным ключом** (или секретным ключом). Отрасль криптографии, которая занимается схемами, требующими пары личного и публичного ключей, известна как **асимметричная криптография**. Эти отрасли иногда также называют **криптографией с закрытым ключом** и **криптографией с открытым ключом** соответственно (хотя это может вызвать путаницу, поскольку в схемах криптографии с открытым ключом также есть закрытые ключи).

Появление асимметричной криптографии в конце 1970-х годов стало одним из самых важных событий в истории криптографии. Без нее большинство наших современных коммуникационных систем, включая Bitcoin, не было бы возможным или, по крайней мере, было бы очень неудобным.

Важно, что современная криптография не исключительно изучает симметричные и асимметричные криптографические схемы (хотя это и покрывает большую часть поля). Например, криптография также занимается хеш-функциями и генераторами псевдослучайных чисел, и вы можете создавать приложения на этих примитивах, которые не связаны с симметричной или асимметричной криптографией.

В-третьих, классические схемы шифрования, подобные тем, что использовались в шифрах Била, были скорее искусством, чем наукой. Их воспринимаемая безопасность во многом основывалась на интуиции относительно их сложности. Обычно их модифицировали, когда узнавали о новой атаке на них, или полностью отказывались от них, если атака была особенно серьезной. Современная криптография, однако, является строгой наукой с формальным, математическим подходом к разработке и анализу криптографических схем. [5]

В частности, современная криптография сосредоточена на формальных **доказательствах безопасности**. Любое доказательство безопасности для криптографической схемы проходит три этапа:

1.	Формулировка **криптографического определения безопасности**, то есть набора целей безопасности и угрозы, исходящей от атакующего.
2.	Формулировка любых математических предположений относительно вычислительной сложности схемы. Например, криптографическая схема может содержать генератор псевдослучайных чисел. Хотя мы не можем доказать их существование, мы можем предполагать, что они существуют.
3.	Изложение математического **доказательства безопасности** схемы на основе формального понятия безопасности и любых математических предположений.

В-четвертых, в то время как исторически криптография в основном использовалась в военных целях, она стала проникать в наши повседневные действия в цифровую эпоху. Будь то онлайн-банкинг, публикации в социальных сетях, покупка товара на Amazon с вашей кредитной картой или отправка чаевых другу в биткоинах, криптография является sine qua non нашей цифровой эпохи.

Учитывая эти четыре аспекта современной криптографии, мы могли бы охарактеризовать современную **криптографию** как науку, занимающуюся формальной разработкой и анализом криптографических схем для защиты цифровой информации от враждебных атак. [6] Здесь безопасность следует понимать в широком смысле как предотвращение атак, которые наносят ущерб секретности, целостности, аутентификации и/или неотказуемости в коммуникациях.
Криптография лучше всего рассматривается как поддисциплина **кибербезопасности**, которая занимается предотвращением кражи, повреждения и неправомерного использования компьютерных систем. Следует отметить, что многие вопросы кибербезопасности имеют мало или только частичное отношение к криптографии.
Например, если компания размещает дорогостоящие серверы локально, ее может беспокоить защита этого оборудования от кражи и повреждения. Хотя это и является вопросом кибербезопасности, оно мало связано с криптографией.

В качестве другого примера, **фишинговые атаки** являются общей проблемой в наше современное время. Эти атаки пытаются обмануть людей через электронное письмо или какой-либо другой мессенджер, чтобы заставить их раскрыть конфиденциальную информацию, такую как пароли или номера кредитных карт. Хотя криптография может помочь решить проблему фишинговых атак до определенной степени, комплексный подход требует большего, чем просто использование криптографии.

**Примечания:**

[3] Точнее, важные применения криптографических схем были связаны с секретностью. Дети, например, часто используют простые криптографические схемы для "веселья". В этих случаях секретность действительно не является проблемой.

[4] Брюс Шнайер, *Прикладная криптография*, 2-е изд., 2015 (Индианаполис, ИН: John Wiley & Sons), стр. 2.

[5] См. Джонатан Кац и Йехуда Линделл, *Введение в современную криптографию*, CRC Press (Бока-Ратон, Флорида: 2015), особенно стр. 16–23, для хорошего описания.

[6] Ср. Кац и Линделл, там же, стр. 3. Я думаю, что их характеристика имеет некоторые проблемы, поэтому представляю здесь немного другую версию их утверждения.

## Открытые коммуникации
<chapterId>cb23d0a6-ba9a-5dc6-a55a-258405ae4117</chapterId>

Современная криптография разработана для обеспечения гарантий безопасности в среде **открытых коммуникаций**. Если наш канал связи настолько хорошо защищен, что подслушивающие лица не имеют никакой возможности манипулировать или даже просто наблюдать за нашими сообщениями, тогда криптография становится излишней. Однако большинство наших каналов связи далеко не так хорошо защищены.

Основой коммуникации в современном мире является огромная сеть волоконно-оптических кабелей. Совершение телефонных звонков, просмотр телевидения и серфинг в интернете в современном домохозяйстве в основном зависят от этой сети волоконно-оптических кабелей (небольшой процент может полагаться исключительно на спутники). Действительно, у вас дома могут быть различные типы подключения к данным, такие как коаксиальный кабель, (асимметричная) цифровая абонентская линия и волоконно-оптический кабель. Но, по крайней мере, в развитом мире, эти различные средства передачи данных быстро соединяются за пределами вашего дома с узлом в огромной сети волоконно-оптических кабелей, которая соединяет весь глобус. Исключения составляют некоторые отдаленные районы развитого мира, такие как в Соединенных Штатах и Австралии, где трафик данных может также проходить на значительные расстояния по традиционным медным телефонным проводам.

Было бы невозможно предотвратить физический доступ потенциальных атакующих к этой сети кабелей и ее поддерживающей инфраструктуре. Фактически, мы уже знаем, что большая часть наших данных перехватывается различными национальными разведывательными агентствами на ключевых узлах Интернета.[7] Это включает в себя все, от сообщений в Facebook до адресов веб-сайтов, которые вы посещаете.

Хотя наблюдение за данными в масштабах требует мощного противника, такого как национальное разведывательное агентство, атакующие с ограниченными ресурсами могут легко попытаться подслушать на более локальном уровне. Хотя это может произойти на уровне подключения к проводам, гораздо проще просто перехватить беспроводную связь.
Большая часть данных наших локальных сетей — будь то в наших домах, в офисе или в кафе — теперь передается через радиоволны к точкам беспроводного доступа на универсальных роутерах, а не через физические кабели. Таким образом, для перехвата любого вашего локального трафика злоумышленнику требуется мало ресурсов. Это особенно тревожно, поскольку большинство людей очень мало делают для защиты данных, которые передаются через их локальные сети. Кроме того, потенциальные атакующие также могут нацеливаться на наши мобильные широкополосные соединения, такие как 3G, 4G и 5G. Все эти беспроводные коммуникации являются легкой целью для атакующих.
Поэтому идея сохранения секретности коммуникаций путем защиты канала связи является безнадежно иллюзорной мечтой для большей части современного мира. Все, что мы знаем, требует серьезного паранойи: вы всегда должны предполагать, что кто-то слушает. И криптография — это основной инструмент, который у нас есть для обеспечения какой-либо безопасности в этой современной среде.

**Примечания:**

[7] Смотрите, например, Ольга Хазан, “The creepy, long-standing practice of undersea cable tapping”, *The Atlantic*, 16 июля 2013 года (доступно на [The Atlantic](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/)).

# Математические основы криптографии 1
<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

## Случайные переменные
<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

Криптография опирается на математику. И если вы хотите построить более чем поверхностное понимание криптографии, вам нужно быть уверенным в этой математике.

Эта глава вводит большинство основных математических понятий, с которыми вы столкнетесь, изучая криптографию. Темы включают случайные переменные, операции по модулю, операции XOR и псевдослучайность. Вы должны освоить материал в этих разделах для любого не поверхностного понимания криптографии.

Следующий раздел посвящен теории чисел, которая гораздо более сложная.

### Случайные переменные

Случайная переменная обычно обозначается не жирным, прописным буквами. Так, например, мы можем говорить о случайной переменной $X$, случайной переменной $Y$ или случайной переменной $Z$. Это обозначение я также буду использовать отсюда и далее.

**Случайная переменная** может принимать два или более возможных значения, каждое с определенной положительной вероятностью. Возможные значения перечислены в **наборе исходов**.

Каждый раз, когда вы **выбираете** случайную переменную, вы извлекаете определенное значение из ее набора исходов в соответствии с определенными вероятностями.

Давайте рассмотрим простой пример. Предположим, переменная $X$ определена следующим образом:

- $X$ имеет набор исходов $\{1,2\}$

$$
Pr[X = 1] = 0.5
$$

$$
Pr[X = 2] = 0.5
$$

Легко видеть, что $X$ является случайной переменной. Во-первых, есть два или более возможных значения, которые $X$ может принять, а именно $1$ и $2$. Во-вторых, каждое возможное значение имеет положительную вероятность появления при выборке $X$, а именно $0.5$.
Всё, что требуется от случайной переменной, это набор возможных исходов с двумя или более вариантами, где каждый вариант имеет положительную вероятность появления при выборке. Таким образом, случайную переменную можно определить в абстрактной форме, без какого-либо контекста. В этом случае можно думать о "выборке" как о проведении некоторого естественного эксперимента для определения значения случайной переменной.

Переменная $X$ выше была определена в абстрактной форме. Таким образом, можно думать о выборке переменной $X$ как о подбрасывании честной монеты и присвоении "2" в случае выпадения орла и "1" в случае выпадения решки. При каждой выборке $X$ монета подбрасывается снова.

Альтернативно, можно также думать о выборке $X$, как о бросании честной кости и присвоении "2" в случае, если кость показывает $1$, $3$ или $4$, и присвоении "1" в случае, если кость показывает $2$, $5$ или $6$. Каждый раз, когда вы выбираете $X$, кость бросается снова.

На самом деле, любой естественный эксперимент, который позволил бы вам определить вероятности возможных значений $X$, можно представить в отношении к рисунку.

Однако часто случайные переменные не вводятся только в абстрактной форме. Вместо этого набор возможных значений исходов имеет явное значение в реальном мире (а не просто как числа). Кроме того, эти исходы и их связанные вероятности могут быть определены на основе какого-то конкретного типа эксперимента (а не как любой естественный эксперимент с этими значениями).

Рассмотрим теперь пример переменной $X$, которая не определена абстрактно. X определена следующим образом, чтобы определить, какая из двух команд начинает футбольный матч:

- $X$ имеет набор исходов {красные начинают, синие начинают}
- Подбрасывается конкретная монета $C$: решка = "красные начинают"; орел = "синие начинают"

$$
Pr [X = \text{красные начинают}] = 0.5
$$

$$
Pr [X = \text{синие начинают}] = 0.5
$$

В этом случае набор исходов X предоставлен с конкретным значением, а именно, какая команда начинает в футбольном матче. Кроме того, возможные исходы и их связанные вероятности определены конкретным экспериментом, а именно подбрасыванием конкретной монеты $C$.

В обсуждениях криптографии случайные переменные обычно вводятся на основе набора исходов с реальным значением. Это может быть набор всех сообщений, которые могут быть зашифрованы, известный как пространство сообщений, или набор всех ключей, которые стороны, использующие шифрование, могут выбрать, известный как пространство ключей.

Однако в обсуждениях криптографии случайные переменные обычно не определяются на основе какого-то конкретного естественного эксперимента, а на основе любого эксперимента, который может дать правильные распределения вероятностей.

Случайные переменные могут иметь дискретные или непрерывные распределения вероятностей. Случайные переменные с **дискретным распределением вероятностей** — то есть дискретные случайные переменные — имеют конечное количество возможных исходов. Случайная переменная $X$ в обоих приведенных до сих пор примерах была дискретной.

**Непрерывные случайные переменные** вместо этого могут принимать значения в одном или нескольких интервалах. Можно сказать, например, что случайная переменная при выборке примет любое действительное значение между 0 и 1, и что каждое действительное число в этом интервале равновероятно. В этом интервале существует бесконечное количество возможных значений.

Для обсуждений криптографии вам нужно будет понимать только дискретные случайные переменные. Любое обсуждение случайных переменных отсюда и далее следует понимать как относящееся к дискретным случайным переменным, если не указано иное.

### Графическое представление случайных переменных
Возможные значения и связанные с ними вероятности для случайной переменной могут быть легко визуализированы с помощью графика. Например, рассмотрим случайную переменную $X$ из предыдущего раздела с набором исходов $\{1, 2\}$, и $Pr [X = 1] = 0.5$ и $Pr [X = 2] = 0.5$. Обычно такую случайную переменную мы отображаем в виде столбчатой диаграммы, как на *Рисунке 1*.
*Рисунок 1: Случайная переменная X*

![Рисунок 1: Случайная переменная X.](assets/Figure2-1.webp)

Широкие столбцы на *Рисунке 1* очевидно не предполагают, что случайная переменная $X$ является непрерывной. Вместо этого столбцы сделаны широкими для большей визуальной привлекательности (просто линия вверх обеспечивает менее интуитивно понятную визуализацию).

### Равномерные переменные

В выражении "случайная переменная" термин "случайная" просто означает "вероятностная". Другими словами, это просто означает, что два или более возможных исхода переменной происходят с определенными вероятностями. Однако эти исходы *не обязательно* должны быть равновероятными (хотя термин "случайная" действительно может иметь такое значение в других контекстах).

**Равномерная переменная** является специальным случаем случайной переменной. Она может принимать два или более значений, все с равной вероятностью. Случайная переменная $X$, изображенная на *Рисунке 1*, явно является равномерной переменной, так как оба возможных исхода происходят с вероятностью $0.5$. Однако существует много случайных переменных, которые не являются примерами равномерных переменных.

Рассмотрим, например, случайную переменную $Y$. Она имеет набор исходов $\{1, 2, 3, 8, 10\}$ и следующее распределение вероятностей:

$$
\Pr[Y = 1] = 0.25
$$

$$
\Pr[Y = 2] = 0.35
$$

$$
\Pr[Y = 3] = 0.1
$$

$$
\Pr[Y = 8] = 0.25
$$

$$
\Pr[Y = 10] = 0.05
$$

Хотя два возможных исхода действительно имеют равную вероятность происхождения, а именно $1$ и $8$, $Y$ также может принимать определенные значения с другими вероятностями, отличными от $0.25$ при выборке. Следовательно, хотя $Y$ действительно является случайной переменной, она не является равномерной переменной.

Графическое изображение $Y$ представлено на *Рисунке 2*.

*Рисунок 2: Случайная переменная Y*

![Рисунок 2: Случайная переменная Y.](assets/Figure2-2.webp "Рисунок 2: Случайная переменная Y")

В качестве последнего примера рассмотрим случайную переменную Z. Она имеет набор исходов {1,3,7,11,12} и следующее распределение вероятностей:

$$
\Pr[Z = 2] = 0.2
$$

$$
\Pr[Z = 3] = 0.2
$$

$$
\Pr[Z = 9] = 0.2
$$

$$
\Pr[Z = 11] = 0.2
$$

$$
\Pr[Z = 12] = 0.2
$$

Вы можете увидеть ее изображение на *Рисунке 3*. В отличие от Y, случайная переменная Z является равномерной переменной, так как все вероятности для возможных значений при выборке равны.

*Рисунок 3: Случайная переменная Z*
![Рисунок 3: Случайная переменная Z.](assets/Figure2-3.webp "Рисунок 3: Случайная переменная Z")

### Условная вероятность

Предположим, что Боб намерен равномерно выбрать день из последнего календарного года. Какова вероятность того, что выбранный день придется на лето?

До тех пор, пока мы считаем, что процесс выбора Боба действительно будет равномерным, мы должны прийти к выводу, что вероятность выбора Бобом дня летом составляет 1/4. Это **безусловная вероятность** того, что случайно выбранный день придется на лето.

Предположим теперь, что вместо равномерного выбора календарного дня, Боб выбирает равномерно только среди тех дней, когда температура в полдень у озера Кристал (Нью-Джерси) была 21 градус Цельсия или выше. Исходя из этой дополнительной информации, к какому выводу мы можем прийти о вероятности того, что Боб выберет день летом?

Мы действительно должны прийти к другому выводу, чем раньше, даже без какой-либо дополнительной конкретной информации (например, температуры в полдень каждый день последнего календарного года).

Зная, что озеро Кристал находится в Нью-Джерси, мы определенно не ожидаем, что температура в полдень будет 21 градус Цельсия или выше зимой. Вместо этого гораздо вероятнее, что это будет теплый день весной или осенью, или день где-то летом. Следовательно, зная, что температура в полдень у озера Кристал в выбранный день была 21 градус Цельсия или выше, вероятность того, что день, выбранный Бобом, придется на лето, значительно выше. Это **условная вероятность** того, что случайно выбранный день придется на лето, учитывая, что температура в полдень у озера Кристал была 21 градус Цельсия или выше.

В отличие от предыдущего примера, вероятности двух событий также могут быть полностью независимыми. В этом случае мы говорим, что они **независимы**.

Предположим, например, что определенная честная монета упала орлом вверх. Исходя из этого факта, какова тогда вероятность того, что завтра пойдет дождь? Условная вероятность в этом случае должна быть такой же, как и безусловная вероятность того, что завтра пойдет дождь, поскольку подбрасывание монеты обычно не оказывает никакого влияния на погоду.

Мы используем символ "|" для записи выражений условной вероятности. Например, вероятность события $A$ при условии, что событие $B$ произошло, можно записать следующим образом:

$$
Pr[A|B]
$$

Таким образом, когда два события, $A$ и $B$, независимы, тогда:

$$
Pr[A|B] = Pr[A] \text{ и } Pr[B|A] = Pr[B]
$$

Условие независимости можно упростить следующим образом:

$$
Pr[A, B] = Pr[A] \cdot Pr[B]
$$

Одним из ключевых результатов в теории вероятностей является известная **Теорема Байеса**. Она в основном утверждает, что $Pr[A|B]$ можно переписать следующим образом:

$$
Pr[A|B] = \frac{Pr[B|A] \cdot Pr[A]}{Pr[B]}
$$

Вместо использования условных вероятностей с конкретными событиями, мы также можем рассматривать условные вероятности, связанные с двумя или более случайными переменными в наборе возможных событий. Предположим, есть две случайные переменные, $X$ и $Y$. Любое возможное значение для $X$ мы можем обозначить как $x$, и любое возможное значение для $Y$ как $y$. Мы могли бы сказать, тогда, что две случайные переменные независимы, если выполняется следующее утверждение:

$$
Pr[X = x, Y = y] = Pr[X = x] \cdot Pr[Y = y]
$$

для всех $x$ и $y$.

Давайте будем немного более ясными относительно того, что это утверждение означает.
Предположим, что множества исходов для $X$ и $Y$ определены следующим образом: **X** = $\{x_1, x_2, \ldots, x_i, \ldots, x_n\}$ и **Y** = $\{y_1, y_2, \ldots, y_i, \ldots, y_m\}$. (Типично обозначать множества значений жирным шрифтом в верхнем регистре.)
Теперь предположим, вы выбираете $Y$ и наблюдаете $y_1$. Приведенное выше утверждение говорит нам, что вероятность теперь получить $x_1$ из выборки $X$ точно такая же, как если бы мы никогда не наблюдали $y_1$. Это верно для любого $y_i$, который мы могли бы извлечь из нашей первоначальной выборки $Y$. Наконец, это справедливо не только для $x_1$. Для любого $x_i$ вероятность появления не зависит от результата выборки $Y$. Все это также относится к случаю, когда сначала выбирается $X$.

Давайте закончим наш разговор на немного более философской ноте. В любой реальной ситуации вероятность какого-либо события всегда оценивается против определенного набора информации. В очень строгом смысле слова не существует "безусловной вероятности".

Например, предположим, я спросил вас о вероятности того, что свиньи полетят к 2030 году. Хотя я не даю вам дополнительной информации, вы явно знаете много о мире, что может повлиять на ваше суждение. Вы никогда не видели летающих свиней. Вы знаете, что большинство людей не ожидают, что они полетят. Вы знаете, что они не совсем созданы для полета. И так далее.

Следовательно, когда мы говорим о "безусловной вероятности" какого-либо события в реальном контексте, этот термин действительно может иметь смысл только если мы понимаем его как "вероятность без какой-либо дополнительной явной информации". Любое понимание "условной вероятности" должно, следовательно, всегда рассматриваться против какого-то конкретного куска информации.

Я мог бы, например, спросить вас о вероятности того, что свиньи полетят к 2030 году, после того как дал вам доказательства того, что некоторые козы в Новой Зеландии научились летать после нескольких лет тренировок. В этом случае вы, вероятно, скорректируете свое суждение о вероятности того, что свиньи полетят к 2030 году. Таким образом, вероятность того, что свиньи полетят к 2030 году, зависит от этого доказательства о козах в Новой Зеландии.

## Операция по модулю
<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

### Модуль

Самое основное выражение с **операцией по модулю** имеет следующий вид: $x \mod y$.

Переменная $x$ называется делимым, а переменная $y$ - делителем. Чтобы выполнить операцию по модулю с положительным делимым и положительным делителем, вы просто определяете остаток от деления.

Например, рассмотрим выражение $25 \mod 4$. Число 4 укладывается в число 25 в общей сложности 6 раз. Остаток от этого деления равен 1. Следовательно, $25 \mod 4$ равно 1. Аналогичным образом, мы можем оценить выражения ниже:

* $29 \mod 30 = 29$ (поскольку 30 укладывается в 29 в общей сложности 0 раз, и остаток равен 29)
* $42 \mod 2 = 0$ (поскольку 2 укладывается в 42 в общей сложности 21 раз, и остаток равен 0)
* $12 \mod 5 = 2$ (поскольку 5 умещается в 12 два раза, и остаток равен 2)
* $20 \mod 8 = 4$ (поскольку 8 умещается в 20 два раза, и остаток равен 4)

Когда делимое или делитель отрицательны, операции с модулем могут обрабатываться различными языками программирования по-разному.

Вы определенно столкнетесь с случаями с отрицательным делимым в криптографии. В этих случаях типичный подход следующий:

* Сначала определите ближайшее значение *меньшее или равное* делимому, на которое делитель делит без остатка. Назовем это значение $p$.
* Если делимое равно $x$, то результат операции по модулю равен значению $x – p$.

Например, предположим, что делимое равно $–20$, а делитель 3. Ближайшее значение, меньшее или равное $–20$, на которое 3 делит без остатка, равно $–21$. Значение $x – p$ в этом случае равно $–20 – (–21)$. Это равно 1, и, следовательно, $–20 \mod 3$ равно 1. Аналогичным образом мы можем оценить следующие выражения:

* $–8 \mod 5 = 2$
* $–19 \mod 16 = 13$
* $–14 \mod 6 = 4$

Что касается обозначений, вы обычно увидите следующие типы выражений: $x = [y \mod z]$. Из-за скобок операция по модулю в этом случае применяется только к правой части выражения. Если, например, $y$ равно 25, а $z$ равно 4, то $x$ оценивается как 1.

Без скобок операция по модулю действует на *обе стороны* выражения. Предположим, например, следующее выражение: $x = y \mod z$. Если $y$ равно 25, а $z$ равно 4, то все, что мы знаем, это то, что $x \mod 4$ оценивается как 1. Это согласуется с любым значением для $x$ из набора $\{\ldots,–7, –3, 1, 5, 9,\ldots\}$.

Раздел математики, который включает операции по модулю над числами и выражениями, называется **модульной арифметикой**. Можно думать об этом разделе как об арифметике для случаев, когда числовая линия не бесконечно длинная. Хотя мы обычно сталкиваемся с операциями по модулю для (положительных) целых чисел в криптографии, вы также можете выполнять операции по модулю с любыми действительными числами.

### Шифр сдвига

Операция по модулю часто встречается в криптографии. Чтобы проиллюстрировать это, давайте рассмотрим одну из самых известных исторических схем шифрования: шифр сдвига.

Давайте сначала определим его. Предположим словарь *D*, который соотносит все буквы английского алфавита, по порядку, с набором чисел $\{0, 1, 2, \ldots, 25\}$. Предположим пространство сообщений **M**. Тогда **шифр сдвига** — это схема шифрования, определенная следующим образом:

- Выберите равномерно ключ $k$ из пространства ключей **K**, где **K** = $\{0, 1, 2, \ldots, 25\}$ [1]
- Зашифруйте сообщение $m \in \mathbf{M}$ следующим образом:
    - Разделите $m$ на его отдельные буквы $m_0, m_1, \ldots, m_i, \ldots, m_l$
- Конвертируйте каждый $m_i$ в число согласно *D*
    - Для каждого $m_i$, $c_i = [(m_i + k) \mod 26]$
    - Конвертируйте каждый $c_i$ обратно в букву согласно *D*
    - Затем объедините $c_0, c_1, \ldots, c_l$, чтобы получить шифртекст $c$
- Расшифровка шифртекста $c$ выполняется следующим образом:
    - Конвертируйте каждый $c_i$ в число согласно *D*
    - Для каждого $c_i$, $m_i = [(c_i – k) \mod 26]$
    - Конвертируйте каждый $m_i$ обратно в букву согласно *D*
    - Затем объедините $m_0, m_1, \ldots, m_l$, чтобы получить исходное сообщение $m$

Оператор модуля в шифре сдвига гарантирует, что буквы циклически переходят, так что все буквы шифртекста определены. Для иллюстрации рассмотрим применение шифра сдвига к слову "DOG".

Предположим, что вы выбрали ключ со значением 17. Буква "O" соответствует числу 15. Без операции модуля сложение этого числа открытого текста с ключом дало бы число шифртекста 32. Однако это число шифртекста не может быть преобразовано в букву шифртекста, так как в английском алфавите только 26 букв. Операция модуля гарантирует, что число шифртекста на самом деле 6 (результат $32 \mod 26$), что соответствует букве шифртекста "G".

Полное шифрование слова "DOG" с ключом 17 выглядит следующим образом:

* Сообщение = DOG = D,O,G = 3,15,6
* $c_0 = [(3 + 17) \mod 26] = [(20) \mod 26] = 20 = U$
* $c_1 = [(15 + 17) \mod 26] = [(32) \mod 26] = 6 = G$
* $c_2 = [(6 + 17) \mod 26] = [(23) \mod 26] = 23 = X$
* $c = UGX$

Каждый может интуитивно понять, как работает шифр сдвига, и, вероятно, использовать его самостоятельно. Однако для углубления ваших знаний в криптографии важно начать чувствовать себя более уверенно с формализацией, так как схемы станут гораздо сложнее. Вот почему шаги для шифра сдвига были формализованы.

**Примечания:**

[1] Мы можем точно определить это утверждение, используя терминологию из предыдущего раздела. Пусть равномерная переменная $K$ имеет $K$ как набор возможных исходов. Так:

$$
Pr[K = 0] = \frac{1}{26}
$$

$$
Pr[K = 1] = \frac{1}{26}
$$

...и так далее. Выберите равномерную переменную $K$ один раз, чтобы получить конкретный ключ.

## Операция XOR
<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

Все компьютерные данные обрабатываются, хранятся и передаются по сетям на уровне битов. Любые криптографические схемы, применяемые к компьютерным данным, также работают на уровне битов.

Например, предположим, что вы набрали электронное письмо в своем почтовом приложении. Любое шифрование, которое вы применяете, не происходит непосредственно над символами ASCII вашего электронного письма. Вместо этого оно применяется к битовому представлению букв и других символов в вашем электронном письме.
Одна из ключевых математических операций, которую необходимо понимать для современной криптографии, помимо операции по модулю, это операция **XOR**, или операция "исключающее или". Эта операция принимает на вход два бита и выдает на выходе другой бит. Операция XOR будет обозначаться как "XOR". Она дает 0, если два бита одинаковы, и 1, если два бита различны. Ниже вы можете увидеть четыре возможности. Символ $\oplus$ представляет "XOR":
* $0 \oplus 0 = 0$
* $0 \oplus 1 = 1$
* $1 \oplus 0 = 1$
* $1 \oplus 1 = 0$

Для иллюстрации предположим, что у вас есть сообщение $m_1$ (01111001) и сообщение $m_2$ (01011001). Операция XOR этих двух сообщений может быть представлена ниже.

* $m_1 \oplus m_2 = 01111001 \oplus 01011001 = 00100000$

Процесс прост. Сначала вы выполняете операцию XOR для крайних левых битов $m_1$ и $m_2$. В данном случае это $0 \oplus 0 = 0$. Затем вы выполняете XOR для второй пары битов слева. В данном случае это $1 \oplus 1 = 0$. Вы продолжаете этот процесс, пока не выполните операцию XOR для крайних правых битов.

Легко видеть, что операция XOR коммутативна, то есть $m_1 \oplus m_2 = m_2 \oplus m_1$. Кроме того, операция XOR также ассоциативна. То есть, $(m_1 \oplus m_2) \oplus m_3 = m_1 \oplus (m_2 \oplus m_3)$.

Операция XOR над двумя строками разной длины может иметь разные интерпретации в зависимости от контекста. Здесь мы не будем заниматься операциями XOR над строками разной длины.

Операция XOR эквивалентна специальному случаю выполнения операции по модулю над сложением битов, когда делитель равен 2. Вы можете увидеть эквивалентность в следующих результатах:

* $(0 + 0) \mod 2 = 0 \oplus 0 = 0$
* $(1 + 0) \mod 2 = 1 \oplus 0 = 1$
* $(0 + 1) \mod 2 = 0 \oplus 1 = 1$
* $(1 + 1) \mod 2 = 1 \oplus 1 = 0$

## Псевдослучайность

В нашем обсуждении случайных и равномерных переменных мы провели конкретное различие между "случайным" и "равномерным". Обычно это различие сохраняется на практике при описании случайных переменных. Однако, в нашем текущем контексте, это различие нужно отбросить, и "случайный" и "равномерный" используются как синонимы. Я объясню почему в конце раздела.

Для начала, мы можем назвать двоичную строку длиной $n$ **случайной** (или **равномерной**), если она была результатом выборки равномерной переменной $S$, которая дает каждой двоичной строке такой длины $n$ равную вероятность выбора.
Предположим, например, множество всех двоичных строк длиной 8: $\{0000\ 0000, 0000\ 0001, \ldots, 1111\ 1111\}$. (Типично записывать 8-битную строку в два квартета, каждый из которых называется **nibble**.) Давайте назовем это множество строк **$S_8$**.
Согласно приведенному выше определению, мы можем, следовательно, назвать конкретную двоичную строку длиной 8 случайной (или равномерной), если она была результатом выборки равномерной переменной $S$, которая дает каждой строке в **$S_8$** равную вероятность выбора. Учитывая, что множество **$S_8$** включает $2^8$ элементов, вероятность выбора при выборке должна быть $1/2^8$ для каждой строки в множестве.

Ключевым аспектом случайности двоичной строки является то, что она определяется с ссылкой на процесс, посредством которого она была выбрана. Форма любой конкретной двоичной строки сама по себе, следовательно, ничего не говорит о ее случайности в выборе.

Например, многие люди интуитивно думают, что строка вроде $1111\ 1111$ не могла быть выбрана случайно. Но это явно не так.

Определяя равномерную переменную $S$ по всем двоичным строкам длиной 8, вероятность выбора $1111\ 1111$ из множества **$S_8$** такая же, как и для строки вроде $0111\ 0100$. Таким образом, вы не можете сказать ничего о случайности строки, просто анализируя саму строку.

Мы также можем говорить о случайных строках, не имея в виду специфически двоичные строки. Мы могли бы, например, говорить о случайной шестнадцатеричной строке $AF\ 02\ 82$. В этом случае строка была бы выбрана случайно из множества всех шестнадцатеричных строк длиной 6. Это эквивалентно случайному выбору двоичной строки длиной 24, так как каждая шестнадцатеричная цифра представляет 4 бита.

Типично выражение “случайная строка”, без уточнения, относится к строке, случайно выбранной из множества всех строк одинаковой длины. Вот как я это описал выше. Строка длиной $n$ может, конечно, также быть случайно выбрана из другого множества. Одно, например, которое состоит только из подмножества всех строк длиной $n$, или, возможно, множество, которое включает строки различной длины. В этих случаях, однако, мы не называем ее “случайной строкой”, а скорее “строкой, которая случайно выбрана из некоторого множества **S**”.

Ключевым понятием в криптографии является псевдослучайность. **Псевдослучайная строка** длиной $n$ кажется *как будто* она была результатом выборки равномерной переменной $S$, которая дает каждой строке в **$S_n$** равную вероятность выбора. На самом деле, однако, строка является результатом выборки равномерной переменной $S'$, которая определяет только распределение вероятностей — не обязательно с равными вероятностями для всех возможных исходов — на подмножестве **$S_n$**. Критически важный момент здесь в том, что никто на самом деле не может отличить выборки из $S$ от $S'$, даже если взять их много.
Предположим, например, случайную величину $S$. Ее множество исходов — **$S_{256}$**, это множество всех двоичных строк длиной 256. Это множество содержит $2^{256}$ элементов. Каждый элемент имеет равную вероятность выбора, $1/2^{256}$, при выборке.

Кроме того, предположим случайную величину $S'$. Ее множество исходов включает только $2^{128}$ двоичных строк длиной 256. Над этими строками имеется некоторое распределение вероятностей, но это распределение не обязательно равномерное.

Предположим, что я теперь взял 1000ы выборок из $S$ и 1000ы выборок из $S'$ и дал вам два набора исходов. Я скажу вам, какой набор исходов связан с какой случайной величиной. Затем я беру выборку из одной из двух случайных величин. Но на этот раз я не скажу вам, из какой случайной величины я взял выборку. Если $S'$ была псевдослучайной, то идея состоит в том, что ваша вероятность сделать правильное предположение о том, из какой случайной величины я взял выборку, практически не лучше, чем $1/2$.

Обычно псевдослучайная строка длиной $n$ производится путем случайного выбора строки размером $n – x$, где $x$ — положительное целое число, и использования ее в качестве входа для алгоритма расширения. Эта случайная строка размером $n – x$ известна как **семя**.

Псевдослучайные строки являются ключевым понятием для практического применения криптографии. Рассмотрим, например, потоковые шифры. В потоковом шифре случайно выбранный ключ подается на вход алгоритма расширения для производства гораздо более длинной псевдослучайной строки. Эта псевдослучайная строка затем сочетается с открытым текстом с помощью операции XOR для производства шифртекста.

Если бы мы не могли производить этот тип псевдослучайной строки для потокового шифра, тогда нам бы потребовался ключ, длина которого равна длине сообщения для его безопасности. Это не очень практичный вариант в большинстве случаев.

Понятие псевдослучайности, обсуждаемое в этом разделе, может быть определено более формально. Оно также распространяется на другие контексты. Но нам не нужно углубляться в это обсуждение здесь. Все, что вам действительно нужно интуитивно понять для многих аспектов криптографии, это разница между случайной и псевдослучайной строкой. [2]

Теперь также должно быть ясно, почему мы отказываемся от различия между "случайным" и "равномерным" в нашем обсуждении. На практике все используют термин псевдослучайный, чтобы указать на строку, которая выглядит **как будто** она была результатом выборки из равномерной переменной $S$. Строго говоря, мы должны называть такую строку "псевдо-равномерной", используя наш язык из предыдущего. Поскольку термин "псевдо-равномерный" неудобен и никем не используется, мы не будем вводить его здесь для ясности. Вместо этого мы просто отказываемся от различия между "случайным" и "равномерным" в текущем контексте.


**Примечания**

[2] Если вас интересует более формальное изложение этих вопросов, вы можете обратиться к книге Каца и Линделла *Введение в современную криптографию*, особенно глава 3.


# Математические основы криптографии 2
<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>




## Что такое теория чисел?
<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>
Эта глава посвящена более продвинутой теме математических основ криптографии: теории чисел. Хотя теория чисел важна для симметричной криптографии (как, например, в шифре Рейндала), она особенно важна в контексте криптографии с открытым ключом.

Если вы находите детали теории чисел обременительными, я бы рекомендовал для начала ознакомиться с ними на высоком уровне. Вы всегда можете вернуться к этому позже.

___

Вы можете охарактеризовать **теорию чисел** как изучение свойств целых чисел и математических функций, работающих с целыми числами.

Рассмотрим, например, что любые два числа $a$ и $N$ являются **взаимно простыми** (или **относительно простыми**), если их наибольший общий делитель равен 1. Предположим теперь, что есть определенное целое число $N$. Сколько целых чисел, меньших $N$, являются взаимно простыми с $N$? Можем ли мы сделать общие утверждения относительно ответов на этот вопрос? Это типичные виды вопросов, на которые стремится ответить теория чисел.

Современная теория чисел опирается на инструменты абстрактной алгебры. Область **абстрактной алгебры** является поддисциплиной математики, где основными объектами анализа являются абстрактные объекты, известные как алгебраические структуры. **Алгебраическая структура** - это набор элементов в сочетании с одной или несколькими операциями, которые удовлетворяют определенным аксиомам. Через алгебраические структуры математики могут получить представление о конкретных математических проблемах, абстрагируясь от их деталей.

Область абстрактной алгебры иногда также называют современной алгеброй. Вы также можете столкнуться с понятием **абстрактной математики** (или **чистой математики**). Этот последний термин не относится к абстрактной алгебре, а скорее означает изучение математики ради самой математики, и не только с учетом потенциальных приложений.

Множества из абстрактной алгебры могут иметь дело с множеством типов объектов, от преобразований, сохраняющих форму на равностороннем треугольнике, до узоров обоев. Для теории чисел мы рассматриваем только множества элементов, содержащих целые числа или функции, работающие с целыми числами.

## Группы
<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

Основное понятие в математике - это понятие множества элементов. Множество обычно обозначается фигурными скобками с элементами, разделенными запятыми.

Например, множество всех целых чисел обозначается как $\{…, -2, -1, 0, 1, 2, …\}$. Многоточия здесь означают, что определенный шаблон продолжается в определенном направлении. Таким образом, множество всех целых чисел также включает $3, 4, 5, 6$ и так далее, а также $-3, -4, -5, -6$ и так далее. Это множество всех целых чисел обычно обозначается $\mathbb{Z}$.

Другой пример множества - это $\mathbb{Z} \mod 11$, или множество всех целых чисел по модулю 11. В отличие от всего множества $\mathbb{Z}$, это множество содержит только конечное количество элементов, а именно $\{0, 1, \ldots, 9, 10\}$.
Распространенная ошибка заключается в том, что многие думают, что множество $\mathbb{Z} \mod 11$ на самом деле является $\{-10, -9, \ldots, 0, \ldots, 9, 10\}$. Но это не так, учитывая способ, которым мы определили операцию по модулю ранее. Любые отрицательные целые числа, уменьшенные по модулю 11, переходят в $\{0, 1, \ldots, 9, 10\}$. Например, выражение $-2 \mod 11$ переходит в $9$, в то время как выражение $-27 \mod 11$ переходит в $5$.

Еще одно базовое понятие в математике - это бинарная операция. Это любая операция, которая принимает два элемента для производства третьего. Например, из базовой арифметики и алгебры вы были бы знакомы с четырьмя основными бинарными операциями: сложение, вычитание, умножение и деление.

Эти два базовых математических понятия, множества и бинарные операции, используются для определения понятия группы, наиболее существенной структуры в абстрактной алгебре.

В частности, предположим некоторую бинарную операцию $\circ$. Кроме того, предположим некоторое множество элементов **S**, оснащенное этой операцией. Все, что здесь означает "оснащенное", это то, что операция $\circ$ может быть выполнена между любыми двумя элементами множества **S**.

Тогда комбинация $\langle \mathbf{S}, \circ \rangle$ является **группой**, если она удовлетворяет четырем конкретным условиям, известным как аксиомы группы.

1. Для любых $a$ и $b$, которые являются элементами $\mathbf{S}$, $a \circ b$ также является элементом $\mathbf{S}$. Это известно как **условие замкнутости**.
2. Для любых $a$, $b$ и $c$, которые являются элементами $\mathbf{S}$, выполняется, что $(a \circ b) \circ c = a \circ (b \circ c)$. Это известно как **условие ассоциативности**.
3. В $\mathbf{S}$ существует уникальный элемент $e$, такой что для каждого элемента $a$ в $\mathbf{S}$ выполняется следующее уравнение: $e \circ a = a \circ e = a$. Поскольку такой элемент $e$ единственный, он называется **нейтральным элементом**. Это условие известно как **условие наличия нейтрального элемента**.
4. Для каждого элемента $a$ в $\mathbf{S}$ существует элемент $b$ в $\mathbf{S}$, такой что выполняется следующее уравнение: $a \circ b = b \circ a = e$, где $e$ является нейтральным элементом. Элемент $b$ здесь известен как **обратный элемент**, и он обычно обозначается как $a^{-1}$. Это условие известно как **условие обратимости**.

Давайте немного подробнее рассмотрим группы. Обозначим множество всех целых чисел через $\mathbb{Z}$. Это множество в сочетании со стандартным сложением, или $\langle \mathbb{Z}, + \rangle$, явно соответствует определению группы, так как оно удовлетворяет четырем вышеупомянутым аксиомам.

1. Для любых $x$ и $y$, которые являются элементами $\mathbb{Z}$, $x + y$ также является элементом $\mathbb{Z}$. Таким образом, $\langle \mathbb{Z}, + \rangle$ удовлетворяет условию замкнутости.
2. Для любых $x$, $y$ и $z$, являющихся элементами $\mathbb{Z}$, выполняется $(x + y) + z = x + (y + z)$. Таким образом, $\langle \mathbb{Z}, + \rangle$ удовлетворяет условию ассоциативности.

3. В $\langle \mathbb{Z}, + \rangle$ существует нейтральный элемент, а именно 0. Для любого $x$ из $\mathbb{Z}$ верно, что: $0 + x = x + 0 = x$. Таким образом, $\langle \mathbb{Z}, + \rangle$ удовлетворяет условию наличия нейтрального элемента.

4. Наконец, для каждого элемента $x$ в $\mathbb{Z}$ существует $y$ такое, что $x + y = y + x = 0$. Например, если $x$ равно 10, то $y$ будет равно $-10$ (в случае, если $x$ равно 0, $y$ также равно 0). Таким образом, $\langle \mathbb{Z}, + \rangle$ удовлетворяет условию наличия обратного элемента.

Важно, что то, что множество целых чисел с операцией сложения образует группу, не означает, что оно образует группу с операцией умножения. Вы можете проверить это, протестировав $\langle \mathbb{Z}, \cdot \rangle$ на соответствие четырем аксиомам группы (где $\cdot$ означает стандартное умножение).

Первые две аксиомы очевидно выполняются. Кроме того, при умножении элемент 1 может служить нейтральным элементом. Любое целое число $x$, умноженное на 1, дает в результате $x$. Однако, $\langle \mathbb{Z}, \cdot \rangle$ не удовлетворяет условию наличия обратного элемента. То есть, не существует уникального элемента $y$ в $\mathbb{Z}$ для каждого $x$ в $\mathbb{Z}$ так, чтобы $x \cdot y = 1$.

Например, предположим, что $x = 22$. Какое значение $y$ из множества $\mathbb{Z}$, умноженное на $x$, даст нейтральный элемент 1? Значение $1/22$ подойдет, но оно не входит в множество $\mathbb{Z}$. Фактически, вы столкнетесь с этой проблемой для любого целого числа $x$, кроме значений 1 и -1 (где $y$ должно быть 1 и -1 соответственно).

Если бы мы разрешили использовать в нашем множестве действительные числа, то наши проблемы в значительной степени исчезли бы. Для любого элемента $x$ в множестве, умножение на $1/x$ дает 1. Поскольку дроби включены в множество действительных чисел, обратный элемент может быть найден для каждого действительного числа. Исключение составляет ноль, так как любое умножение на ноль никогда не даст нейтральный элемент 1. Следовательно, множество ненулевых действительных чисел, оснащенное умножением, действительно является группой.

Некоторые группы удовлетворяют пятому общему условию, известному как **условие коммутативности**. Это условие следующее:

* Предположим, группа $G$ с множеством **S** и бинарной операцией $\circ$. Предположим, что $a$ и $b$ являются элементами **S**. Если выполняется, что $a \circ b = b \circ a$ для любых двух элементов $a$ и $b$ в **S**, тогда $G$ удовлетворяет условию коммутативности.
Любая группа, которая удовлетворяет условию коммутативности, известна как **коммутативная группа** или **абелева группа** (в честь Нильса Хенрика Абеля). Легко проверить, что как множество действительных чисел по сложению, так и множество целых чисел по сложению являются абелевыми группами. Множество целых чисел по умножению вообще не является группой, и, следовательно, не может быть абелевой группой. В отличие от этого, множество ненулевых действительных чисел по умножению также является абелевой группой.

Следует учитывать два важных соглашения о нотации. Во-первых, знаки “+” или “×” часто используются для обозначения операций группы, даже когда элементы на самом деле не являются числами. В этих случаях не следует интерпретировать эти знаки как стандартное арифметическое сложение или умножение. Вместо этого они являются операциями, имеющими лишь абстрактное сходство с этими арифметическими операциями.

Если вы не ссылаетесь конкретно на арифметическое сложение или умножение, проще использовать символы, такие как $\circ$ и $\diamond$, для операций группы, поскольку они не имеют глубоко укоренившихся культурных коннотаций.

Во-вторых, по той же причине, по которой “+” и “×” часто используются для обозначения неарифметических операций, нейтральные элементы групп часто символизируются “0” и “1”, даже когда элементы в этих группах не являются числами. Если вы не ссылаетесь на нейтральный элемент группы с числами, проще использовать более нейтральный символ, такой как “$e$”, для обозначения нейтрального элемента.

Многие различные и очень важные наборы значений в математике, оснащенные определенными бинарными операциями, являются группами. Однако криптографические приложения работают только с наборами целых чисел или, по крайней мере, с элементами, которые описываются целыми числами, то есть в пределах теории чисел. Следовательно, наборы с действительными числами, отличными от целых, не используются в криптографических приложениях.

Давайте закончим, приведя пример элементов, которые могут быть “описаны целыми числами”, хотя они и не являются целыми числами. Хорошим примером являются точки эллиптических кривых. Хотя любая точка на эллиптической кривой явно не является целым числом, такая точка действительно описывается двумя целыми числами.

Эллиптические кривые, например, критически важны для Bitcoin. Любая стандартная частная и публичная пара ключей Bitcoin выбирается из набора точек, который определяется следующей эллиптической кривой:

$$
x^3 + 7 = y^2 \mod 2^{256} – 2^{32} – 29 – 28 – 27 – 26 - 24 - 1
$$

(наибольшее простое число меньше $2^{256}$). Координата $x$ является частным ключом, а координата $y$ — вашим публичным ключом.

Транзакции в Bitcoin обычно включают блокировку выходов на один или несколько публичных ключей каким-либо образом. Значение из этих транзакций может быть разблокировано с помощью создания цифровых подписей соответствующими частными ключами.

## Циклические группы
<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

Одно из главных различий, которое мы можем провести, это между **конечной** и **бесконечной группой**. Первая имеет конечное количество элементов, в то время как вторая имеет бесконечное количество элементов. Количество элементов в любой конечной группе известно как **порядок группы**. Вся практическая криптография, которая включает использование групп, опирается на конечные (числовые) группы.

В криптографии с открытым ключом особенно важным является определенный класс конечных абелевых групп, известных как циклические группы. Для понимания циклических групп нам сначала нужно понять концепцию экспоненцирования элементов группы.
Предположим, что существует группа $G$ с групповой операцией $\circ$, и что $a$ является элементом группы $G$. Тогда выражение $a^n$ следует интерпретировать как элемент $a$, сочетающийся сам с собой в общей сложности $n – 1$ раз. Например, $a^2$ означает $a \circ a$, $a^3$ означает $a \circ a \circ a$ и так далее. (Заметим, что здесь возведение в степень не обязательно соответствует возведению в степень в обычном арифметическом смысле.)

Давайте рассмотрим пример. Предположим, что $G = \langle \mathbb{Z} \mod 7, + \rangle$, и наше значение для $a$ равно 4. В этом случае, $a^2 = [4 + 4 \mod 7] = [8 \mod 7] = 1 \mod 7$. В качестве альтернативы, $a^4$ будет представлять $[4 + 4 + 4 + 4 \mod 7] = [16 \mod 7] = 2 \mod 7$.

Некоторые абелевы группы имеют один или несколько элементов, которые могут порождать все другие элементы группы через непрерывное возведение в степень. Эти элементы называются **генераторами** или **примитивными элементами**.

Важным классом таких групп является $\langle \mathbb{Z}^* \mod N, \cdot \rangle$, где $N$ является простым числом. Обозначение $\mathbb{Z}^*$ здесь означает, что группа содержит все ненулевые положительные целые числа меньше $N$. Таким образом, эта группа всегда имеет $N – 1$ элементов.

Рассмотрим, например, $G = \langle \mathbb{Z}^* \mod 11, \cdot \rangle$. Эта группа имеет следующие элементы: $\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}$. Порядок этой группы равен 10 (что действительно равно $11 – 1$).

Давайте исследуем возведение в степень элемента 2 из этой группы. Расчеты до $2^{12}$ показаны ниже. Обратите внимание, что слева от уравнения показатель степени относится к возведению в степень элемента группы. В нашем конкретном примере это действительно включает арифметическое возведение в степень справа от уравнения (но это также могло бы включать, например, сложение). Для ясности я выписал повторяющуюся операцию, а не форму записи в виде степени справа.

* $2^1 = 2 \mod 11$
* $2^2 = 2 \cdot 2 \mod 11 = 4 \mod 11$
* $2^3 = 2 \cdot 2 \cdot 2 \mod 11 = 8 \mod 11$
* $2^4 = 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 16 \mod 11 = 5 \mod 11$
* $2^5 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 32 \mod 11 = 10 \mod 11$
* $2^6 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 64 \mod 11 = 9 \mod 11$
* $2^7 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 128 \mod 11 = 7 \mod 11$
* $2^8 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 256 \mod 11 = 3 \mod 11$
* $2^9 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 512 \mod 11 = 6 \mod 11$
* $2^{10} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 1024 \mod 11 = 1 \mod 11$
* $2^{11} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 2048 \mod 11 = 2 \mod 11$
* $2^{12} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 4096 \mod 11 = 4 \mod 11$

Если внимательно посмотреть, можно увидеть, что выполнение возведения в степень элемента 2 циклически проходит через все элементы $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ в следующем порядке: 2, 4, 8, 5, 10, 9, 7, 3, 6, 1. После $2^{10}$, продолжение возведения в степень элемента 2 снова циклически проходит через все элементы и в том же порядке. Следовательно, элемент 2 является генератором в $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$.

Хотя $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ имеет несколько генераторов, не все элементы этой группы являются генераторами. Рассмотрим, например, элемент 3. Проход через первые 10 возведений в степень, не показывая обременительных вычислений, дает следующие результаты:

* $3^1 = 3 \mod 11$
* $3^2 = 9 \mod 11$
* $3^3 = 5 \mod 11$
* $3^4 = 4 \mod 11$
* $3^5 = 1 \mod 11$
* $3^6 = 3 \mod 11$
* $3^7 = 9 \mod 11$
* $3^8 = 5 \mod 11$
* $3^9 = 4 \mod 11$
* $3^{10} = 1 \mod 11$
Вместо того чтобы перебирать все значения в $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$, возведение в степень элемента 3 приводит только к подмножеству этих значений: 3, 9, 5, 4 и 1. После пятого возведения в степень эти значения начинают повторяться.
Теперь мы можем определить **циклическую группу** как любую группу, имеющую по крайней мере один генератор. То есть, есть по крайней мере один элемент группы, из которого вы можете получить все другие элементы группы путем возведения в степень.

Вы могли заметить в нашем примере выше, что и $2^{10}$, и $3^{10}$ равны $1 \mod 11$. Фактически, хотя мы не будем выполнять расчеты, возведение в степень 10 любого элемента группы $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ даст $1 \mod 11$. Почему это так?

Это важный вопрос, но для ответа на него нужно немало работы.

Для начала предположим, что есть два положительных целых числа $a$ и $N$. Важная теорема в теории чисел утверждает, что $a$ имеет мультипликативный обратный элемент по модулю $N$ (то есть, целое число $b$, такое что $a \cdot b = 1 \mod N$), тогда и только тогда, когда наибольший общий делитель между $a$ и $N$ равен 1. То есть, если $a$ и $N$ взаимно просты.

Таким образом, для любой группы целых чисел, оснащенной умножением по модулю $N$, в набор включаются только меньшие взаимно простые с $N$. Этот набор можно обозначить как $\mathbb{Z}^c \mod N$.

Например, предположим, что $N$ равно 10. Только целые числа 1, 3, 7 и 9 взаимно просты с 10. Таким образом, набор $\mathbb{Z}^c \mod 10$ включает только $\{1, 3, 7, 9\}$. Вы не можете создать группу с целочисленным умножением по модулю 10, используя любые другие целые числа между 1 и 10. Для этой конкретной группы обратными являются пары 1 и 9, а также 3 и 7.

В случае, когда само $N$ является простым числом, все целые числа от 1 до $N – 1$ взаимно просты с $N$. Такая группа, таким образом, имеет порядок $N – 1$. Используя нашу раннюю нотацию, $\mathbb{Z}^c \mod N$ равно $\mathbb{Z}^* \mod N$, когда $N$ является простым числом. Группа, которую мы выбрали для нашего раннего примера, $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$, является конкретным примером этого класса групп.

Далее, функция $\phi(N)$ вычисляет количество взаимно простых чисел до числа $N$ и известна как **функция Эйлера**. [1] Согласно **теореме Эйлера**, когда два целых числа $a$ и $N$ взаимно просты, выполняется следующее:

* $a^{\phi(N)} \mod N = 1 \mod N$
Это имеет важное значение для класса групп $\langle \mathbb{Z}^* \mod N, \cdot \rangle$, где $N$ является простым числом. Для этих групп экспоненцирование элементов группы представляет собой арифметическое возведение в степень. То есть, $a^{\phi(N)} \mod N$ представляет арифметическую операцию $a^{\phi(N)} \mod N$. Поскольку любой элемент $a$ в этих мультипликативных группах взаимно прост с $N$, это означает, что $a^{\phi(N)} \mod N = a^{N – 1} \mod N = 1 \mod N$.

Теорема Эйлера является действительно важным результатом. Во-первых, она подразумевает, что все элементы в $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ могут циклически проходить через определенное количество значений при возведении в степень, которое делит $N – 1$. В случае $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$, это означает, что каждый элемент может циклически проходить только через 2, 5 или 10 элементов. Количество значений, через которые проходит любой элемент при возведении в степень, известно как **порядок элемента**. Элемент с порядком, эквивалентным порядку группы, является генератором.

Кроме того, теорема Эйлера подразумевает, что мы всегда можем знать результат $a^{N – 1} \mod N$ для любой группы $\langle \mathbb{Z}^* \mod N, \cdot \rangle$, где $N$ является простым числом. Это так, независимо от того, насколько сложными могут быть фактические вычисления.

Например, предположим, что наша группа это $\mathbb{Z}^* \mod 160,481,182$ (где 160,481,182 действительно является простым числом). Мы знаем, что все целые числа от 1 до 160,481,181 должны быть элементами этой группы, и что $\phi(n) = 160,481,181$. Хотя мы не можем выполнить все шаги в вычислениях, мы знаем, что выражения вроде $514^{160,481,181}$, $2,005^{160,481,181}$, и $256,212^{160,481,181}$ должны все равно давать $1 \mod 160,481,182$.

**Примечания:**

[1] Функция работает следующим образом. Любое целое число $N$ может быть разложено на произведение простых чисел. Предположим, что определенное $N$ разложено следующим образом: $p_1^{e1} \cdot p_2^{e2} \cdot \ldots \cdot p_m^{em}$, где все $p$ являются простыми числами, а все $e$ являются целыми числами, большими или равными 1. Тогда:

$$
\phi(N) = \sum_{i=1}^m \left[p_i^{e_i} - p_i^{e_i - 1}\right]
$$

Формула функции Эйлера для разложения $N$ на простые множители.

## Поля
<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

Группа является базовой алгебраической структурой в абстрактной алгебре, но существует много других. Единственной другой алгебраической структурой, с которой вам нужно быть знакомым, является **поле**, в частности **конечное поле**. Этот тип алгебраической структуры часто используется в криптографии, например, в Advanced Encryption Standard. Последний является основной схемой симметричного шифрования, с которой вы столкнетесь на практике.
Поле происходит из понятия группы. В частности, **поле** - это множество элементов **S**, оснащенное двумя бинарными операторами $\circ$ и $\diamond$, которое удовлетворяет следующим условиям:
1. Множество **S**, оснащенное $\circ$, является абелевой группой.
2. Множество **S**, оснащенное $\diamond$, является абелевой группой для "ненулевых" элементов.
3. Множество **S**, оснащенное двумя операторами, удовлетворяет так называемому условию дистрибутивности: Предположим, что $a$, $b$ и $c$ являются элементами **S**. Тогда **S**, оснащенное двумя операторами, удовлетворяет свойству дистрибутивности, когда $a \circ (b \diamond c) = (a \circ b) \diamond (a \circ c)$.

Следует отметить, что, как и в случае с группами, определение поля очень абстрактно. Оно не делает никаких утверждений о типах элементов в **S** или о операциях $\circ$ и $\diamond$. Просто говорится, что поле - это любое множество элементов с двумя операциями, для которых выполняются три вышеуказанных условия. (Элемент "ноль" во второй абелевой группе может быть абстрактно интерпретирован.)

Так что может быть примером поля? Хорошим примером является множество $\mathbb{Z} \mod 7$, или $\{0, 1, \ldots, 7\}$, определенное над стандартным сложением (вместо $\circ$ выше) и стандартным умножением (вместо $\diamond$ выше).

Во-первых, $\mathbb{Z} \mod 7$ удовлетворяет условию для того, чтобы быть абелевой группой по сложению, и оно удовлетворяет условию для того, чтобы быть абелевой группой по умножению, если рассматривать только ненулевые элементы. Во-вторых, сочетание множества с двумя операторами удовлетворяет условию дистрибутивности.

Дидактически полезно исследовать эти утверждения, используя некоторые конкретные значения. Давайте возьмем экспериментальные значения 5, 2 и 3, некоторые случайно выбранные элементы из множества $\mathbb{Z} \mod 7$, чтобы исследовать поле $\langle \mathbb{Z} \mod 7, +, \cdot \rangle$. Мы будем использовать эти три значения по порядку, по мере необходимости, для исследования конкретных условий.

Давайте сначала исследуем, является ли $\mathbb{Z} \mod 7$, оснащенное сложением, абелевой группой.

1. **Условие замкнутости**: Давайте возьмем 5 и 2 в качестве наших значений. В этом случае, $[5 + 2] \mod 7 = 7 \mod 7 = 0$. Это действительно элемент $\mathbb{Z} \mod 7$, так что результат согласуется с условием замкнутости.
2. **Условие ассоциативности**: Давайте возьмем 5, 2 и 3 в качестве наших значений. В этом случае, $[(5 + 2) + 3] \mod 7 = [5 + (2 + 3)] \mod 7 = 10 \mod 7 = 3$. Это согласуется с условием ассоциативности.
3. **Условие наличия нейтрального элемента**: Давайте возьмем 5 в качестве нашего значения. В этом случае, $[5 + 0] \mod 7 = [0 + 5] \mod 7 = 5$. Так что 0 выглядит как нейтральный элемент для сложения.
4. **Обратное условие**: Рассмотрим обратное к 5. Должно выполняться условие $[5 + d] \mod 7 = 0$ для некоторого значения $d$. В данном случае уникальное значение из $\mathbb{Z} \mod 7$, удовлетворяющее этому условию, равно 2.5. **Условие коммутативности**: Возьмем 5 и 3 в качестве наших значений. В этом случае $[5 + 3] \mod 7 = [3 + 5] \mod 7 = 1$. Это соответствует условию коммутативности.

Множество $\mathbb{Z} \mod 7$, оснащенное операцией сложения, явно представляет собой абелеву группу. Теперь давайте исследуем, является ли $\mathbb{Z} \mod 7$, оснащенное операцией умножения, абелевой группой для всех ненулевых элементов.

1. **Условие замкнутости**: Возьмем 5 и 2 в качестве наших значений. В этом случае $[5 \cdot 2] \mod 7 = 10 \mod 7 = 3$. Это также элемент $\mathbb{Z} \mod 7$, так что результат соответствует условию замкнутости.
2. **Условие ассоциативности**: Возьмем 5, 2 и 3 в качестве наших значений. В этом случае $[(5 \cdot 2) \cdot 3] \mod 7 = [5 \cdot (2 \cdot 3)] \mod 7 = 30 \mod 7 = 2$. Это соответствует условию ассоциативности.
3. **Условие наличия нейтрального элемента**: Возьмем 5 в качестве нашего значения. В этом случае $[5 \cdot 1] \mod 7 = [1 \cdot 5] \mod 7 = 5$. Так что 1 выглядит как нейтральный элемент для умножения.
4. **Обратное условие**: Рассмотрим обратное к 5. Должно выполняться условие $[5 \cdot d] \mod 7 = 1$ для некоторого значения $d$. Уникальное значение из $\mathbb{Z} \mod 7$, удовлетворяющее этому условию, равно 3. Это соответствует обратному условию.
5. **Условие коммутативности**: Возьмем 5 и 3 в качестве наших значений. В этом случае $[5 \cdot 3] \mod 7 = [3 \cdot 5] \mod 7 = 15 \mod 7 = 1$. Это соответствует условию коммутативности.

Множество $\mathbb{Z} \mod 7$ явно соответствует правилам абелевой группы при сочетании как операции сложения, так и умножения над ненулевыми элементами.

Наконец, это множество в сочетании с обеими операциями, кажется, соответствует условию дистрибутивности. Возьмем 5, 2 и 3 в качестве наших значений. Мы видим, что $[5 \cdot (2 + 3)] \mod 7 = [5 \cdot 2 + 5 \cdot 3] \mod 7 = 25 \mod 7 = 4$.

Теперь мы видели, что $\mathbb{Z} \mod 7$, оснащенное операциями сложения и умножения, соответствует аксиомам конечного поля при тестировании с конкретными значениями. Конечно, мы также можем показать это в общем случае, но не будем делать этого здесь.

Ключевое различие между двумя типами полей: конечные и бесконечные поля.
**Бесконечное поле** включает в себя поле, где множество **S** бесконечно велико. Множество вещественных чисел $\mathbb{R}$, оснащенное операциями сложения и умножения, является примером бесконечного поля. **Конечное поле**, также известное как **поле Галуа**, - это поле, где множество **S** конечно. Наш пример выше $\langle \mathbb{Z} \mod 7, +, \cdot \rangle$ является конечным полем.
В криптографии нас преимущественно интересуют конечные поля. В общем случае можно показать, что конечное поле существует для некоторого множества элементов **S** тогда и только тогда, когда оно имеет $p^m$ элементов, где $p$ - простое число, а $m$ - положительное целое число, большее или равное единице. Другими словами, если порядок некоторого множества **S** является простым числом ($p^m$, где $m = 1$) или степенью простого числа ($p^m$, где $m > 1$), тогда вы можете найти два оператора $\circ$ и $\diamond$ так, что условия для поля будут удовлетворены.

Если некоторое конечное поле имеет простое число элементов, то оно называется **простым полем**. Если количество элементов в конечном поле является степенью простого числа, то поле называется **расширенным полем**. В криптографии нас интересуют как простые, так и расширенные поля. [2]

Основные простые поля, представляющие интерес в криптографии, - это те, где множество всех целых чисел модулируется некоторым простым числом, а операторы - стандартные сложение и умножение. Этот класс конечных полей включал бы $\mathbb{Z} \mod 2$, $\mathbb{Z} \mod 3$, $\mathbb{Z} \mod 5$, $\mathbb{Z} \mod 7$, $\mathbb{Z} \mod 11$, $\mathbb{Z} \mod 13$ и так далее. Для любого простого поля $\mathbb{Z} \mod p$ множество целых чисел поля следующее: $\{0, 1, \ldots, p – 2, p – 1\}$.

В криптографии нас также интересуют расширенные поля, особенно любые поля с $2^m$ элементами, где $m > 1$. Такие конечные поля, например, используются в шифре Риждаля, который лежит в основе стандарта шифрования Advanced Encryption Standard. Хотя простые поля относительно интуитивно понятны, эти расширенные поля с основанием 2, вероятно, не для всех, кто не знаком с абстрактной алгеброй.

Для начала, действительно верно, что любому множеству целых чисел с $2^m$ элементами можно назначить два оператора, которые сделают их комбинацию полем (при условии, что $m$ - положительное целое число). Однако то, что поле существует, не обязательно означает, что его легко обнаружить или что оно особенно практично для определенных приложений.

Как оказалось, особенно применимые расширенные поля $2^m$ в криптографии - это те, которые определены над особыми множествами полиномиальных выражений, а не над каким-то множеством целых чисел.

Например, предположим, что мы хотели бы расширенное поле с $2^3$ (то есть, 8) элементами в множестве. Хотя может быть много различных множеств, которые можно использовать для полей такого размера, одно из таких множеств включает все уникальные полиномы вида $a_2x^2 + a_1x + a_0$, где каждый коэффициент $a_i$ либо 0, либо 1. Следовательно, это множество **S** включает следующие элементы:
1. $0$: Случай, когда $a_2 = 0$, $a_1 = 0$, и $a_0 = 0$.
2. $1$: Случай, когда $a_2 = 0$, $a_1 = 0$, и $a_0 = 1$.
3. $x$: Случай, когда $a_2 = 0$, $a_1 = 1$, и $a_0 = 0$.
4. $x + 1$: Случай, когда $a_2 = 0$, $a_1 = 1$, и $a_0 = 1$.
5. $x^2$: Случай, когда $a_2 = 1$, $a_1 = 0$, и $a_0 = 0$.
6. $x^2 + 1$: Случай, когда $a_2 = 1$, $a_1 = 0$, и $a_0 = 1$.
7. $x^2 + x$: Случай, когда $a_2 = 1$, $a_1 = 1$, и $a_0 = 0$.
8. $x^2 + x + 1$: Случай, когда $a_2 = 1$, $a_1 = 1$, и $a_0 = 1$.

Таким образом, **S** будет множеством $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$. Какие две операции могут быть определены над этим набором элементов, чтобы их комбинация образовала поле?

Первая операция над множеством **S** ($\circ$) может быть определена как стандартное сложение полиномов по модулю 2. Всё, что вам нужно сделать, это сложить полиномы так, как вы обычно это делаете, а затем применить модуль 2 к каждому из коэффициентов результирующего полинома. Вот несколько примеров:

* $[(x^2) + (x^2 + x + 1)] \mod 2 = [2x^2 + x + 1] \mod 2 = x + 1$
* $[(x^2 + x) + (x)] \mod 2 = [x^2 + 2x] \mod 2 = x^2$
* $[(x + 1) + (x^2 + x + 1)] \mod 2 = [x^2 + 2x + 2] \mod 2 = x^2 + 1$

Вторая операция над множеством **S** ($\diamond$), необходимая для создания поля, более сложная. Это своего рода умножение, но не стандартное арифметическое умножение. Вместо этого вам нужно рассматривать каждый элемент как вектор и понимать операцию как умножение этих двух векторов по модулю неприводимого полинома.

Давайте сначала обратимся к понятию неприводимого полинома. **Неприводимый полином** - это такой, который не может быть разложен на множители (так же, как простое число не может быть разложено на компоненты, отличные от 1 и самого простого числа). Для наших целей нас интересуют полиномы, которые являются неприводимыми относительно множества всех целых чисел. (Заметим, что некоторые полиномы можно разложить, например, на действительные или комплексные числа, даже если их нельзя разложить, используя целые числа.)
Например, рассмотрим многочлен $x^2 - 3x + 2$. Его можно переписать как $(x – 1)(x – 2)$. Следовательно, он не является неприводимым. Теперь рассмотрим многочлен $x^2 + 1$. Используя только целые числа, невозможно дальше разложить это выражение. Следовательно, это неприводимый многочлен относительно целых чисел.
Далее, давайте обратимся к концепции умножения векторов. Мы не будем глубоко изучать эту тему, но вам просто нужно понять основное правило: деление векторов возможно, пока дивиденд имеет степень выше или равную степени делителя. Если дивиденд имеет степень ниже, чем у делителя, то дивиденд больше не может быть разделен на делитель.

Например, рассмотрим выражение $x^6 + x + 1 \mod x^5 + x^2$. Очевидно, это выражение допускает дальнейшее упрощение, так как степень дивиденда, 6, выше степени делителя, 5. Теперь рассмотрим выражение $x^5 + x + 1 \mod x^5 + x^2$. Это также допускает дальнейшее упрощение, так как степень дивиденда, 5, и делителя, 5, равны.

Однако теперь рассмотрим выражение $x^4 + x + 1 \mod x^5 + x^2$. Это выражение не допускает дальнейшего упрощения, так как степень дивиденда, 4, ниже степени делителя, 5.

На основе этой информации мы теперь готовы найти нашу вторую операцию для множества $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$.

Я уже сказал, что вторая операция должна быть понята как умножение векторов по модулю некоторого неприводимого многочлена. Этот неприводимый многочлен должен обеспечивать, что вторая операция определяет абелеву группу над **S** и согласуется с условием дистрибутивности. Так каким же должен быть этот неприводимый многочлен?

Поскольку все векторы в множестве имеют степень 2 или ниже, неприводимый многочлен должен быть степени 3. Если любое умножение двух векторов в множестве дает многочлен степени 3 или выше, мы знаем, что по модулю многочлена степени 3 всегда получается многочлен степени 2 или ниже. Это так, потому что любой многочлен степени 3 или выше всегда делится на многочлен степени 3. Кроме того, многочлен, который функционирует как делитель, должен быть неприводимым.

Оказывается, существует несколько неприводимых многочленов степени 3, которые мы могли бы использовать в качестве нашего делителя. Каждый из этих многочленов определяет различное поле в сочетании с нашим множеством **S** и сложением по модулю 2. Это означает, что у вас есть несколько вариантов при использовании расширенных полей $2^m$ в криптографии.

Для нашего примера предположим, что мы выбираем многочлен $x^3 + x + 1$. Действительно, он является неприводимым, потому что его нельзя разложить на множители, используя целые числа. Кроме того, он обеспечит, что любое умножение двух элементов даст многочлен степени 2 или меньше.
Давайте рассмотрим пример второй операции, используя полином $x^3 + x + 1$ в качестве делителя, чтобы проиллюстрировать, как это работает. Предположим, что вы умножаете элементы $x^2 + 1$ на $x^2 + x$ в нашем множестве **S**. Затем нам нужно вычислить выражение $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1$. Это можно упростить следующим образом:
* $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1 =$
* $[x^2 \cdot x^2 + x^2 \cdot x + 1 \cdot x^2 + 1 \cdot x] \mod x^3 + x + 1 =$
* $[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$

Мы знаем, что $[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$ может быть уменьшено, так как степень делимого (4) выше, чем степень делителя (3).

Для начала, вы можете видеть, что выражение $x^3 + x + 1$ входит в $x^4 + x^3 + x^2 + x$ в общей сложности $x$ раз. Вы можете проверить это, умножив $x^3 + x + 1$ на $x$, что равно $x^4 + x^2 + x$. Поскольку последний член имеет такую же степень, как и делимое, а именно 4, мы знаем, что это работает. Вы можете рассчитать остаток от этого деления на $x$ следующим образом:

* $[(x^4 + x^3 + x^2 + x) - (x^4 + x^2 + x)] \mod x^3 + x + 1 =$
* $[x^3] \mod x^3 + x + 1 =$
* $x^3$

Таким образом, после деления $x^4 + x^3 + x^2 + x$ на $x^3 + x + 1$ в общей сложности $x$ раз, у нас остается остаток $x^3$. Можно ли далее разделить $x^3$ на $x^3 + x + 1$?

Интуитивно может показаться, что $x^3$ больше не может быть разделен на $x^3 + x + 1$, потому что последний член кажется больше. Однако, помните наше обсуждение деления векторов ранее. Пока степень делимого больше или равна степени делителя, выражение может быть дополнительно уменьшено. В частности, выражение $x^3 + x + 1$ может войти в $x^3$ ровно 1 раз. Остаток рассчитывается следующим образом:

$$
[(x^3) - (x^3 + x + 1)] \mod x^3 + x + 1 = [x + 1] \mod x^3 + x + 1 = x + 1
$$

Возможно, вы задаетесь вопросом, почему $(x^3) - (x^3 + x + 1)$ оценивается как $x + 1$, а не $-x - 1$. Помните, что первая операция нашего поля определена по модулю 2. Следовательно, вычитание двух векторов дает точно такой же результат, как и сложение двух векторов.
Подводя итог умножению $x^2 + 1$ и $x^2 + x$: когда вы умножаете эти два выражения, вы получаете полином четвертой степени, $x^4 + x^3 + x^2 + x$, который необходимо упростить по модулю $x^3 + x + 1$. Полином четвертой степени делится на $x^3 + x + 1$ ровно $x + 1$ раз. Остаток от деления $x^4 + x^3 + x^2 + x$ на $x^3 + x + 1$ ровно $x + 1$ раз равен $x + 1$. Это действительно элемент из нашего набора $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$.

Почему расширенные поля с основанием 2 над множествами полиномов, как в приведенном выше примере, могут быть полезны для криптографии? Причина в том, что коэффициенты в полиномах таких множеств, будь то 0 или 1, можно рассматривать как элементы двоичных строк определенной длины. Набор **S** в нашем примере выше, например, можно вместо этого рассматривать как набор **S**, который включает все двоичные строки длиной 3 (от 000 до 111). Таким образом, операции над **S** также могут использоваться для выполнения операций над этими двоичными строками и создания двоичной строки той же длины.

**Примечания:**

[2] Расширенные поля становятся очень контринтуитивными. Вместо элементов целых чисел они имеют множества полиномов. Кроме того, любые операции выполняются по модулю некоторого неприводимого полинома.

## Абстрактная алгебра на практике
<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>

Несмотря на формальный язык и абстрактность обсуждения, понятие группы не должно быть слишком сложным для понимания. Это просто набор элементов вместе с бинарной операцией, при выполнении которой на этих элементах соблюдаются четыре общих условия. Абелева группа имеет дополнительное условие, известное как коммутативность. Циклическая группа, в свою очередь, является особым видом абелевой группы, а именно той, которая имеет генератор. Поле - это просто более сложная конструкция из базового понятия группы.

Но если вы практически настроенный человек, вы можете задаться вопросом на этом этапе: Кому это интересно? Имеет ли знание о том, что некоторый набор элементов с оператором является группой, или даже абелевой или циклической группой, какое-либо практическое значение? Имеет ли значение знание о том, что что-то является полем?

Не вдаваясь в слишком много деталей, ответ - “да”. Группы были впервые созданы в 19 веке французским математиком Эваристом Галуа. Он использовал их для вывода выводов о решении полиномиальных уравнений степени выше пяти.

С тех пор концепция группы помогла осветить ряд проблем в математике и в других областях. На их основе, например, физик Мюррей-Гелл-Ман смог предсказать существование частицы до того, как она была фактически наблюдена в экспериментах. [3] В качестве другого примера, химики используют теорию групп для классификации форм молекул. Математики даже использовали концепцию группы для выводов о чем-то таком конкретном, как обои!
Показать, что набор элементов с некоторой операцией является группой, означает, что то, что вы описываете, обладает определенной симметрией. Не симметрией в обычном понимании слова, а в более абстрактной форме. И это может предоставить значительное понимание определенных систем и проблем. Более сложные понятия из абстрактной алгебры просто дают нам дополнительную информацию.
Самое важное, вы увидите значение групп и полей теории чисел на практике через их применение в криптографии, особенно в криптографии с открытым ключом. Мы уже видели в нашем обсуждении полей, например, как расширенные поля используются в шифре Рейндал. Мы рассмотрим этот пример в *Главе 5*.

Для дальнейшего обсуждения абстрактной алгебры я бы рекомендовал отличную серию видео по абстрактной алгебре от Socratica. [4] Особенно рекомендую следующие видео: "Что такое абстрактная алгебра?", "Определение группы (расширенное)", "Определение кольца (расширенное)" и "Определение поля (расширенное)". Эти четыре видео дадут вам дополнительное понимание многих обсуждаемых выше вопросов. (Мы не обсуждали кольца, но поле - это просто особый тип кольца.)

Для дальнейшего обсуждения современной теории чисел вы можете обратиться к многим продвинутым обсуждениям криптографии. В качестве предложений я бы предложил "Введение в современную криптографию" Джонатана Каца и Йехуды Линделла или "Понимание криптографии" Кристофа Паара и Яна Пельцля для дальнейшего обсуждения. [5]

**Примечания:**

[3] Смотрите [Видео на YouTube](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be)

[4] Socratica, [Абстрактная алгебра](https://www.socratica.com/subject/abstract-algebra)

[5] Кац и Линделл, *Введение в современную криптографию*, 2-е изд., 2015 (CRC Press: Бока-Ратон, Флорида). Паар и Пельцль, *Понимание криптографии*, 2010 (Springer-Verlag: Берлин).

# Симметричная криптография
<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

## Алиса и Боб
<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

Одним из двух основных направлений криптографии является симметричная криптография. Она включает в себя схемы шифрования, а также схемы, связанные с аутентификацией и целостностью. До 1970-х годов вся криптография состояла из симметричных схем шифрования.

Основное обсуждение начинается с рассмотрения симметричных схем шифрования и делает важное различие между потоковыми шифрами и блочными шифрами. Затем мы переходим к кодам аутентификации сообщений, которые являются схемами для обеспечения целостности и подлинности сообщений. Наконец, мы исследуем, как симметричные схемы шифрования и коды аутентификации сообщений могут быть объединены для обеспечения безопасной коммуникации.

В этой главе вкратце обсуждаются различные симметричные криптографические схемы на практике. Следующая глава предлагает подробное изложение шифрования с использованием потокового шифра и блочного шифра на практике, а именно RC4 и AES соответственно.

Перед началом нашего обсуждения симметричной криптографии я хочу кратко сделать несколько замечаний об иллюстрациях Алисы и Боба в этой и последующих главах.

___

При иллюстрации принципов криптографии люди часто опираются на примеры с участием Алисы и Боба. Я тоже буду придерживаться этого. 

Особенно если вы новичок в криптографии, важно понимать, что эти примеры с Алисой и Бобом предназначены только для иллюстрации криптографических принципов и конструкций в упрощенной среде. Однако принципы и конструкции применимы к гораздо более широкому кругу реальных контекстов.
Ниже приведены пять ключевых моментов, которые следует иметь в виду при рассмотрении примеров с участием Алисы и Боба в криптографии:
1. Их можно легко адаптировать к примерам с другими типами участников, такими как компании или государственные организации.
2. Их можно легко расширить, включив три или более участников.
3. В примерах Боб и Алиса обычно являются активными участниками в создании каждого сообщения и в применении криптографических схем к этому сообщению. Но на самом деле электронная коммуникация в большей степени автоматизирована. Например, когда вы посещаете веб-сайт, использующий безопасность транспортного уровня, криптография обычно полностью обрабатывается вашим компьютером и веб-сервером.
4. В контексте электронной коммуникации "сообщения", которые передаются по каналу связи, обычно являются пакетами TCP/IP. Они могут относиться к электронной почте, сообщению в Facebook, телефонному разговору, передаче файла, веб-сайту, загрузке программного обеспечения и так далее. Это не сообщения в традиционном смысле. Тем не менее, криптографы часто упрощают эту реальность, заявляя, что сообщение, например, является электронной почтой.
5. Примеры обычно сосредоточены на электронной коммуникации, но их также можно расширить на традиционные формы коммуникации, такие как письма.

## Схемы симметричного шифрования

Мы можем условно определить **схему симметричного шифрования** как любую криптографическую схему с тремя алгоритмами:

1. **Алгоритм генерации ключа**, который генерирует приватный ключ.
2. **Алгоритм шифрования**, который принимает приватный ключ и открытый текст в качестве входных данных и выдает шифртекст.
3. **Алгоритм дешифрования**, который принимает приватный ключ и шифртекст в качестве входных данных и выдает исходный открытый текст.

Обычно схема шифрования — будь то симметричная или асимметричная — предлагает шаблон для шифрования на основе базового алгоритма, а не точную спецификацию.

Например, рассмотрим Salsa20, схему симметричного шифрования. Ее можно использовать как с 128-битными, так и с 256-битными длинами ключей. Выбор длины ключа влияет на некоторые мелкие детали алгоритма (точное количество раундов в алгоритме).

Но нельзя сказать, что использование Salsa20 с 128-битным ключом является другой схемой шифрования, чем Salsa20 с 256-битным ключом. Базовый алгоритм остается тем же. Только при изменении базового алгоритма мы действительно говорим о двух разных схемах шифрования.

Схемы симметричного шифрования обычно полезны в двух типах случаев: (1) Когда два или более агента общаются на расстоянии и хотят сохранить содержание своих коммуникаций в секрете; и (2) когда один агент хочет сохранить содержание сообщения в секрете на протяжении времени.

Вы можете увидеть изображение ситуации (1) на *Рисунке 1* ниже. Боб хочет отправить сообщение $M$ Алисе на расстоянии, но не хочет, чтобы другие могли прочитать это сообщение.

Боб сначала шифрует сообщение $M$ с помощью приватного ключа $K$. Затем он отправляет шифртекст $C$ Алисе. Как только Алиса получает шифртекст, она может расшифровать его с помощью ключа $K$ и прочитать открытый текст. С хорошей схемой шифрования любой злоумышленник, перехвативший шифртекст $C$, не должен иметь возможности узнать что-либо действительно значимое о сообщении $M$.

Вы можете увидеть изображение ситуации (2) на *Рисунке 2* ниже. Боб хочет предотвратить просмотр определенной информации другими людьми. Типичная ситуация может заключаться в том, что Боб является сотрудником, хранящим конфиденциальные данные на своем компьютере, которые не должны читать ни посторонние, ни его коллеги.
Боб шифрует сообщение $M$ в момент времени $T_0$ с помощью ключа $K$, получая зашифрованный текст $C$. В момент времени $T_1$ ему снова нужно сообщение, и он расшифровывает зашифрованный текст $C$ с помощью ключа $K$. Любой злоумышленник, который мог бы столкнуться с зашифрованным текстом $C$ в промежутке времени, не должен был бы иметь возможности вывести что-либо значимое о $M$ из него.

*Рисунок 1: Секретность в пространстве*

![Рисунок 1: Секретность в пространстве](assets/Figure4-1.webp "Рисунок 1: Секретность в пространстве")

*Рисунок 2: Секретность во времени*

![Рисунок 2: Секретность во времени](assets/Figure4-2.webp "Рисунок 2: Секретность во времени")

## Пример: Шифр сдвига
<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

В главе 2 мы столкнулись с шифром сдвига, который является примером очень простой симметричной схемы шифрования. Давайте рассмотрим его снова здесь.

Предположим, что существует словарь *D*, который соотносит все буквы английского алфавита, по порядку, с набором чисел $\{0,1,2,\dots,25\}$. Предположим набор возможных сообщений **M**. Тогда шифр сдвига - это схема шифрования, определенная следующим образом:

- Случайным образом выбирается ключ $k$ из набора возможных ключей **K**, где **K** = $\{0,1,2,\dots,25\}$
- Шифрование сообщения $m \in$ **M** происходит следующим образом:
    - Разделяем $m$ на отдельные буквы $m_0, m_1,\dots, m_i, \dots, m_l$
    - Конвертируем каждый $m_i$ в число согласно *D*
    - Для каждого $m_i$, $c_i = [(m_i + k) \mod 26]$
    - Конвертируем каждый $c_i$ обратно в букву согласно *D*
    - Затем объединяем $c_0, c_1,\dots, c_l$, получая зашифрованный текст $c$
- Расшифровка зашифрованного текста $c$ происходит следующим образом:
    - Конвертируем каждый $c_i$ в число согласно *D*
    - Для каждого $c_i$, $m_i = [(c_i - k) \mod 26]$
    - Конвертируем каждый $m_i$ обратно в букву согласно *D*
    - Затем объединяем $m_0, m_1,\dots, m_l$, получая исходное сообщение $m$

То, что делает шифр сдвига симметричной схемой шифрования, заключается в использовании одного и того же ключа как для процесса шифрования, так и для процесса расшифровки. Например, предположим, что вы хотите зашифровать сообщение “DOG” с использованием шифра сдвига, и случайным образом выбрали ключ "24". Шифрование сообщения с этим ключом даст “BME”. Единственный способ восстановить исходное сообщение - использовать тот же ключ, "24", для процесса расшифровки.

Этот шифр сдвига является примером **моноалфавитного шифра подстановки**: схемы шифрования, где алфавит зашифрованного текста фиксирован (то есть используется только один алфавит). Предполагая, что алгоритм расшифровки детерминирован, каждый символ в зашифрованном тексте подстановки может соответствовать максимум одному символу в исходном тексте.
До 1700-х годов многие применения шифрования в значительной степени зависели от шифров подстановки с одним алфавитом, хотя часто они были гораздо сложнее шифра сдвига. Например, вы могли случайным образом выбрать букву из алфавита для каждой буквы исходного текста при условии, что каждая буква встречается в алфавите шифртекста только один раз. Это означает, что у вас было бы факториал 26 возможных секретных ключей, что было огромным количеством в доэлектронную эпоху.
Обратите внимание, что термин **шифр** вы будете встречать очень часто в криптографии. Имейте в виду, что этот термин имеет различные значения. Фактически, я знаю по крайней мере пять различных значений этого термина в криптографии.

В некоторых случаях он относится к схеме шифрования, как это делается в шифре сдвига и шифре моноалфавитной подстановки. Однако термин также может относиться конкретно к алгоритму шифрования, секретному ключу или просто к шифртексту любой такой схемы шифрования.

Наконец, термин шифр также может относиться к базовому алгоритму, из которого можно построить криптографические схемы. Это может включать различные алгоритмы шифрования, но также и другие типы криптографических схем. Этот смысл термина становится актуальным в контексте блочных шифров (см. раздел "Блочные шифры" ниже).

Вы также можете столкнуться с терминами **зашифровать** или **расшифровать**. Эти термины являются просто синонимами шифрования и дешифрования.

## Атаки полным перебором и принцип Керкгоффса
<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

Шифр сдвига является очень ненадежной симметричной схемой шифрования, по крайней мере, в современном мире. [1] Атакующий может просто попытаться расшифровать любой шифртекст со всеми 26 возможными ключами, чтобы увидеть, какой результат имеет смысл. Этот тип атаки, когда атакующий просто перебирает ключи, чтобы увидеть, что работает, известен как **атака полным перебором** или **исчерпывающий поиск ключа**.

Для того чтобы схема шифрования соответствовала минимальному понятию безопасности, она должна иметь набор возможных ключей, или **пространство ключей**, которое настолько велико, что атаки полным перебором являются невозможными. Все современные схемы шифрования соответствуют этому стандарту. Это известно как принцип **достаточного пространства ключей**. Подобный принцип обычно применяется в различных типах криптографических схем.

Чтобы представить себе огромный размер пространства ключей в современных схемах шифрования, предположим, что файл был зашифрован с использованием 128-битного ключа с использованием стандарта передового шифрования. Это означает, что у атакующего есть набор из $2^{128}$ ключей, через которые ей нужно пройти для атаки полным перебором. Шанс успеха в 0,78% с этой стратегией потребовал бы от атакующего перебрать примерно $2.65 \times 10^{36}$ ключей.

Предположим, мы оптимистично предполагаем, что атакующий может попытаться $10^{16}$ ключей в секунду (то есть 10 квадриллионов ключей в секунду). Чтобы проверить 0,78% всех ключей в пространстве ключей, её атака должна была бы длиться $2.65 \times 10^{20}$ секунд. Это около 8,4 триллиона лет. Так что даже атака полным перебором со стороны абсурдно мощного противника не реалистична с современной 128-битной схемой шифрования. Это принцип достаточного пространства ключей в действии.

Будет ли шифр сдвига более безопасным, если атакующий не знает алгоритм шифрования? Возможно, но не намного.
В любом случае современная криптография всегда исходит из предположения, что безопасность любой симметричной схемы шифрования зависит только от секретности закрытого ключа. Предполагается, что атакующий знает все остальные детали, включая пространство сообщений, пространство ключей, пространство шифртекстов, алгоритм выбора ключа, алгоритм шифрования и алгоритм дешифрования.
Идея о том, что безопасность симметричной схемы шифрования может зависеть только от секретности закрытого ключа, известна как **принцип Керкгоффса**.

Как изначально предполагал Керкгоффс, принцип применяется только к симметричным схемам шифрования. Однако более общая версия принципа также применима ко всем другим современным типам криптографических схем: дизайн любой криптографической схемы не должен быть секретным, чтобы обеспечить ее безопасность; секретность может распространяться только на некоторые строки информации, обычно на закрытый ключ.

Принцип Керкгоффса имеет центральное значение для современной криптографии по четырем причинам. Во-первых, существует лишь ограниченное количество криптографических схем для определенных типов приложений. Например, большинство современных приложений симметричного шифрования используют шифр Рейндал. Таким образом, ваша секретность в отношении дизайна схемы очень ограничена. Однако есть гораздо больше гибкости в сохранении в секрете некоторого закрытого ключа для шифра Рейндал.

Во-вторых, заменить некоторую строку информации проще, чем целую криптографическую схему. Предположим, что все сотрудники компании используют одно и то же программное обеспечение для шифрования, и каждые два сотрудника имеют закрытый ключ для конфиденциального общения. Компрометация ключей в этом сценарии вызывает проблемы, но по крайней мере компания могла бы сохранить программное обеспечение с такими нарушениями безопасности. Если бы компания полагалась на секретность схемы, любое нарушение этой секретности потребовало бы замены всего программного обеспечения.

В-третьих, принцип Керкгоффса позволяет стандартизировать и обеспечивать совместимость между пользователями криптографических схем. Это имеет огромные преимущества для эффективности. Например, трудно представить, как миллионы людей могли бы безопасно подключаться к веб-серверам Google каждый день, если бы эта безопасность требовала сохранения в секрете криптографических схем.

В-четвертых, принцип Керкгоффса позволяет публичному анализу криптографических схем. Такой анализ абсолютно необходим для достижения безопасных криптографических схем. Например, основной алгоритм в симметричной криптографии, шифр Рейндал, был результатом конкурса, организованного Национальным институтом стандартов и технологий с 1997 по 2000 год.

Любая система, которая пытается достичь **безопасности за счет неясности**, полагается на сохранение в секрете деталей своего дизайна и/или реализации. В криптографии это будет конкретно система, которая полагается на сохранение в секрете деталей дизайна криптографической схемы. Таким образом, безопасность за счет неясности находится в прямом противоречии с принципом Керкгоффса.

Способность открытости улучшать качество и безопасность также распространяется шире на цифровой мир, чем только криптография. Свободные и открытые дистрибутивы Linux, такие как Debian, например, обычно имеют несколько преимуществ перед их аналогами Windows и MacOS с точки зрения конфиденциальности, стабильности, безопасности и гибкости. Хотя это может иметь несколько причин, вероятно, самый важный принцип, как выразил это Эрик Реймонд в своем знаменитом эссе "Собор и базар", заключается в том, что "при достаточном количестве глаз все баги поверхностны". Этот принцип мудрости толпы и дал Linux его наибольший успех.
Нельзя однозначно утверждать, что криптографическая схема "безопасна" или "небезопасна". Вместо этого существуют различные понятия безопасности для криптографических схем. Каждое **определение криптографической безопасности** должно указывать (1) цели безопасности, а также (2) возможности атакующего. Анализ криптографических схем с точки зрения одного или нескольких конкретных понятий безопасности дает представление о их применении и ограничениях.
Хотя мы не будем углубляться во все детали различных понятий криптографической безопасности, вы должны знать, что два предположения являются общими для всех современных понятий безопасности, касающихся симметричных и асимметричных схем (и в какой-то форме к другим криптографическим примитивам):

* Знания атакующего о схеме соответствуют принципу Керкгоффа.
* Атакующий не может осуществимо выполнить атаку методом полного перебора по схеме. В частности, модели угроз криптографических понятий безопасности обычно даже не допускают атак методом полного перебора, поскольку предполагается, что они не являются актуальным соображением.

**Примечания:**

[1] Согласно Светонию, шифр сдвига с постоянным ключевым значением 3 использовался Юлием Цезарем в его военной переписке. Таким образом, A всегда становилась D, B всегда E, C всегда F и так далее. Эта конкретная версия шифра сдвига, таким образом, стала известна как **Шифр Цезаря** (хотя это не действительно шифр в современном смысле слова, так как ключевое значение постоянно). Шифр Цезаря мог быть безопасен в первом веке до н.э., если враги Рима были очень незнакомы с шифрованием. Но в современные времена он явно не был бы очень безопасной схемой.

[2] Джонатан Кац и Йехуда Линделл, _Введение в современную криптографию_, CRC Press (Бока-Ратон, Флорида: 2015), стр. 7 и далее.

[3] Эрик Рэймонд, “Собор и базар”, доклад был представлен на Linux Kongress, Вюрцбург, Германия (27 мая 1997 года). Существует ряд последующих версий, а также книга. Мои цитаты из страницы 30 в книге: Эрик Рэймонд, _Собор и базар: Размышления о Linux и Open Source от случайного революционера_, пересмотренное издание. (2001), O’Reilly: Себастополь, Калифорния.

## Потоковые шифры
<chapterId>479aa6f4-45c4-59ca-8616-8cf8e61fc871</chapterId>

Симметричные шифровальные схемы стандартно подразделяются на два типа: **потоковые шифры** и **блочные шифры**. Однако это различие несколько проблематично, поскольку люди используют эти термины неоднозначно. В следующих нескольких разделах я изложу различие так, как считаю это наилучшим образом. Однако вы должны быть осведомлены, что многие люди могут использовать эти термины несколько иначе, чем я изложил.

Давайте сначала обратимся к потоковым шифрам. **Потоковый шифр** — это симметричная шифровальная схема, где шифрование состоит из двух шагов.

Сначала, с помощью приватного ключа производится строка, длина которой равна длине открытого текста. Эта строка называется **ключевым потоком**.

Затем, ключевой поток математически сочетается с открытым текстом для производства шифртекста. Это сочетание обычно является операцией XOR. Для расшифровки вы можете просто выполнить обратную операцию. (Заметьте, что $A \oplus B = B \oplus A$, в случае если $A$ и $B$ являются битовыми строками. Таким образом, порядок операции XOR в потоковом шифре не имеет значения для результата. Это свойство известно как **коммутативность**.)
Типичный потоковый шифр XOR изображен на *Рисунке 3*. Сначала вы берете закрытый ключ $K$ и используете его для генерации ключевого потока. Затем ключевой поток комбинируется с открытым текстом с помощью операции XOR, что приводит к созданию шифртекста. Любой агент, получивший шифртекст, может легко расшифровать его, если у него есть ключ $K$. Все, что ей нужно сделать, это создать ключевой поток такой же длины, как шифртекст, согласно указанной процедуре схемы, и выполнить с ним операцию XOR.

*Рисунок 3: Потоковый шифр XOR*

![Рисунок 3: Потоковый шифр XOR](assets/Figure4-3.webp "Рисунок 3: Потоковый шифр XOR")

Напоминаем, что схема шифрования обычно является шаблоном для шифрования с одним и тем же базовым алгоритмом, а не точной спецификацией. Соответственно, потоковый шифр обычно является шаблоном для шифрования, в котором можно использовать ключи разной длины. Хотя длина ключа может влиять на некоторые мелкие детали схемы, это не повлияет на ее существенную форму.

Шифр сдвига является примером очень простого и ненадежного потокового шифра. Используя одну букву (закрытый ключ), вы можете произвести строку букв длиной сообщения (ключевой поток). Затем этот ключевой поток комбинируется с открытым текстом с помощью операции по модулю для получения шифртекста. (Эта операция по модулю может быть упрощена до операции XOR при представлении букв в битах).

Еще один известный пример потокового шифра - **шифр Виженера**, названный в честь Блеза де Виженера, который полностью разработал его в конце 16-го века (хотя другие уже проделали много предварительной работы). Это пример **полиалфавитного шифра подстановки**: схемы шифрования, где алфавит шифртекста для символа открытого текста меняется в зависимости от его позиции в тексте. В отличие от моноалфавитного шифра подстановки, символы шифртекста могут быть связаны с более чем одним символом открытого текста.

С развитием популярности шифрования в Ренессансной Европе также развивался **криптоанализ** — то есть, взлом шифртекстов — особенно с использованием **частотного анализа**. Последний использует статистические закономерности в нашем языке для взлома шифртекстов и был открыт арабскими учеными уже в девятом веке. Это техника, которая особенно хорошо работает с более длинными текстами. И даже самые сложные моноалфавитные шифры подстановки уже не были достаточны против частотного анализа к 1700-м годам в Европе, особенно в военных и безопасностных настройках. Поскольку шифр Виженера предложил значительное улучшение в безопасности, он стал популярным в этот период и был широко распространен к концу 1700-х годов.

Неформально говоря, схема шифрования работает следующим образом:

1. Выберите слово из нескольких букв в качестве закрытого ключа.
2. Для любого сообщения примените шифр сдвига к каждой букве сообщения, используя соответствующую букву в ключевом слове в качестве сдвига.
3. Если вы прошли через ключевое слово, но еще не зашифровали весь открытый текст, снова примените буквы ключевого слова как шифр сдвига к соответствующим буквам в оставшейся части текста.
4. Продолжайте этот процесс, пока весь сообщение не будет зашифровано.

Для иллюстрации предположим, что ваш закрытый ключ - "GOLD", и вы хотите зашифровать сообщение "CRYPTOGRAPHY". В этом случае вы бы продолжили следующим образом согласно шифру Виженера:

- $c_0  = [(2 + 6) \mod 26] = 8 = I$
- $c_1  = [(17 + 14) \mod 26] = 5 = F$
- $c_2  = [(24 + 11) \mod 26] = 9 = J$
- $c_3 = [(15 + 3) \mod 26] = 18 = S$
- $c_4 = [(19 + 6) \mod 26] = 25 = Z$
- $c_5 = [(14 + 14) \mod 26] = 2 = C$
- $c_6 = [(6 + 11) \mod 26] = 17 = R$
- $c_7 = [(17 + 3) \mod 26] = 20 = U$
- $c_8 = [(0 + 6) \mod 26] = 6 = G$
- $c_9 = [(15 + 14) \mod 26] = 3 = D$
- $c_{10} = [(7 + 11) \mod 26] = 18 = S$
- $c_{11} = [(24 + 3) \mod 26] = 1 = B$

Таким образом, шифртекст $c$ = "IFJSZCRUGDSB".

Еще один известный пример потокового шифра - это **одноразовый блокнот**. С одноразовым блокнотом вы просто создаете строку случайных битов такой же длины, как и сообщение открытого текста, и производите шифртекст с помощью операции XOR. Таким образом, приватный ключ и ключевой поток эквивалентны при использовании одноразового блокнота.

В то время как шифр сдвига и шифр Виженера очень ненадежны в современную эпоху, одноразовый блокнот очень безопасен при правильном использовании. Вероятно, самое известное применение одноразового блокнота, по крайней мере до 1980-х годов, было для **горячей линии Вашингтон-Москва**.

Горячая линия - это прямая связь между Вашингтоном и Москвой для срочных дел, которая была установлена после Карибского кризиса. Технология для нее трансформировалась на протяжении годов. В настоящее время она включает прямой оптоволоконный кабель, а также две спутниковые связи (для резервирования), которые позволяют использовать электронную почту и текстовые сообщения. Связь заканчивается в различных местах в США. Известными конечными точками являются Пентагон, Белый дом и гора Рейвен Рок. Вопреки распространенному мнению, горячая линия никогда не включала телефоны.

По сути, схема одноразового блокнота работала следующим образом. И Вашингтон, и Москва имели два набора случайных чисел. Один набор случайных чисел, созданный русскими, относился к шифрованию и дешифрованию любых сообщений на русском языке. Один набор случайных чисел, созданный американцами, относился к шифрованию и дешифрованию любых сообщений на английском языке. Время от времени больше случайных чисел доставлялось другой стороне доверенными курьерами.

Таким образом, Вашингтон и Москва могли тайно общаться, используя эти случайные числа для создания одноразовых блокнотов. Каждый раз, когда вам нужно было общаться, вы использовали следующую часть случайных чисел для вашего сообщения.

Несмотря на высокую степень безопасности, одноразовый блокнот сталкивается с значительными практическими ограничениями: ключ должен быть такой же длины, как и сообщение, и ни одна часть одноразового блокнота не может быть использована повторно. Это означает, что вам нужно отслеживать, где вы находитесь в одноразовом блокноте, хранить огромное количество битов и время от времени обмениваться случайными битами с вашими контрагентами. В результате, одноразовый блокнот не часто используется на практике.

Вместо этого, в практике чаще используются **псевдослучайные потоковые шифры**. Salsa20 и тесно связанный с ним вариант ChaCha являются примерами часто используемых псевдослучайных потоковых шифров.
С этими потоковыми шифрами на основе псевдослучайных последовательностей вы сначала случайным образом выбираете ключ K, который короче длины открытого текста. Такой случайный ключ K обычно создается нашим компьютером на основе непредсказуемых данных, которые он собирает со временем, таких как время между сетевыми сообщениями, движения мыши и так далее.
Этот случайный ключ $K$ затем вставляется в алгоритм расширения, который создает псевдослучайную ключевую последовательность такой же длины, как и сообщение. Вы можете точно указать, какой длины должна быть ключевая последовательность (например, 500 бит, 1000 бит, 1200 бит, 29 117 бит и так далее).

Псевдослучайная ключевая последовательность кажется *как будто* она была выбрана совершенно случайно из множества всех строк одинаковой длины. Следовательно, шифрование с использованием псевдослучайной ключевой последовательности кажется таким, как будто оно было выполнено с использованием одноразового блокнота. Но это, конечно, не так.

Поскольку наш секретный ключ короче ключевой последовательности и наш алгоритм расширения должен быть детерминированным, чтобы процесс шифрования/дешифрования работал, не каждая ключевая последовательность данной длины могла бы быть результатом нашей операции расширения.

Предположим, например, что наш секретный ключ имеет длину 128 бит и что мы можем вставить его в алгоритм расширения, чтобы создать гораздо более длинную ключевую последовательность, скажем, из 2 500 бит. Поскольку наш алгоритм расширения должен быть детерминированным, наш алгоритм может выбрать максимум $1/2^{128}$ строк длиной 2 500 бит. Так что такая ключевая последовательность никогда не могла бы быть выбрана полностью случайно из всех строк одинаковой длины.

Наше определение потокового шифра имеет два аспекта: (1) ключевая последовательность такой же длины, как и открытый текст, генерируется с помощью секретного ключа; и (2) эта ключевая последовательность сочетается с открытым текстом, обычно через операцию XOR, для создания шифртекста.

Иногда люди определяют условие (1) более строго, утверждая, что ключевая последовательность должна быть специфически псевдослучайной. Это означает, что ни шифр сдвига, ни одноразовый блокнот не будут рассматриваться как потоковые шифры.

На мой взгляд, более широкое определение условия (1) предоставляет более простой способ организации схем шифрования. Кроме того, это означает, что нам не нужно переставать называть определенную схему шифрования потоковым шифром только потому, что мы узнаем, что она на самом деле не полагается на псевдослучайные ключевые последовательности.

**Примечания:**

[4] Криптомузей, "Горячая линия Вашингтон-Москва", 2013, доступно на [https://www.cryptomuseum.com/crypto/hotline/index.htm](https://www.cryptomuseum.com/crypto/hotline/index.htm).

## Блочные шифры
<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

Первый способ, которым обычно понимается **блочный шифр**, - это как что-то более примитивное, чем потоковый шифр: основной алгоритм, который выполняет преобразование с сохранением длины на строке подходящей длины с помощью ключа. Этот алгоритм может использоваться для создания схем шифрования и, возможно, других типов криптографических схем.
Часто блочный шифр может принимать входные строки различной длины, такие как 64, 128 или 256 бит, а также ключи различной длины, такие как 128, 192 или 256 бит. Хотя некоторые детали алгоритма могут изменяться в зависимости от этих переменных, основной алгоритм остается неизменным. Если бы это было не так, мы говорили бы о двух разных блочных шифрах. Обратите внимание, что использование терминологии "основной алгоритм" здесь такое же, как и для схем шифрования.
Иллюстрация работы блочного шифра может быть видна на *Рисунке 4* ниже. Сообщение $M$ длиной $L$ и ключ $K$ служат входными данными для блочного шифра. Он выдает сообщение $M'$ длиной $L$. Ключ не обязательно должен быть той же длины, что и $M$ и $M'$, для большинства блочных шифров.

*Рисунок 4: Блочный шифр*

![Рисунок 4: Блочный шифр](assets/Figure4-4.webp "Рисунок 4: Блочный шифр")

Блочный шифр сам по себе не является схемой шифрования. Но блочный шифр может использоваться с различными **режимами работы** для создания разных схем шифрования. Режим работы просто добавляет некоторые дополнительные операции вне блочного шифра.

Чтобы проиллюстрировать, как это работает, предположим, что блочный шифр (BC) требует 128-битную входную строку и 128-битный закрытый ключ. На рисунке 5 ниже показано, как этот блочный шифр может быть использован с **режимом электронной кодовой книги** (**ECB режим**) для создания схемы шифрования. (Многоточия справа указывают, что вы можете повторять этот паттерн столько, сколько необходимо).

*Рисунок 5: Блочный шифр с режимом ECB*

![Рисунок 5: Блочный шифр с режимом ECB](assets/Figure4-5.webp "Рисунок 5: Блочный шифр с режимом ECB")

Процесс шифрования электронной кодовой книги с использованием блочного шифра следующий. Посмотрите, можно ли разделить ваше исходное сообщение на блоки по 128 бит. Если нет, добавьте **дополнение** к сообщению, чтобы результат мог быть равномерно разделен на блоки размером 128 бит. Это ваши данные, используемые для процесса шифрования.

Теперь разделите данные на части по 128-битным строкам ($M_1$, $M_2$, $M_3$ и так далее). Пропустите каждую 128-битную строку через блочный шифр с вашим 128-битным ключом, чтобы получить 128-битные части шифртекста ($C_1$, $C_2$, $C_3$ и так далее). Эти части, когда они снова соединены, формируют полный шифртекст.

Расшифровка - это просто обратный процесс, хотя получателю действительно нужен какой-то узнаваемый способ удалить любое дополнение из расшифрованных данных, чтобы восстановить исходное исходное сообщение.

Хотя относительно простой, блочный шифр с режимом электронной кодовой книги не обладает безопасностью. Это потому, что он приводит к **детерминированному шифрованию**. Любые две идентичные 128-битные строки данных шифруются абсолютно одинаково. Эту информацию можно использовать.

Вместо этого, любая схема шифрования, построенная на основе блочного шифра, должна быть **вероятностной**: то есть шифрование любого сообщения $M$ или любого конкретного фрагмента $M$ должно обычно приводить к разному результату каждый раз. [5]

**Режим цепочки блоков шифрования** (**CBC режим**) вероятно, является наиболее распространенным режимом, используемым с блочным шифром. Комбинация, если сделана правильно, создает вероятностную схему шифрования. Вы можете увидеть иллюстрацию этого режима работы на *Рисунке 6* ниже.
![Рисунок 6: Блочный шифр с режимом CBC](assets/Figure4-6.webp "Рисунок 6: Блочный шифр с режимом CBC")
Предположим, что размер блока снова составляет 128 бит. Таким образом, для начала вам снова нужно будет убедиться, что ваше исходное открытое сообщение получает необходимое дополнение.

Затем вы выполняете операцию XOR первой 128-битной части вашего открытого текста с **вектором инициализации** размером 128 бит. Результат помещается в блочный шифр для получения шифртекста первого блока. Для второго блока размером 128 бит вы сначала выполняете операцию XOR открытого текста с шифртекстом из первого блока, прежде чем вставить его в блочный шифр. Вы продолжаете этот процесс, пока не зашифруете все ваше открытое сообщение.

По завершении вы отправляете зашифрованное сообщение вместе с незашифрованным вектором инициализации получателю. Получателю необходимо знать вектор инициализации, иначе он не сможет расшифровать шифртекст.

Такая конструкция намного безопаснее, чем режим электронной кодовой книги, при правильном использовании. Во-первых, вы должны убедиться, что вектор инициализации является случайной или псевдослучайной строкой. Кроме того, вы должны использовать разный вектор инициализации каждый раз, когда используете эту схему шифрования.

Другими словами, ваш вектор инициализации должен быть случайным или псевдослучайным одноразовым числом, где **одноразовое число** означает "число, которое используется только один раз". Если вы будете придерживаться этой практики, то режим CBC с блочным шифром обеспечивает, что любые два идентичных блока открытого текста будут зашифрованы по-разному каждый раз.

Наконец, давайте обратим наше внимание на **режим обратной связи по выходу** (**режим OFB**). Вы можете увидеть изображение этого режима на *Рисунке 7*.

*Рисунок 7: Блочный шифр с режимом OFB*

![Рисунок 7: Блочный шифр с режимом OFB](assets/Figure4-7.webp "Рисунок 7: Блочный шифр с режимом OFB")

В режиме OFB вы также выбираете вектор инициализации. Но здесь, для первого блока, вектор инициализации напрямую вставляется в блочный шифр вместе с вашим ключом. Полученные 128 бит затем рассматриваются как ключевой поток. Этот ключевой поток выполняет операцию XOR с открытым текстом для получения шифртекста блока. Для последующих блоков вы используете ключевой поток из предыдущего блока в качестве входных данных в блочный шифр и повторяете шаги.

Если вы внимательно посмотрите, то увидите, что здесь, с использованием режима OFB блочного шифра, на самом деле был создан потоковый шифр. Вы генерируете части ключевого потока размером 128 бит, пока не получите длину открытого текста (отбрасывая биты, которые вам не нужны из последней 128-битной части ключевого потока). Затем вы выполняете операцию XOR ключевого потока с вашим открытым текстом, чтобы получить шифртекст.

В предыдущем разделе о потоковых шифрах я утверждал, что вы производите ключевой поток с помощью закрытого ключа. Точнее, он не обязательно должен быть создан только с закрытым ключом. Как вы можете видеть в режиме OFB, ключевой поток производится с поддержкой как закрытого ключа, так и вектора инициализации.

Обратите внимание, что, как и в режиме CBC, важно выбирать псевдослучайное или случайное одноразовое число для вектора инициализации каждый раз, когда вы используете блочный шифр в режиме OFB. В противном случае одна и та же 128-битная строка сообщения, отправленная в разных сообщениях, будет зашифрована одинаково. Это один из способов создания вероятностного шифрования с потоковым шифром.
Некоторые потоковые шифры используют только закрытый ключ для создания ключевого потока. Для таких потоковых шифров важно использовать случайный nonce для выбора закрытого ключа для каждого случая коммуникации. В противном случае результаты шифрования с помощью этих потоковых шифров также будут детерминированными, что приведет к проблемам безопасности.
Самым популярным современным блочным шифром является **шифр Рейндал**. Он стал победителем среди пятнадцати предложений на конкурсе, проведенном Национальным институтом стандартов и технологий (NIST) между 1997 и 2000 годами с целью замены старого стандарта шифрования, **стандарта шифрования данных** (**DES**).

Шифр Рейндал может использоваться с различными спецификациями длин ключей и размеров блоков, а также в различных режимах работы. Комитет конкурса NIST принял ограниченную версию шифра Рейндал — а именно, ту, которая требует размеров блоков и длин ключей 128 бит, 192 бита или 256 бит — в качестве части **стандарта продвинутого шифрования** (**AES**). Это действительно основной стандарт для приложений симметричного шифрования. Он настолько безопасен, что даже Агентство национальной безопасности якобы готово использовать его с ключами на 256 бит для секретных документов. [6]

Блочный шифр AES будет подробно объяснен в *Главе 5*.

**Примечания:**

[5] Важность вероятностного шифрования впервые была подчеркнута Шафи Голдвассером и Сильвио Микали, "Вероятностное шифрование", _Журнал компьютерных и системных наук_, 28 (1984), 270–99.

[6] См. NSA, "Коммерческий набор алгоритмов национальной безопасности", [https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm](https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm).

## Разъяснение путаницы

Путаница в отличии между блочными шифрами и потоковыми шифрами возникает, потому что иногда люди понимают термин блочный шифр как относящийся специально к *блочному шифру с режимом блочного шифрования*.

Рассмотрим режимы ECB и CBC в предыдущем разделе. Эти режимы конкретно требуют, чтобы данные для шифрования делились на размер блока (что может потребовать использования дополнения для исходного сообщения). Кроме того, данные в этих режимах также обрабатываются блочным шифром напрямую (а не просто сочетаются с результатом операции блочного шифра, как в режиме OFB).

Следовательно, альтернативно, вы можете определить **блочный шифр** как любую схему шифрования, которая работает с фиксированными блоками сообщения за раз (где любой блок должен быть длиннее байта, иначе он превращается в потоковый шифр). И данные для шифрования, и шифртекст должны равномерно делиться на этот размер блока. Обычно размер блока составляет 64, 128, 192 или 256 бит в длину. В отличие от этого, потоковый шифр может шифровать любые сообщения блоками по одному биту или байту за раз.

С этим более конкретным пониманием блочного шифра, вы действительно можете утверждать, что современные схемы шифрования являются либо потоковыми, либо блочными шифрами. Отныне я буду использовать термин блочный шифр в более общем смысле, если не указано иное.
Обсуждение режима OFB в предыдущем разделе также поднимает другой интересный момент. Некоторые потоковые шифры созданы на основе блочных шифров, например, Rijndael с OFB. В то время как такие шифры, как Salsa20 и ChaCha, не созданы из блочных шифров. Последние можно назвать **примитивными потоковыми шифрами**. (На самом деле нет стандартизированного термина для обозначения таких потоковых шифров.)
Когда люди говорят о преимуществах и недостатках потоковых и блочных шифров, они обычно сравнивают примитивные потоковые шифры с схемами шифрования на основе блочных шифров.

Хотя вы всегда можете легко построить потоковый шифр из блочного шифра, обычно очень сложно создать какую-либо конструкцию с режимом блочного шифрования (например, с режимом CBC) из примитивного потокового шифра.

Из этого обсуждения вы теперь должны понимать *Рисунок 8*. Он предоставляет обзор схем симметричного шифрования. Мы используем три вида схем шифрования: примитивные потоковые шифры, потоковые шифры на основе блочных шифров и блочные шифры в режиме блока (также называемые "блочными шифрами" на диаграмме).

*Рисунок 8: Обзор схем симметричного шифрования*

![Рисунок 8: Обзор схем симметричного шифрования](assets/Figure4-8.webp "Рисунок 8: Обзор схем симметричного шифрования")

## Коды аутентификации сообщений
<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>

Шифрование связано с секретностью. Но криптография также занимается более широкими темами, такими как целостность сообщений, аутентичность и невозможность отказа. Так называемые **коды аутентификации сообщений** (MAC) являются симметричными криптографическими схемами, которые поддерживают аутентичность и целостность в коммуникациях.

Почему для коммуникации нужно что-то, кроме секретности? Предположим, что Боб отправляет Алисе сообщение, используя практически непробиваемое шифрование. Любой атакующий, перехвативший это сообщение, не сможет получить значимых сведений о его содержании. Однако атакующий все еще имеет по крайней мере два других вектора атаки:

1. Она может перехватить шифротекст, изменить его содержимое и отправить измененный шифротекст Алисе.
2. Она может полностью заблокировать сообщение Боба и отправить свой собственный созданный шифротекст.

В обоих этих случаях атакующий может не иметь никаких сведений о содержимом из шифротекстов (1) и (2). Но она все равно может нанести значительный ущерб таким образом. Вот здесь и становятся важны коды аутентификации сообщений.

Коды аутентификации сообщений определяются как симметричные криптографические схемы с тремя алгоритмами: алгоритм генерации ключа, алгоритм генерации тега и алгоритм верификации. Безопасный MAC обеспечивает, что теги являются **экзистенциально нефальсифицируемыми** для любого атакующего, то есть они не могут успешно создать тег на сообщение, который проходит проверку, если у них нет приватного ключа.

Боб и Алиса могут бороться с манипуляцией конкретного сообщения, используя MAC. Предположим на момент, что им не важна секретность. Они только хотят убедиться, что сообщение, полученное Алисой, действительно от Боба и не было изменено никаким образом.

Процесс изображен на *Рисунке 9*. Для использования **MAC** (Кода Аутентификации Сообщения) они сначала генерируют приватный ключ $K$, который является общим между ними. Боб создает тег $T$ для сообщения, используя приватный ключ $K$. Затем он отправляет сообщение вместе с тегом сообщения Алисе. Она может затем проверить, что тег действительно сделал Боб, запустив через алгоритм верификации приватный ключ, сообщение и тег.

*Рисунок 9: Обзор схем симметричного шифрования*
![Рисунок 9: Обзор схем симметричного шифрования](assets/Figure4-9.webp "Рисунок 9: Обзор схем симметричного шифрования")
Из-за **невозможности подделки**, атакующий не может изменить сообщение $M$ никаким образом или создать своё сообщение с действительным тегом. Это так, даже если атакующий наблюдает за тегами множества сообщений между Бобом и Алисой, которые используют один и тот же приватный ключ. В лучшем случае, атакующий может помешать Алисе получить сообщение $M$ (проблема, с которой криптография не может справиться).

MAC гарантирует, что сообщение действительно было создано Бобом. Эта подлинность автоматически подразумевает целостность сообщения — то есть, если Боб создал какое-то сообщение, то, ipso facto, оно не было изменено никаким образом атакующим. Таким образом, отныне любая забота об аутентификации должна автоматически подразумевать заботу о целостности.

Хотя я провел различие между подлинностью и целостностью сообщения в своем обсуждении, также обычно эти термины используются как синонимы. Они, таким образом, относятся к идее сообщений, которые были созданы конкретным отправителем и не были изменены никаким образом. В этом духе коды аутентификации сообщений часто также называют **кодами целостности сообщений**.

## Аутентифицированное шифрование
<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>

Обычно вы хотели бы гарантировать как секретность, так и подлинность в коммуникации, и, следовательно, схемы шифрования и схемы MAC обычно используются вместе.

**Схема аутентифицированного шифрования** — это схема, которая сочетает в себе шифрование с MAC высокоуровневым образом. В частности, она должна соответствовать стандартам невозможности подделки, а также очень строгому понятию секретности, а именно, быть устойчивой к **атакам с выбранным шифротекстом**. [7]

Для того чтобы схема шифрования была устойчива к атакам с выбранным шифротекстом, она должна соответствовать стандартам **немодифицируемости**: то есть, любое изменение шифротекста атакующим должно привести либо к недействительному шифротексту, либо к шифротексту, который расшифровывается в текст, не имеющий никакого отношения к оригинальному. [8]

Поскольку схема аутентифицированного шифрования гарантирует, что шифротекст, созданный атакующим, всегда недействителен (поскольку тег не будет проверен), она соответствует стандартам устойчивости к атакам с выбранным шифротекстом. Интересно, что можно доказать, что схема аутентифицированного шифрования всегда может быть создана из комбинации неподдельного MAC и схемы шифрования, которая соответствует менее строгому понятию безопасности, известному как **безопасность перед атакой с выбранным открытым текстом**.

Мы не будем углубляться во все детали создания схем аутентифицированного шифрования. Но важно знать две детали их конструкции.

Во-первых, схема аутентифицированного шифрования сначала обрабатывает шифрование, а затем создает тег сообщения на шифротексте. Оказывается, что другие подходы — такие как объединение шифротекста с тегом на открытом тексте, или сначала создание тега, а затем шифрование как открытого текста, так и тега — небезопасны. Кроме того, для обеих операций используются свои собственные случайно выбранные приватные ключи, иначе ваша безопасность серьезно скомпрометирована.

Упомянутый принцип применим более широко: *вы всегда должны использовать различные ключи при комбинировании базовых криптографических схем*.

Схема аутентифицированного шифрования изображена на *Рисунке 10*. Боб сначала создает шифротекст $C$ из сообщения $M$, используя случайно выбранный ключ $K_C$. Затем он создает тег сообщения $T$, пропустив шифротекст и другой случайно выбранный ключ $K_T$ через алгоритм генерации тега. И шифротекст, и тег сообщения отправляются Алисе.
Алиса теперь сначала проверяет, действителен ли тег, учитывая шифртекст $C$ и ключ $K_T$. Если тег действителен, она может затем расшифровать сообщение, используя ключ $K_C$. Таким образом, она уверена в очень сильном понятии секретности в их коммуникациях, а также знает, что сообщение было создано Бобом.
*Рисунок 10: Схема аутентифицированного шифрования*

![Рисунок 10: Схема аутентифицированного шифрования](assets/Figure4-10.webp "Рисунок 10: Схема аутентифицированного шифрования")

Как создаются MAC (коды аутентификации сообщений)? Хотя MAC могут быть созданы различными методами, общим и эффективным способом их создания является использование **криптографических хеш-функций**.

Мы более подробно рассмотрим криптографические хеш-функции в *Главе 6*. Пока просто знайте, что **хеш-функция** - это эффективно вычисляемая функция, которая принимает на вход данные произвольного размера и выдает результаты фиксированной длины. Например, популярная хеш-функция **SHA-256** (алгоритм безопасного хеширования 256) всегда генерирует 256-битный результат, независимо от размера входных данных. Некоторые хеш-функции, такие как SHA-256, находят полезное применение в криптографии.

Наиболее распространенным типом тега, создаваемым с помощью криптографической хеш-функции, является **хеш-основанный код аутентификации сообщений** (HMAC). Процесс изображен на *Рисунке 11*. Сторона производит два различных ключа из приватного ключа $K$, внутренний ключ $K_1$ и внешний ключ $K_2$. Открытый текст $M$ или шифртекст $C$ затем хешируется вместе с внутренним ключом. Полученный результат $T'$ затем хешируется с внешним ключом для создания тега сообщения $T$.

Существует палитра хеш-функций, которые могут быть использованы для создания HMAC. Наиболее часто используемой хеш-функцией является SHA-256.

*Рисунок 11: HMAC*

![Рисунок 11: HMAC](assets/Figure4-11.webp "Рисунок 11: HMAC")

**Примечания:**

[7] Конкретные результаты, обсуждаемые в этом разделе, взяты из работы Каца и Линделла, стр. 131–47.

[8] Технически, определение атак с выбранным шифртекстом отличается от понятия неизменяемости. Но можно показать, что эти два понятия безопасности эквивалентны.

## Защищенные сессии связи
<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

Предположим, что две стороны находятся в сессии связи, так что они отправляют друг другу множество сообщений.

Схема аутентифицированного шифрования позволяет получателю сообщения проверить, что оно было создано его партнером в сессии связи (до тех пор, пока приватный ключ не был скомпрометирован). Это работает достаточно хорошо для одного сообщения. Однако, как правило, две стороны отправляют сообщения туда и обратно в сессии связи. И в этой ситуации простая схема аутентифицированного шифрования, описанная в предыдущем разделе, не обеспечивает достаточной безопасности.

Основная причина заключается в том, что схема аутентифицированного шифрования не дает никаких гарантий, что сообщение действительно было отправлено агентом, который его создал, в рамках сессии связи. Рассмотрим следующие три вектора атаки:

1. **Атака повторного воспроизведения**: Атакующий пересылает шифртекст и тег, которые он перехватил между двумя сторонами на более раннем этапе.
2. **Атака перестановки**: Атакующий перехватывает два сообщения в разное время и отправляет их получателю в обратном порядке.
3. **Атака отражения**: Атакующий наблюдает за сообщением, отправленным от А к Б, и также отправляет это сообщение А.

Хотя атакующий не имеет знаний о шифртексте и не может создать поддельные шифртексты, вышеупомянутые атаки все же могут нанести значительный ущерб коммуникациям.
Предположим, например, что конкретное сообщение между двумя сторонами включает в себя перевод финансовых средств. Атака повторного воспроизведения может осуществить перевод средств второй раз. Простая схема аутентифицированного шифрования не имеет защиты от таких атак.
К счастью, такие виды атак могут быть легко предотвращены в сессии коммуникации с использованием **идентификаторов** и **относительных временных индикаторов**.

Идентификаторы могут быть добавлены к открытому тексту сообщения перед шифрованием. Это предотвратит любые атаки отражения. Относительный временной индикатор может, например, быть порядковым номером в определенной сессии коммуникации. Каждая сторона добавляет порядковый номер к сообщению перед шифрованием, так что получатель знает, в каком порядке сообщения были отправлены. Это исключает возможность атак переупорядочивания. Также это исключает атаки повторного воспроизведения. Любое сообщение, которое атакующий отправляет по линии, будет иметь старый порядковый номер, и получатель будет знать, что не следует обрабатывать сообщение снова.

Чтобы проиллюстрировать, как работают защищенные сессии коммуникации, предположим снова Алису и Боба. Они отправляют в общей сложности четыре сообщения туда и обратно. Вы можете увидеть, как работает схема аутентифицированного шифрования с идентификаторами и порядковыми номерами ниже на *Рисунке 11*.

Сессия коммуникации начинается с того, что Боб отправляет Алисе зашифрованный текст $C_{0,B}$ с тегом сообщения $T_{0,B}$. Зашифрованный текст содержит сообщение, а также идентификатор (BOB) и порядковый номер (0). Тег $T_{0,B}$ создается для всего зашифрованного текста. В последующих коммуникациях Алиса и Боб поддерживают этот протокол, обновляя поля по мере необходимости.

*Рисунок 12: Защищенная сессия коммуникации*

![Рисунок 12: Защищенная сессия коммуникации](assets/Figure4-12.webp "Рисунок 12: Защищенная сессия коммуникации")

# RC4 и AES
<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

## Потоковый шифр RC4
<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>

В этой главе мы обсудим детали схемы шифрования с современным примитивным потоковым шифром, RC4 (или "шифр Ривеста 4"), и современным блочным шифром, AES. Хотя шифр RC4 вышел из употребления как метод шифрования, AES является стандартом для современного симметричного шифрования. Эти два примера должны дать лучшее представление о том, как работает симметричное шифрование изнутри.

___

Чтобы иметь представление о том, как работают современные псевдослучайные потоковые шифры, я сосредоточусь на потоковом шифре RC4. Это псевдослучайный потоковый шифр, который использовался в протоколах безопасности беспроводных точек доступа WEP и WAP, а также в TLS. Поскольку у RC4 есть множество доказанных слабостей, он вышел из употребления. Фактически, Инженерный совет Интернета теперь запрещает использование наборов RC4 клиентскими и серверными приложениями во всех случаях TLS. Тем не менее, он хорошо служит примером для иллюстрации работы примитивного потокового шифра.

Для начала я покажу, как зашифровать открытый текстовый сообщение с помощью упрощенного шифра RC4. Предположим, наше открытый текстовое сообщение — «SOUP». Шифрование с нашим упрощенным шифром RC4, следовательно, происходит в четыре этапа.

### Шаг 1
Сначала определите массив **S** с $S[0] = 0$ до $S[7] = 7$. Здесь массив просто означает изменяемую коллекцию значений, организованных по индексу, также называемую списком в некоторых языках программирования (например, Python). В данном случае индекс идет от 0 до 7, а значения также идут от 0 до 7. Таким образом, **S** выглядит следующим образом:
- $S = [0, 1, 2, 3, 4, 5, 6, 7]$

Здесь значения не являются ASCII-числами, а представлениями десятичных значений 1-байтовых строк. Так что значение 2 будет равно $0000 \ 0011$. Длина массива **S**, таким образом, составляет 8 байт.

### Шаг 2

Во-вторых, определите массив ключей **K** длиной 8 байт, выбрав ключ между 1 и 8 байтами (доли байтов недопустимы). Поскольку каждый байт состоит из 8 бит, вы можете выбрать любое число между 0 и 255 для каждого байта вашего ключа.

Предположим, мы выбрали наш ключ **k** как $[14, 48, 9]$, так что его длина составляет 3 байта. Каждый индекс нашего массива ключей, таким образом, устанавливается в соответствии с десятичным значением для этого конкретного элемента ключа, по порядку. Если вы пройдете через весь ключ, начните снова с начала, пока не заполните 8 слотов массива ключей. Таким образом, наш массив ключей следующий:

- $K = [14, 48, 9, 14, 48, 9, 14, 48]$

### Шаг 3

В-третьих, мы будем трансформировать массив **S** с использованием массива ключей **K** в процессе, известном как **планирование ключа**. Процесс следующий в псевдокоде:

- Создайте переменные **j** и **i**
- Установите переменную $j = 0$
- Для каждого $i$ от 0 до 7:
    - Установите $j = (j + S[i] + K[i]) \mod 8$
    - Поменяйте местами $S[i]$ и $S[j]$

Трансформация массива **S** отображена в *Таблице 1*.

Для начала вы можете увидеть исходное состояние **S** как $[0, 1, 2, 3, 4, 5, 6, 7]$ с начальным значением 0 для **j**. Это будет трансформировано с использованием массива ключей $[14, 48, 9, 14, 48, 9, 14, 48]$.

Цикл for начинается с $i = 0$. Согласно нашему псевдокоду выше, новое значение **j** становится 6 ($j = (j + S[0] + K[0]) \mod 8 = (0 + 0 + 14) \mod 8 = 6 \mod 8$). Поменяв местами $S[0]$ и $S[6]$, состояние **S** после 1 раунда становится $[6, 1, 2, 3, 4, 5, 0, 7]$.
В следующей строке, $i = 1$. Проходя через цикл for снова, **j** получает значение 7 ($j = (j + S[1] + K[1]) \mod 8 = (6 + 1 + 48) \mod 8 = 55 \mod 8 = 7 \mod 8$). Поменяв местами $S[1]$ и $S[7]$ в текущем состоянии **S**, $[6, 1, 2, 3, 4, 5, 0, 7]$, получаем $[6, 7, 2, 3, 4, 5, 0, 1]$ после второго раунда.
Мы продолжаем этот процесс до тех пор, пока не получим последнюю строку внизу для массива **S**, $[6, 4, 1, 0, 3, 7, 5, 2]$.

*Таблица 1: Таблица планирования ключей*

| Раунд   | i   | j   |     | S[0] | S[1] | S[2] | S[3] | S[4] | S[5] | S[6] | S[7] |
| ------- | --- | --- | --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|         |     |     |     |      |      |      |      |      |      |      |      |
| Начальный |     | 0   |     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| 1       | 0   | 6   |     | 6    | 1    | 2    | 3    | 4    | 5    | 0    | 7    |
| 2       | 1   | 7   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 3       | 2   | 2   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 4       | 3   | 3   |     | 6    | 7    | 2    | 3    | 4    | 5    | 0    | 1    |
| 5       | 4   | 3   |     | 6    | 7    | 2    | 0    | 3    | 5    | 4    | 1    |
| 6       | 5   | 6   |     | 6    | 4    | 2    | 0    | 3    | 7    | 5    | 1    |
| 7       | 6   | 1   |     | 6    | 4    | 2    | 0    | 3    | 7    | 5    | 2    |
| 8       | 7   | 2   |     | 6    | 4    | 1    | 0    | 3    | 7    | 5    | 2    |

### Шаг 4
На четвертом шаге мы производим **ключевой поток (keystream)**. Это псевдослучайная строка длиной, равной сообщению, которое мы хотим отправить. Она будет использоваться для шифрования исходного сообщения "SOUP". Поскольку ключевой поток должен быть такой же длины, как сообщение, нам нужен такой, который имеет 4 байта.
Ключевой поток производится следующим псевдокодом:

- Создайте переменные **j**, **i** и **t**.
- Установите $j = 0$.
- Для каждого $i$ открытого текста, начиная с $i = 1$ и до $i = 4$, каждый байт ключевого потока производится следующим образом:
    - $j = (j + S[i]) \mod 8$
    - Поменяйте местами $S[i]$ и $S[j]$.
    - $t = (S[i] + S[j]) \mod 8$
    - $i$-ый байт ключевого потока = $S[t]$

Вы можете следить за расчетами в *Таблице 2*.

Исходное состояние **S** это $S = [6, 4, 1, 0, 3, 7, 5, 2]$. Установив $i = 1$, значение **j** становится 4 ($j = (j + S[i]) \mod 8 = (0 + 4) \mod 8 = 4$). Затем мы меняем местами $S[1]$ и $S[4]$, чтобы получить преобразование **S** во второй строке, $[6, 3, 1, 0, 4, 7, 5, 2]$. Значение **t** затем становится 7 ($t = (S[i] + S[j]) \mod 8 = (3 + 4) \mod 8 = 7$). Наконец, байт для ключевого потока это $S[7]$, или 2.

Затем мы продолжаем производить другие байты, пока у нас не будет следующих четырех байтов: 2, 6, 3 и 7. Каждый из этих байтов затем может быть использован для шифрования каждой буквы открытого текста, "SOUP".

Для начала, используя таблицу ASCII, мы видим, что “SOUP”, закодированное десятичными значениями соответствующих байтовых строк, это “83 79 85 80”. Комбинация с ключевым потоком “2 6 3 7” дает “85 85 88 87”, что остается неизменным после операции модуля 256. В ASCII шифротекст “85 85 88 87” равен “UUXW”.

Что произойдет, если слово для шифрования будет длиннее массива **S**? В этом случае массив **S** просто продолжает трансформироваться таким образом, как показано выше, для каждого байта **i** открытого текста, пока количество байтов в ключевом потоке не станет равным количеству букв в открытом тексте.

*Таблица 2: Генерация ключевого потока*

| i   | j   | t   | Ключевой поток | S[0] | S[1] | S[2] | S[3] | S[4] | S[5] | S[6] | S[7] |
| --- | --- | --- | -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|     | 0   |     |           | 6    | 4    | 1    | 0    | 3    | 7    | 5    | 2    || 1   | 4   | 7   | 2         | 6    | 3    | 1    | 0    | 4    | 7    | 5    | 2    |
| 2   | 5   | 0   | 6         | 6    | 3    | 7    | 0    | 4    | 1    | 5    | 2    |
| 3   | 5   | 1   | 3         | 6    | 3    | 7    | 1    | 4    | 0    | 5    | 2    |
| 4   | 1   | 7   | 2         | 6    | 4    | 7    | 1    | 3    | 0    | 5    | 2    |

Приведенный пример является упрощенной версией **потокового шифра RC4**. Фактический потоковый шифр RC4 использует массив **S** длиной 256 байт, а не 8 байт, и ключ может быть длиной от 1 до 256 байт, а не от 1 до 8 байт. Массив ключей и ключевые потоки затем создаются с учетом длины массива **S** в 256 байт. Расчеты становятся значительно сложнее, но принципы остаются теми же. Используя тот же ключ, [14,48,9], со стандартным шифром RC4, открытый текст "SOUP" шифруется как 67 02 ed df в шестнадцатеричном формате.

Потоковый шифр, в котором ключевой поток обновляется независимо от открытого текста или шифртекста, является **синхронным потоковым шифром**. Ключевой поток зависит только от ключа. Очевидно, RC4 является примером синхронного потокового шифра, так как ключевой поток не имеет отношения к открытому тексту или шифртексту. Все наши примитивные потоковые шифры, упомянутые в предыдущей главе, включая шифр сдвига, шифр Виженера и одноразовый блокнот, также относились к синхронному типу.

В отличие от этого, **асинхронный потоковый шифр** имеет ключевой поток, который производится как ключом, так и предыдущими элементами шифртекста. Этот тип шифра также называется **самосинхронизирующимся шифром**.

Важно, что ключевой поток, произведенный с использованием RC4, следует рассматривать как одноразовый блокнот, и вы не можете произвести ключевой поток точно таким же образом в следующий раз. Вместо изменения ключа каждый раз, практическое решение заключается в сочетании ключа с **nonce** для производства байтового потока.

## AES с 128-битным ключом
<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

Как упоминалось в предыдущей главе, Национальный институт стандартов и технологий (NIST) провел соревнование между 1997 и 2000 годами, чтобы определить новый стандарт симметричного шифрования. **Шифр Рейндал** оказался победителем. Название является игрой слов на именах бельгийских создателей, Винсента Реймена и Йоана Даемена.
Шифр Рейндал (Rijndael) является **блочным шифром**, что означает наличие базового алгоритма, который может использоваться с различными спецификациями длин ключей и размеров блоков. Затем его можно использовать с различными режимами работы для создания схем шифрования.
Комитет конкурса NIST принял ограниченную версию шифра Рейндал — а именно ту, которая требует размеров блоков и длин ключей 128 бит, 192 бита или 256 бит — в качестве части **Стандарта Авансированного Шифрования (AES)**. Эта ограниченная версия шифра Рейндал также может использоваться в нескольких режимах работы. Спецификация стандарта известна как **Стандарт Авансированного Шифрования (AES)**.

Чтобы показать, как работает шифр Рейндал, ядро AES, я проиллюстрирую процесс шифрования с 128-битным ключом. Размер ключа влияет на количество раундов, проводимых для каждого блока шифрования. Для ключей 128 бит требуется 10 раундов. Для 192 и 256 бит это было бы 12 и 14 раундов соответственно.

Кроме того, я предположу, что AES используется в **режиме ECB**. Это немного упрощает изложение и не имеет значения для алгоритма Рейндал. Надо быть уверенным, режим ECB на практике не является безопасным, поскольку приводит к детерминированному шифрованию. Наиболее часто используемый безопасный режим с AES — **CBC** (Cipher Block Chaining).

Давайте назовем ключ $K_0$. Конструкция с вышеупомянутыми параметрами выглядит, как на *Рисунке 1*, где $M_i$ обозначает часть открытого текста размером 128 бит и $C_i$ — часть шифртекста размером 128 бит. Если открытый текст не может быть равномерно разделен на размер блока, к последнему блоку добавляется дополнение.


*Рисунок 1: AES-ECB с 128-битным ключом*

![Рисунок 1: AES-ECB с 128-битным ключом](assets/Figure5-1.webp "Рисунок 1: AES-ECB с 128-битным ключом")

Каждый 128-битный блок текста проходит через десять раундов в схеме шифрования Рейндал. Это требует отдельного раундового ключа для каждого раунда ($K_1$ до $K_{10}$). Эти ключи производятся для каждого раунда из исходного 128-битного ключа $K_0$ с использованием **алгоритма расширения ключа**. Таким образом, для каждого блока текста, который нужно зашифровать, мы будем использовать исходный ключ $K_0$, а также десять отдельных раундовых ключей. Обратите внимание, что эти же 11 ключей используются для каждого 128-битного блока открытого текста, который требует шифрования.

Алгоритм расширения ключа длинный и сложный. Разбираться в нем имеет мало учебной пользы. Вы можете самостоятельно ознакомиться с алгоритмом расширения ключа, если хотите. Как только раундовые ключи произведены, шифр Рейндал будет манипулировать первым 128-битным блоком открытого текста, $M_1$, как видно на *Рисунке 2*. Теперь мы рассмотрим эти шаги.

*Рисунок 2: Манипуляция $M_1$ с помощью шифра Рейндал:*

**Раунд 0:**
- XOR $M_1$ и $K_0$ для получения $S_0$

---

**Раунд n для n = {1,...,9}:**
- XOR $S_{n-1}$ и $K_n$
- Подстановка байтов
- Сдвиг строк
- Смешивание столбцов
- XOR $S$ и $K_n$ для получения $S_n$

---

**Раунд 10:**
- XOR $S_9$ и $K_{10}$ - Подстановка байтов
- Сдвиг строк
- XOR $S$ и $K_{10}$ для получения $S_{10}$
- $S_{10}$ = $C_1$

### Раунд 0

Раунд 0 шифра Рейндала прост. Массив $S_0$ получается в результате операции XOR между 128-битным открытым текстом и закрытым ключом. То есть,

- $S_0 = M_1 \oplus K_0$

### Раунд 1

В раунде 1 массив $S_0$ сначала комбинируется с ключом раунда $K_1$ с использованием операции XOR. Это приводит к новому состоянию $S$.

Во-вторых, выполняется операция **подстановки байтов** на текущем состоянии $S$. Она работает, беря каждый байт из 16-байтового массива $S$ и подставляя его на байт из массива, называемого **S-бокс Рейндала**. Каждый байт имеет уникальное преобразование, и в результате производится новое состояние $S$. S-бокс Рейндала показан на *Рисунке 3*.

*Рисунок 3: S-бокс Рейндала*

|     | 00  | 01  | 02  | 03  | 04  | 05  | 06  | 07  | 08  | 09  | 0A  | 0B  | 0C  | 0D  | 0E  | 0F  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 00  | 63  | 7C  | 77  | 7B  | F2  | 6B  | 6F  | C5  | 30  | 01  | 67  | 2B  | FE  | D7  | AB  | 76  |
| 10  | CA  | 82  | C9  | 7D  | FA  | 59  | 47  | F0  | AD  | D4  | A2  | AF  | 9C  | A4  | 72  | C0  |
| 20  | B7  | FD  | 93  | 26  | 36  | 3F  | F7  | CC  | 34  | A5  | E5  | F1  | 71  | D8  | 31  | 15  |
| 30  | 04  | C7  | 23  | C3  | 18  | 96  | 05  | 9A  | 07  | 12  | 80  | E2  | EB  | 27  | B2  | 75  |
| 40  | 09  | 83  | 2C  | 1A  | 1B  | 6E  | 5A  | A0  | 52  | 3B  | D6  | B3  | 29  | E3  | 2F  | 84  |
| 50  | 53  | D1  | 00  | ED  | 20  | FC  | B1  | 5B  | 6A  | CB  | BE  | 39  | 4A  | 4C  | 58  | CF  || 60  | D0  | EF  | AA  | FB  | 43  | 4D  | 33  | 85  | 45  | F9  | 02  | 7F  | 50  | 3C  | 9F  | A8  |
| 70  | 51  | A3  | 40  | 8F  | 92  | 9D  | 38  | F5  | BC  | B6  | DA  | 21  | 10  | FF  | F3  | D2  |
| 80  | CD  | 0C  | 13  | EC  | 5F  | 97  | 44  | 17  | C4  | A7  | 7E  | 3D  | 64  | 5D  | 19  | 73  |
| 90  | 60  | 81  | 4F  | DC  | 22  | 2A  | 90  | 88  | 46  | EE  | B8  | 14  | DE  | 5E  | 0B  | DB  |
| A0  | E0  | 32  | 3A  | 0A  | 49  | 06  | 24  | 5C  | C2  | D3  | AC  | 62  | 91  | 95  | E4  | 79  |
| B0  | E7  | C8  | 37  | 6D  | 8D  | D5  | 4E  | A9  | 6C  | 56  | F4  | EA  | 65  | 7A  | AE  | 08  |
| C0  | BA  | 78  | 25  | 2E  | 1C  | A6  | B4  | C6  | E8  | DD  | 74  | 1F  | 4B  | BD  | 8B  | 8A  |
| D0  | 70  | 3E  | B5  | 66  | 48  | 03  | F6  | 0E  | 61  | 35  | 57  | B9  | 86  | C1  | 1D  | 9E  |
| E0  | E1  | F8  | 98  | 11  | 69  | D9  | 8E  | 94  | 9B  | 1E  | 87  | E9  | CE  | 55  | 28  | DF  |
| F0  | 8C  | A1  | 89  | 0D  | BF  | E6  | 42  | 68  | 41  | 99  | 2D  | 0F  | B0  | 54  | BB  | 16  |

Этот S-Box - это одно из мест, где абстрактная алгебра находит применение в шифре Рижндаль, в частности **поля Галуа**.

Для начала вы определяете каждый возможный байтовый элемент от 00 до FF как 8-битный вектор. Каждый такой вектор является элементом **поля Галуа GF(2^8)**, где неприводимый многочлен для операции модуло - это $x^8 + x^4 + x^3 + x + 1$. Поле Галуа с этими спецификациями также называется **конечным полем Рижндаля**.

Далее, для каждого возможного элемента в поле, мы создаем то, что называется **S-Box Ниберга**. В этом боксе каждый байт отображается на его **мультипликативный обратный** (т.е. так, чтобы их произведение равнялось 1). Затем мы отображаем эти значения из S-Box Ниберга в S-Box Рижндаля, используя **аффинное преобразование**.

Третья операция над массивом **S** - это операция **сдвига строк**. Она берет состояние **S** и выставляет все шестнадцать байтов в матрицу. Заполнение матрицы начинается с верхнего левого угла и продвигается вокруг, идя сверху вниз, а затем, каждый раз когда колонка заполнена, сдвигаясь на одну колонку вправо и вверх.

Как только матрица **S** построена, четыре строки сдвигаются. Первая строка остается на месте. Вторая строка перемещается на одну влево. Третья перемещается на две влево. Четвертая перемещается на три влево. Пример процесса представлен на *Рисунке 4*. Исходное состояние **S** показано сверху, а результативное состояние после операции сдвига строк показано ниже.

*Рисунок 4: Операция сдвига строк*

| F1   | A0   | B1   | 23   |
|------|------|------|------|
| 59   | EF   | 09   | 82   |
| 97   | 01   | B0   | CC   |
| D4   | 72   | 04   | 21   |

| F1   | A0   | B1   | 23   |
|------|------|------|------|
| EF   | 09   | 82   | 59   |
| B0   | CC   | 97   | 01   |
| 21   | D4   | 72   | 04   |


На четвертом этапе **поля Галуа** снова играют роль. Для начала, каждая колонка матрицы **S** умножается на колонку матрицы 4 x 4, видимой на *Рисунке 5*. Но вместо обычного умножения матриц, это векторное умножение **по модулю неприводимого многочлена**, $x^8 + x^4 + x^3 + x + 1$. Результирующие коэффициенты вектора представляют отдельные биты байта.

*Рисунок 5: Матрица смешивания столбцов*

| 02   | 03   | 01   | 01   |
|------|------|------|------|
| 01   | 02   | 03   | 01   |
| 01   | 01   | 02   | 03   || 03   | 01   | 01   | 02   |

Умножение первого столбца матрицы **S** на матрицу 4 x 4 выше приводит к результату на *Рисунке 6*.

*Рисунок 6: Умножение первого столбца:*

$$
\begin{matrix}
02 \cdot F1 + 03 \cdot EF + 01 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 02 \cdot EF + 03 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 01 \cdot EF + 02 \cdot B0 + 03 \cdot 21 \\
03 \cdot F1 + 01 \cdot EF + 01 \cdot B0 + 02 \cdot 21
\end{matrix}
$$

На следующем этапе все члены матрицы должны быть преобразованы в полиномы. Например, F1 представляет 1 байт и станет $x^7 + x^6 + x^5 + x^4 + 1$, а 03 представляет 1 байт и станет $x + 1$.

Затем все умножения выполняются **по модулю** $x^8 + x^4 + x^3 + x + 1$. Это приводит к сложению четырех полиномов в каждой из четырех ячеек столбца. После выполнения этих сложений **по модулю 2**, вы получите четыре полинома. Каждый из этих полиномов представляет 8-битную строку или 1 байт **S**. Мы не будем выполнять все эти расчеты здесь для матрицы на *Рисунке 6*, поскольку они обширны.

После обработки первого столбца, другие три столбца матрицы **S** обрабатываются аналогичным образом. В конечном итоге это приведет к матрице из шестнадцати байтов, которую можно преобразовать в массив.

На последнем этапе массив **S** снова комбинируется с ключом раунда в операции **XOR**. Это производит состояние $S_1$. То есть,

- $S_1 = S \oplus K_0$

### Раунды 2 по 10

Раунды с 2 по 9 являются просто повторением раунда 1, *mutatis mutandis*. Финальный раунд выглядит очень похоже на предыдущие раунды, за исключением того, что шаг **смешивания столбцов** убирается. То есть, раунд 10 выполняется следующим образом:

- $S_9 \oplus K_{10}$
- Замена байтов
- Сдвиг строк
- $S_{10} = S \oplus K_{10}$

Состояние $S_{10}$ теперь установлено как $C_1$, первые 128 бит шифртекста. Прохождение через оставшиеся блоки открытого текста размером 128 бит дает полный шифртекст **C**.

### Операции шифра Рижндаль

Какова логика различных операций, наблюдаемых в шифре Рижндаль?

Не вдаваясь в подробности, схемы шифрования оцениваются на основе степени, в которой они создают путаницу и диффузию. Если у схемы шифрования высокая степень **путаницы**, это означает, что шифртекст сильно отличается от открытого текста. Если у схемы шифрования высокая степень **диффузии**, это означает, что любое небольшое изменение в открытом тексте производит сильно отличающийся шифртекст.
Основание для операций, лежащих в основе шифра Рейндал, заключается в том, что они обеспечивают высокую степень путаницы и диффузии. Путаница создается операцией замены байтов, в то время как диффузия достигается за счет операций сдвига строк и перемешивания столбцов.
# Асимметричная криптография
<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

## Проблема распределения и управления ключами
<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

Как и в случае с симметричной криптографией, асимметричные схемы могут использоваться для обеспечения как секретности, так и аутентификации. Однако, в отличие от них, эти схемы используют два ключа вместо одного: приватный и публичный.

Мы начинаем наше исследование с открытия асимметричной криптографии, в частности, с проблем, которые сподвигли к ее разработке. Затем мы обсуждаем, как на высоком уровне работают асимметричные схемы шифрования и аутентификации. После этого мы вводим хеш-функции, которые ключевы для понимания асимметричных схем аутентификации и также имеют значение в других криптографических контекстах, например, для хеш-основанных кодов аутентификации сообщений, обсуждаемых в главе 4.

___

Предположим, что Боб хочет купить новый дождевик в интернет-магазине спортивных товаров Jim’s Sporting Goods, который имеет миллионы клиентов в Северной Америке. Это будет его первая покупка у них, и он хочет использовать свою кредитную карту. Сначала Бобу нужно будет создать аккаунт в Jim’s Sporting Goods, что требует отправки личных данных, таких как его адрес и информация о кредитной карте. Затем он может пройти через необходимые шаги для покупки дождевика.

Боб и Jim’s Sporting Goods захотят убедиться, что их коммуникация защищена на протяжении всего процесса, учитывая, что Интернет является открытой системой связи. Например, они захотят убедиться, что никакой потенциальный злоумышленник не сможет узнать детали кредитной карты и адреса Боба, а также что никто не сможет повторить его покупки или создать фальшивые от его имени.

Продвинутая схема аутентифицированного шифрования, обсуждаемая в предыдущей главе, определенно могла бы сделать коммуникацию между Бобом и Jim’s Sporting Goods безопасной. Но очевидно существуют практические препятствия для реализации такой схемы.

Чтобы проиллюстрировать эти практические препятствия, предположим, что мы живем в мире, где существуют только инструменты симметричной криптографии. Что могли бы сделать Jim’s Sporting Goods и Боб, чтобы обеспечить безопасную коммуникацию?

В этих условиях они столкнулись бы с значительными затратами на обеспечение безопасной коммуникации. Поскольку Интернет является открытой системой связи, они не могут просто обменяться набором ключей через него. Следовательно, Бобу и представителю Jim’s Sporting Goods придется осуществить обмен ключами лично.

Одним из вариантов может быть создание Jim’s Sporting Goods специальных мест для обмена ключами, где Боб и другие новые клиенты могут получить набор ключей для безопасной коммуникации. Очевидно, это потребовало бы значительных организационных затрат и сильно снизило бы эффективность, с которой новые клиенты могут совершать покупки.

В качестве альтернативы, Jim’s Sporting Goods может отправить Бобу пару ключей с помощью высоко доверенного курьера. Это, вероятно, более эффективно, чем организация мест для обмена ключами. Но это все равно потребует значительных затрат, особенно если многие клиенты совершают только одну или несколько покупок.

Далее, симметричная схема аутентифицированного шифрования также заставляет Jim’s Sporting Goods хранить отдельные наборы ключей для всех своих клиентов. Это была бы значительная практическая проблема для тысяч клиентов, не говоря уже о миллионах.
Чтобы понять этот последний пункт, представим, что магазин спортивных товаров Джима предоставляет каждому клиенту одну и ту же пару ключей. Это позволило бы каждому клиенту — или любому другому, кто мог бы получить эту пару ключей — читать и даже манипулировать всеми коммуникациями между магазином спортивных товаров Джима и его клиентами. Тогда можно было бы вообще не использовать криптографию в ваших коммуникациях.
Даже повторное использование набора ключей для некоторых клиентов является ужасной практикой безопасности. Любой потенциальный атакующий мог бы попытаться использовать эту особенность схемы (помните, что предполагается, что атакующие знают все о схеме, кроме ключей, в соответствии с принципом Керкгоффса).

Таким образом, магазину спортивных товаров Джима пришлось бы хранить пару ключей для каждого клиента, независимо от того, как эти пары ключей распределяются. Это явно представляет несколько практических проблем.

- Магазину спортивных товаров Джима пришлось бы хранить миллионы пар ключей, один набор для каждого клиента.
- Эти ключи необходимо было бы надежно защитить, поскольку они были бы верной целью для хакеров. Любые нарушения безопасности потребовали бы повторения дорогостоящих обменов ключами, либо в специальных местах обмена ключами, либо курьером.
- Любой клиент магазина спортивных товаров Джима должен был бы безопасно хранить пару ключей дома. Потери и кражи будут происходить, требуя повторения обменов ключами. Клиентам также пришлось бы проходить этот процесс для любых других интернет-магазинов или других типов сущностей, с которыми они хотели бы общаться и совершать транзакции через Интернет.

Эти две основные проблемы, о которых только что шла речь, были очень фундаментальными до конца 1970-х годов. Они были известны как **проблема распределения ключей** и **проблема управления ключами** соответственно.

Эти проблемы всегда существовали, конечно, и часто вызывали головную боль в прошлом. Например, военные силы должны были постоянно распространять книги с ключами для безопасной связи среди персонала на поле боя с большими рисками и затратами. Но эти проблемы усугублялись, поскольку мир все больше переходил к дальней, цифровой коммуникации, особенно для неправительственных сущностей.

Если бы эти проблемы не были решены в 1970-х годах, эффективные и безопасные покупки в магазине спортивных товаров Джима, вероятно, не существовали бы. Фактически, большая часть нашего современного мира с практичной и безопасной электронной почтой, онлайн-банкингом и покупками, вероятно, была бы всего лишь далекой фантазией. Что-то даже напоминающее Bitcoin вообще не могло бы существовать.

Так что же произошло в 1970-х годах? Как возможно, что мы можем мгновенно совершать покупки в Интернете и безопасно просматривать Всемирную паутину? Как возможно, что мы можем мгновенно отправлять Bitcoin по всему миру со своих смартфонов?

## Новые направления в криптографии
<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

К 1970-м годам проблемы распределения и управления ключами привлекли внимание группы американских академических криптографов: Уитфилда Диффи, Мартина Хеллмана и Ральфа Меркля. Несмотря на серьезный скептицизм со стороны большинства их коллег, они решили найти решение этой проблемы.

По крайней мере одной из основных мотиваций их начинания было предвидение, что открытые компьютерные коммуникации глубоко повлияют на наш мир. Как отмечают Диффи и Хеллман в 1976 году,
Развитие компьютерных коммуникационных сетей обещает легкий и недорогой контакт между людьми или компьютерами на противоположных сторонах мира, заменяя большинство почтовых отправлений и многие поездки телекоммуникациями. Для многих приложений эти контакты должны быть защищены как от подслушивания, так и от внедрения нелегитимных сообщений. Однако на данный момент решение проблем безопасности значительно отстает от других областей технологии связи. *Современная криптография не способна удовлетворить требованиям, поскольку ее использование наложило бы такие серьезные неудобства на пользователей системы, что многие преимущества телепроцессинга были бы утрачены.* [1]

Упорство Диффи, Хеллмана и Меркла окупилось. Первая публикация их результатов была статьей Диффи и Хеллмана в 1976 году под названием "Новые направления в криптографии". В ней они представили два оригинальных способа решения проблем распределения ключей и управления ключами.

Первое решение, которое они предложили, было протоколом *обмена ключами на расстоянии*, то есть набором правил для обмена одним или несколькими симметричными ключами по незащищенному каналу связи. Этот протокол теперь известен как *обмен ключами Диффи-Хеллмана* или *обмен ключами Диффи-Хеллмана-Меркла*. [2]

С помощью обмена ключами Диффи-Хеллмана две стороны сначала обмениваются некоторой информацией публично по незащищенному каналу, такому как Интернет. На основе этой информации они затем независимо создают симметричный ключ (или пару симметричных ключей) для безопасного общения. Хотя обе стороны создают свои ключи независимо, обмененная публично информация обеспечивает, что процесс создания ключа приведет к одинаковому результату для обеих сторон.

Важно, что, хотя любой может наблюдать за информацией, которая обменивается публично сторонами по незащищенному каналу, только две стороны, участвующие в обмене информацией, могут создать симметричные ключи из нее.

Это, конечно, звучит совершенно контринтуитивно. Как две стороны могут обменяться некоторой информацией публично, которая позволит только им создать симметричные ключи из нее? Почему кто-то другой, наблюдающий за обменом информацией, не сможет создать те же ключи?

Это, конечно, основывается на некоторой прекрасной математике. Обмен ключами Диффи-Хеллмана работает через однонаправленную функцию с лазейкой. Давайте обсудим значение этих двух терминов по очереди.

Предположим, что вам дана некоторая функция $f(x)$ и результат $f(a) = y$, где $a$ - это конкретное значение для $x$. Мы говорим, что $f(x)$ является **однонаправленной функцией**, если легко вычислить значение $y$, имея $a$ и $f(x)$, но вычислить значение $a$, имея $y$ и $f(x)$, вычислительно невозможно. Название **однонаправленная функция**, конечно, происходит от того факта, что такую функцию практично вычислить только в одном направлении.

Некоторые однонаправленные функции имеют то, что называется **лазейкой**. Хотя практически невозможно вычислить $a$, имея только $y$ и $f(x)$, существует определенная информация $Z$, которая делает вычисление $a$ из $y$ вычислительно выполнимым. Эта информация $Z$ известна как **лазейка**. Однонаправленные функции, имеющие лазейку, известны как **функции с лазейкой**.
Мы не будем углубляться в детали обмена ключами Диффи-Хеллмана здесь. Но в сущности каждый участник создает некоторую информацию, часть которой делится публично, а некоторая остается секретной. Затем каждая сторона берет свою секретную часть информации и публичную информацию, предоставленную другой стороной, чтобы создать приватный ключ. И довольно удивительно, обе стороны в итоге получают один и тот же приватный ключ.
Любая сторона, наблюдающая только за публично обмененной информацией между двумя сторонами в обмене ключами Диффи-Хеллмана, не сможет воспроизвести эти вычисления. Для этого им понадобится приватная информация одной из двух сторон.

Хотя базовая версия обмена ключами Диффи-Хеллмана, представленная в статье 1976 года, не очень безопасна, более сложные версии базового протокола определенно используются и сегодня. Что наиболее важно, каждый протокол обмена ключами в последней версии протокола безопасности транспортного уровня (версия 1.3) по сути является обогащенной версией протокола, представленного Диффи и Хеллманом в 1976 году. Протокол безопасности транспортного уровня является ведущим протоколом для безопасного обмена информацией, форматированной в соответствии с протоколом передачи гипертекста (http), стандартом для обмена веб-контентом.

Важно, что обмен ключами Диффи-Хеллмана не является асимметричной схемой. Строго говоря, он, возможно, относится к области криптографии с симметричным ключом. Но поскольку и обмен ключами Диффи-Хеллмана, и асимметричная криптография опираются на однонаправленные функции теории чисел с ловушками, они обычно обсуждаются вместе.

Второй способ, который Диффи и Хеллман предложили для решения проблемы распределения и управления ключами в своей статье 1976 года, был, конечно, через асимметричную криптографию.

В отличие от их представления обмена ключами Диффи-Хеллмана, они предоставили только общие контуры того, как могли бы быть построены асимметричные криптографические схемы. Они не предложили никакой однонаправленной функции, которая могла бы конкретно удовлетворить условиям, необходимым для разумной безопасности в таких схемах.

Однако практическая реализация асимметричной схемы была найдена год спустя тремя разными академическими криптографами и математиками: Рональдом Ривестом, Ади Шамиром и Леонардом Адлеманом. [3] Криптосистема, которую они ввели, стала известна как **криптосистема RSA** (по их фамилиям).

Ловушечные функции, используемые в асимметричной криптографии (и обмене ключами Диффи-Хеллмана), связаны с двумя основными **вычислительно сложными проблемами**: факторизацией простых чисел и вычислением дискретных логарифмов.

**Факторизация простых чисел** требует, как следует из названия, разложения целого числа на его простые множители. Проблема RSA является, пожалуй, самым известным примером криптосистемы, связанной с факторизацией простых чисел.

**Проблема дискретного логарифма** возникает в циклических группах. Имея генератор в определенной циклической группе, требуется вычисление уникального показателя степени, необходимого для получения другого элемента группы из генератора.

Схемы, основанные на дискретном логарифме, опираются на два основных типа циклических групп: мультипликативные группы целых чисел и группы, включающие точки на эллиптических кривых. Оригинальный обмен ключами Диффи-Хеллмана, представленный в "Новых направлениях в криптографии", работает с циклической мультипликативной группой целых чисел. Алгоритм цифровой подписи Bitcoin и недавно представленная схема подписи Шнорра (2021) оба основаны на проблеме дискретного логарифма для определенной группы циклических эллиптических кривых.

Далее мы перейдем к обзору секретности и аутентификации в асимметричной среде. Однако перед этим нам нужно сделать краткое историческое замечание.
Теперь кажется правдоподобным, что группа британских криптографов и математиков, работающих на правительственную связную штаб-квартиру (GCHQ), независимо сделала упомянутые выше открытия на несколько лет раньше. Эта группа состояла из Джеймса Эллиса, Клиффорда Кокса и Малькольма Уильямсона.
Согласно их собственным заявлениям и заявлениям GCHQ, именно Джеймс Эллис впервые разработал концепцию криптографии с открытым ключом в 1969 году. Предположительно, затем Клиффорд Кокс открыл криптографическую систему RSA в 1973 году, а Малькольм Уильямсон - концепцию обмена ключами Диффи-Хеллмана в 1974 году. [4] Однако утверждается, что их открытия не были раскрыты до 1997 года из-за секретности работы, проводимой в GCHQ.

**Примечания:**

[1] Уитфилд Диффи и Мартин Хеллман, “Новые направления в криптографии,” _IEEE Transactions on Information Theory_ IT-22 (1976), стр. 644–654, на стр. 644.

[2] Ральф Меркл также обсуждает протокол обмена ключами в “Безопасная связь по незащищенным каналам”, _Communications of the Association for Computing Machinery_, 21 (1978), 294–99. Хотя Меркл фактически представил эту статью до работы Диффи и Хеллмана, она была опубликована позже. Решение Меркла не обеспечивает экспоненциальную безопасность, в отличие от Диффи-Хеллмана.

[3] Рон Ривест, Ади Шамир и Леонард Адлеман, “Метод получения цифровых подписей и криптосистем с открытым ключом”, _Communications of the Association for Computing Machinery_, 21 (1978), стр. 120–26.

[4] Хорошую историю этих открытий предоставляет Саймон Сингх в книге _The Code Book_, Fourth Estate (Лондон, 1999), Глава 6.

## Асимметричное шифрование и аутентификация
<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

Обзор **асимметричного шифрования** с помощью Боба и Алисы представлен на *Рисунке 1*.

Алиса сначала создает пару ключей, состоящую из одного открытого ключа ($K_P$) и одного закрытого ключа ($K_S$), где “P” в $K_P$ означает “public” (открытый), а “S” в $K_S$ - “secret” (секретный). Затем она свободно распространяет этот открытый ключ среди других. Мы вернемся к деталям этого процесса распространения немного позже. Но пока предположим, что любой, включая Боба, может безопасно получить открытый ключ Алисы $K_P$.

В какой-то момент позже Боб хочет написать сообщение $M$ Алисе. Поскольку оно содержит конфиденциальную информацию, он хочет, чтобы содержимое оставалось секретным для всех, кроме Алисы. Поэтому Боб сначала шифрует свое сообщение $M$, используя $K_P$. Затем он отправляет полученный шифротекст $C$ Алисе, которая расшифровывает $C$ с помощью $K_S$, чтобы восстановить исходное сообщение $M$.

*Рисунок 1: Асимметричное шифрование*

![Рисунок 1: Асимметричное шифрование](assets/Figure6-1.webp "Рисунок 1: Асимметричное шифрование")

Любой противник, подслушивающий общение Боба и Алисы, может наблюдать $C$. Она также знает $K_P$ и алгоритм шифрования $E(\cdot)$. Однако важно, что эта информация не позволяет атакующему выполнимо расшифровать шифротекст $C$. Для расшифровки специфически требуется $K_S$, которого у атакующего нет.
Схемы симметричного шифрования, как правило, должны быть защищены от атакующего, который может законно шифровать открытые текстовые сообщения (такая безопасность называется защитой от атак с выбранным шифротекстом). Однако они не предназначены для того, чтобы позволять атакующему или кому-либо другому создавать такие законные шифротексты.

Это резко контрастирует с асимметричной схемой шифрования, цель которой - позволить любому, включая атакующих, создавать законные шифротексты. Таким образом, асимметричные схемы шифрования могут быть обозначены как **шифры с множественным доступом**.

Чтобы лучше понять, что происходит, представьте, что вместо отправки сообщения электронно, Боб хотел бы отправить физическое письмо в тайне. Один из способов обеспечить секретность - чтобы Алиса отправила Бобу надежный замок, но оставила ключ у себя. После написания письма Боб мог бы положить его в коробку и закрыть ее замком Алисы. Затем он мог бы отправить закрытую коробку с сообщением Алисе, у которой есть ключ, чтобы открыть ее.

Хотя Боб может закрыть замок, ни он, ни любой другой человек, который перехватит коробку, не сможет открыть замок, если он действительно надежен. Только Алиса может открыть его и увидеть содержимое письма Боба, потому что у нее есть ключ.

Асимметричная схема шифрования, грубо говоря, является цифровой версией этого процесса. Замок аналогичен публичному ключу, а ключ от замка аналогичен приватному ключу. Однако, поскольку замок цифровой, Алисе гораздо проще и дешевле распространять его среди всех, кто может захотеть отправить ей секретные сообщения.

Для аутентификации в асимметричной среде мы используем **цифровые подписи**. Таким образом, они выполняют ту же функцию, что и коды аутентификации сообщений в симметричной среде. Обзор цифровых подписей представлен на *Рисунке 2*.

Боб сначала создает пару ключей, состоящую из публичного ключа ($K_P$) и приватного ключа ($K_S$), и распространяет свой публичный ключ. Когда он хочет отправить аутентифицированное сообщение Алисе, он сначала берет свое сообщение $M$ и свой приватный ключ, чтобы создать **цифровую подпись** $D$. Затем Боб отправляет Алисе свое сообщение вместе с цифровой подписью.

Алиса вставляет сообщение, публичный ключ и цифровую подпись в **алгоритм проверки**. Этот алгоритм выдает либо **true** для действительной подписи, либо **false** для недействительной подписи.

Цифровая подпись, как ясно из названия, является цифровым эквивалентом письменной подписи на письмах, контрактах и так далее. Фактически, цифровая подпись обычно намного более безопасна. С некоторыми усилиями вы можете подделать письменную подпись; процесс упрощается из-за того, что письменные подписи часто не проверяются тщательно. Однако надежная цифровая подпись, так же как и надежный код аутентификации сообщения, **невозможно подделать**: то есть с надежной схемой цифровой подписи никто не сможет создать подпись для сообщения, которая пройдет процедуру проверки, если у него нет приватного ключа.

*Рисунок 2: Асимметричная аутентификация*

![Рисунок 2: Асимметричная аутентификация](assets/Figure6-2.webp "Рисунок 2: Асимметричная аутентификация")

Как и в случае с асимметричным шифрованием, мы видим интересный контраст между цифровыми подписями и кодами аутентификации сообщений. Для последних алгоритм проверки может использоваться только одной из сторон, участвующих в защищенном общении. Это потому, что он требует приватного ключа. Однако, в асимметричной среде, любой может проверить цифровую подпись $S$, сделанную Бобом.
Всё это делает цифровые подписи чрезвычайно мощным инструментом. Они лежат в основе, например, создания подписей на контрактах, которые могут быть проверены в юридических целях. Если бы Боб сделал подпись на контракте в вышеупомянутом обмене, Алиса могла бы предъявить сообщение $M$, контракт и подпись $S$ в суд. Суд, в свою очередь, может проверить подпись, используя публичный ключ Боба. [5]

В качестве другого примера, цифровые подписи являются важным аспектом безопасного распространения программного обеспечения и обновлений к нему. Такой тип публичной проверяемости невозможно создать, используя только коды аутентификации сообщений.

Как последний пример мощи цифровых подписей, рассмотрим Биткойн. Одно из наиболее распространенных заблуждений о Биткойне, особенно в СМИ, заключается в том, что транзакции зашифрованы: это не так. Вместо этого, транзакции Биткойна работают с цифровыми подписями для обеспечения безопасности.

Биткойны существуют в пакетах, называемых нерасходованными выходами транзакций (или **UTXO’s**). Предположим, вы получили три платежа на определенный адрес Биткойна по 2 биткойна каждый. Технически у вас теперь нет 6 биткойнов на этом адресе. Вместо этого у вас есть три пакета по 2 биткойна, которые заблокированы криптографической задачей, связанной с этим адресом. Для любого платежа, который вы совершаете, вы можете использовать один, два или все три этих пакета, в зависимости от того, сколько вам нужно для транзакции.

Доказательство владения нерасходованными выходами транзакций обычно демонстрируется через одну или несколько цифровых подписей. Биткойн работает именно потому, что создание действительных цифровых подписей на нерасходованных выходах транзакций вычислительно невозможно, если у вас нет секретной информации, необходимой для их создания.

В настоящее время транзакции Биткойна прозрачно включают всю информацию, которая должна быть проверена участниками сети, такую как происхождение используемых в транзакции нерасходованных выходов транзакций. Хотя возможно скрыть некоторую часть этой информации и все же позволить провести верификацию (как это делают некоторые альтернативные криптовалюты, такие как Monero), это также создает определенные риски безопасности.

Иногда возникает путаница между цифровыми подписями и цифрово захваченными рукописными подписями. В последнем случае вы захватываете изображение своей рукописной подписи и вставляете его в электронный документ, такой как трудовой договор. Однако это не является цифровой подписью в криптографическом смысле. Последняя представляет собой просто длинное число, которое может быть создано только при наличии приватного ключа.

Так же, как и в симметричном ключевом контексте, вы также можете использовать асимметричное шифрование и схемы аутентификации вместе. Применяются аналогичные принципы. Прежде всего, вы должны использовать разные пары приватных и публичных ключей для шифрования и создания цифровых подписей. Кроме того, вы должны сначала зашифровать сообщение, а затем аутентифицировать его.

Важно, что во многих приложениях асимметричная криптография не используется на протяжении всего процесса коммуникации. Вместо этого она обычно используется только для *обмена симметричными ключами* между сторонами, которые будут фактически общаться.

Это случается, например, когда вы покупаете товары в интернете. Зная публичный ключ продавца, она может отправлять вам цифрово подписанные сообщения, которые вы можете проверить на подлинность. На этой основе вы можете следовать одному из нескольких протоколов для обмена симметричными ключами для безопасного общения.

Основная причина частоты упомянутого подхода заключается в том, что асимметричная криптография намного менее эффективна, чем симметричная криптография, в обеспечении определенного уровня безопасности. Это одна из причин, почему нам все еще нужна симметричная криптография наряду с публичной криптографией. Кроме того, симметричная криптография гораздо более естественна в определенных приложениях, таких как шифрование собственных данных пользователем компьютера.

Итак, как именно цифровые подписи и шифрование с использованием публичного ключа решают проблемы распределения и управления ключами?
Здесь не существует единственного ответа. Асимметричная криптография - это инструмент, и не существует одного способа использования этого инструмента. Но давайте рассмотрим наш предыдущий пример с Jim’s Sporting Goods, чтобы показать, как обычно решаются подобные вопросы на этом примере.

Для начала, Jim’s Sporting Goods, вероятно, обратилась бы к **органу по сертификации**, организации, которая поддерживает распространение открытых ключей. Орган по сертификации зарегистрировал бы некоторые детали о Jim’s Sporting Goods и выдал бы ей открытый ключ. Затем он отправил бы Jim’s Sporting Goods сертификат, известный как **TLS/SSL сертификат**, с открытым ключом Jim’s Sporting Goods, цифровая подпись которого выполнена с использованием собственного открытого ключа органа по сертификации. Таким образом, орган по сертификации подтверждает, что конкретный открытый ключ действительно принадлежит Jim’s Sporting Goods.

Ключ к пониманию этого процесса с TLS/SSL сертификатами заключается в том, что, хотя у вас обычно не будет храниться открытый ключ Jim’s Sporting Goods где-либо на вашем компьютере, открытые ключи признанных органов по сертификации действительно хранятся в вашем браузере или в вашей операционной системе. Они хранятся в так называемых **корневых сертификатах**.

Следовательно, когда Jim’s Sporting Goods предоставляет вам свой TLS/SSL сертификат, вы можете проверить цифровую подпись органа по сертификации через корневой сертификат в вашем браузере или операционной системе. Если подпись действительна, вы можете быть относительно уверены, что открытый ключ на сертификате действительно принадлежит Jim’s Sporting Goods. На этой основе легко настроить протокол для безопасного общения с Jim’s Sporting Goods.

Распространение ключей теперь стало значительно проще для Jim’s Sporting Goods. Не трудно увидеть, что управление ключами также значительно упрощено. Вместо того, чтобы хранить тысячи ключей, Jim’s Sporting Goods просто нужно хранить приватный ключ, который позволяет ей создавать подписи для открытого ключа на ее SSL сертификате. Каждый раз, когда клиент заходит на сайт Jim’s Sporting Goods, они могут установить безопасную сессию связи с использованием этого открытого ключа. Клиентам также не нужно хранить какую-либо информацию (кроме открытых ключей признанных органов по сертификации в их операционной системе и браузере).

**Примечания:**

[5] Любые схемы, пытающиеся достичь невозможности отказа, другая тема, которую мы обсуждали в Главе 1, в своей основе должны включать цифровые подписи.

## Хеш-функции
<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

Хеш-функции повсеместно используются в криптографии. Они не являются ни симметричными, ни асимметричными схемами, но попадают в свою собственную криптографическую категорию.

Мы уже сталкивались с хеш-функциями в Главе 4 при создании хеш-основанных аутентификационных сообщений. Они также важны в контексте цифровых подписей, хотя по немного другой причине: цифровые подписи обычно делаются на основе хеш-значения некоторого (зашифрованного) сообщения, а не самого (зашифрованного) сообщения. В этом разделе я предложу более подробное введение в хеш-функции.

Давайте начнем с определения хеш-функции. **Хеш-функция** - это любая эффективно вычислимая функция, которая принимает на вход данные произвольного размера и выдает выходные данные фиксированной длины.

**Криптографическая хеш-функция** - это просто хеш-функция, которая полезна для приложений в криптографии. Выходные данные криптографической хеш-функции обычно называются **хеш**, **хеш-значение** или **дайджест сообщения**.

В контексте криптографии "хеш-функция" обычно относится к криптографической хеш-функции. Я буду придерживаться этой практики отныне.
Пример популярной хеш-функции - **SHA-256** (secure hash algorithm 256). Независимо от размера входных данных (например, 15 бит, 100 бит или 10 000 бит), эта функция выдаст 256-битное хеш-значение. Ниже вы можете увидеть несколько примеров результатов работы функции SHA-256.
“Hello”: `185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969`

“52398”: `a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90`

“Криптография - это весело”: `3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c`

Все результаты точно 256 бит, записанные в шестнадцатеричном формате (каждая шестнадцатеричная цифра может быть представлена четырьмя двоичными цифрами). Так что даже если бы вы ввели в функцию SHA-256 книгу Толкиена *Властелин колец*, результат все равно был бы 256 бит.

Хеш-функции, такие как SHA-256, используются для различных целей в криптографии. Какие свойства требуются от хеш-функции, действительно зависит от контекста конкретного применения. В криптографии обычно выделяют два основных свойства, желаемых от хеш-функций: [6]

1.	Стойкость к коллизиям
2.	Скрытие

Говорят, что хеш-функция $H$ обладает **стойкостью к коллизиям**, если невозможно найти два значения, $x$ и $y$, таких, что $x \neq y$, но $H(x) = H(y)$.

Хеш-функции, стойкие к коллизиям, важны, например, при верификации программного обеспечения. Предположим, что вы хотели бы скачать версию Windows Bitcoin Core 0.21.0 (серверное приложение для обработки трафика сети Bitcoin). Основные шаги, которые вам нужно будет предпринять для проверки легитимности программного обеспечения, следующие:

1.	Сначала вам нужно скачать и импортировать публичные ключи одного или нескольких участников Bitcoin Core в программное обеспечение, которое может проверять цифровые подписи (например, Kleopetra). Эти публичные ключи можно найти [здесь](https://github.com/bitcoin/bitcoin/blob/master/contrib/builder-keys/keys.txt). Рекомендуется проверять программное обеспечение Bitcoin Core с публичными ключами нескольких участников.
2.	Затем вам нужно проверить импортированные публичные ключи. По крайней мере, один из шагов, который вы должны предпринять, - убедиться, что публичные ключи, которые вы нашли, совпадают с опубликованными в различных других местах. Например, вы можете посетить личные веб-страницы, страницы в Twitter или Github страницы людей, чьи публичные ключи вы импортировали. Обычно это сравнение публичных ключей производится путем сравнения короткого хеша публичного ключа, известного как отпечаток.
3.	Затем вам нужно скачать исполняемый файл для Bitcoin Core с их [веб-сайта](www.bitcoincore.org). Будут доступны пакеты для операционных систем Linux, Windows и MAC.
4.	Далее, вам нужно найти два файла релиза. Первый содержит официальный хеш SHA-256 для скачанного вами исполняемого файла вместе с хешами всех других выпущенных пакетов. Другой файл релиза будет содержать подписи различных участников над файлом релиза с хешами пакетов. Оба эти файла релиза должны быть размещены на веб-сайте Bitcoin Core.
5. Далее вам необходимо будет вычислить хеш SHA-256 для загруженного с сайта Bitcoin Core исполняемого файла на вашем компьютере. Затем сравните этот результат с официальным хешем пакета для исполняемого файла. Они должны совпадать.  
6. Наконец, вам нужно будет проверить, что одна или несколько цифровых подписей над файлом релиза с официальными хешами пакетов действительно соответствуют одному или нескольким публичным ключам, которые вы импортировали (релизы Bitcoin Core не всегда подписываются всеми). Это можно сделать с помощью приложения, такого как Kleopetra.

Этот процесс верификации программного обеспечения имеет два основных преимущества. Во-первых, он гарантирует, что при загрузке с сайта Bitcoin Core не произошло ошибок передачи данных. Во-вторых, он обеспечивает защиту от возможности того, что злоумышленник мог заставить вас загрузить измененный, вредоносный код, либо путем взлома сайта Bitcoin Core, либо перехватив трафик.

Как именно процесс верификации программного обеспечения, описанный выше, защищает от этих проблем?

Если вы тщательно проверили импортированные вами публичные ключи, то можете быть довольно уверены, что эти ключи действительно принадлежат их владельцам и не были скомпрометированы. Учитывая, что цифровые подписи обладают свойством экзистенциальной нефальсифицируемости, вы знаете, что только эти участники могли создать цифровую подпись над официальными хешами пакетов в файле релиза.

Предположим, что подписи в загруженном вами файле релиза проверены. Теперь вы можете сравнить значение хеша, которое вы вычислили локально для загруженного исполняемого файла Windows, с тем, которое включено в должным образом подписанный файл релиза. Поскольку вы знаете, что хеш-функция SHA-256 устойчива к коллизиям, совпадение означает, что ваш исполняемый файл точно такой же, как официальный исполняемый файл.

Теперь давайте обратимся ко второму общему свойству хеш-функций: **скрытию**. Говорят, что хеш-функция $H$ обладает свойством скрытия, если для любого случайно выбранного $x$ из очень большого диапазона невозможно найти $x$, зная только $H(x)$.

Ниже вы можете увидеть вывод SHA-256 для сообщения, которое я написал. Чтобы обеспечить достаточную случайность, в сообщение была включена случайно сгенерированная строка символов в конце. Учитывая, что SHA-256 обладает свойством скрытия, никто не смог бы расшифровать это сообщение.

- `b194221b37fa4cd1cfce15aaef90351d70de17a98ee6225088b523b586c32ded`

Но я не буду держать вас в напряжении до тех пор, пока SHA-256 не станет слабее. Исходное сообщение, которое я написал, было следующим:

* “Это очень случайное сообщение, ну или скорее случайное. Эта начальная часть не является таковой, но я закончу некоторыми относительно случайными символами, чтобы обеспечить очень непредсказуемое сообщение. XLWz4dVG3BxUWm7zQ9qS”.

Обычным способом использования хеш-функций с свойством скрытия является управление паролями (устойчивость к коллизиям также важна для этого применения). Любая приличная онлайн-служба на основе учетных записей, такая как Facebook или Google, не будет хранить ваши пароли напрямую для управления доступом к вашей учетной записи. Вместо этого они будут хранить только хеш этого пароля. Каждый раз, когда вы вводите свой пароль в браузере, сначала вычисляется хеш. Только этот хеш отправляется на сервер поставщика услуг и сравнивается с хешем, хранящимся в базе данных на сервере. Свойство скрытия может помочь гарантировать, что злоумышленники не смогут восстановить его из значения хеша.
Управление паролями с помощью хешей, конечно, работает только в том случае, если пользователи действительно выбирают сложные пароли. Свойство сокрытия предполагает, что x выбирается случайным образом из очень большого диапазона. Выбор паролей вроде "1234", "mypassword" или даты вашего дня рождения не обеспечит настоящей безопасности. Существуют длинные списки распространенных паролей и их хешей, которыми могут воспользоваться атакующие, если они когда-либо получат хеш вашего пароля. Такие типы атак известны как **атаки по словарю**. Если атакующие знают некоторые ваши личные данные, они также могут попытаться сделать некоторые обоснованные предположения. Поэтому вам всегда нужны длинные, надежные пароли (желательно длинные, случайные строки из менеджера паролей).

Иногда приложению может потребоваться хеш-функция, которая обладает как стойкостью к коллизиям, так и свойством сокрытия. Но определенно не всегда. Процесс верификации программного обеспечения, о котором мы говорили, например, требует только, чтобы хеш-функция обладала стойкостью к коллизиям, сокрытие не важно.

Хотя стойкость к коллизиям и сокрытие являются основными свойствами, которые ищут от хеш-функций в криптографии, в некоторых приложениях могут быть желательны и другие типы свойств.

**Примечания:**

[6] Терминология "сокрытие" не является общеупотребительной, но взята специально из работы Арвинда Нараянана, Джозефа Бонно, Эдварда Фелтена, Эндрю Миллера и Стивена Голдфедера, *Bitcoin and Cryptocurrency Technologies*, Princeton University Press (Принстон, 2016), Глава 1.

# Криптосистема RSA
<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

## Проблема факторизации
<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

Хотя симметричная криптография обычно довольно интуитивно понятна для большинства людей, это обычно не относится к асимметричной криптографии. Хотя вы, вероятно, удобно ознакомились с высокоуровневым описанием, предложенным в предыдущих разделах, вы, вероятно, задаетесь вопросом, что именно такое односторонние функции и как именно они используются для построения асимметричных схем.

В этой главе я сниму некоторую тайну, окружающую асимметричную криптографию, более глубоко рассмотрев конкретный пример, а именно криптосистему RSA. В первом разделе я представлю проблему факторизации, на которой основана проблема RSA. Затем я рассмотрю ряд ключевых результатов из теории чисел. В последнем разделе мы объединим эту информацию, чтобы объяснить проблему RSA и как это можно использовать для создания асимметричных криптографических схем.

Добавление этой глубины к нашему обсуждению не является легкой задачей. Это требует введения довольно большого количества теорем и предложений теории чисел. Но не позволяйте математике отпугнуть вас. Проработка этого обсуждения значительно улучшит ваше понимание того, что лежит в основе асимметричной криптографии, и является ценным вложением.

Давайте теперь первым делом обратимся к проблеме факторизации.

___

Всякий раз, когда вы умножаете два числа, скажем $a$ и $b$, мы называем числа $a$ и $b$ **множителями**, а результат – **произведением**. Попытка записать число $N$ в виде умножения двух или более множителей называется **факторизацией** или **разложением на множители**. [1] Любую проблему, требующую этого, можно назвать **проблемой факторизации**.

Около 2,500 лет назад греческий математик Евклид из Александрии открыл ключевую теорему о факторизации целых чисел. Обычно ее называют **теоремой о единственном разложении на простые множители** и она утверждает следующее:

**Теорема 1**. Каждое целое число $N$, которое больше 1, либо является простым числом, либо может быть выражено в виде произведения простых множителей.
Всё, что означает последняя часть этого утверждения, заключается в том, что вы можете взять любое составное число $N$, большее 1, и представить его в виде произведения простых чисел. Ниже приведено несколько примеров составных чисел, представленных как произведение простых множителей.
* $18 = 2 \cdot 3 \cdot 3 = 2 \cdot 3^2$
* $84 = 2 \cdot 2 \cdot 3 \cdot 7 = 2^2 \cdot 3 \cdot 7$
* $144 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 3 \cdot 3 = 2^4 \cdot 3^2$

Для всех трех чисел выше вычисление их простых множителей относительно просто, даже если вам известно только $N$. Вы начинаете с наименьшего простого числа, а именно с 2, и смотрите, сколько раз число $N$ делится на него. Затем вы переходите к проверке делимости $N$ на 3, 5, 7 и так далее. Вы продолжаете этот процесс до тех пор, пока ваше число $N$ не будет представлено в виде произведения только простых чисел.

Возьмем, к примеру, число 84. Ниже вы можете увидеть процесс определения его простых множителей. На каждом шаге мы выделяем наименьший оставшийся простой множитель (слева) и определяем остаточный член для разложения. Мы продолжаем, пока остаточный член также не станет простым числом. На каждом шаге текущее разложение 84 отображается справа.

* Простой множитель = 2: остаточный член = 42 	($84 = 2 \cdot 42$)
* Простой множитель = 2: остаточный член = 21 	($84 = 2 \cdot 2 \cdot 21$)
* Простой множитель = 3: остаточный член = 7 	($84 = 2 \cdot 2 \cdot 3 \cdot 7$)
* Поскольку 7 является простым числом, результатом будет $2 \cdot 2 \cdot 3 \cdot 7$, или $2^2 \cdot 3 \cdot 7$.

Предположим теперь, что $N$ очень велико. Насколько сложно будет разложить $N$ на простые множители?

Это действительно зависит от $N$. Предположим, например, что $N$ равно 50,450,400. Хотя это число выглядит пугающе, расчеты не так сложны и могут быть легко выполнены вручную. Как и выше, вы просто начинаете с 2 и продолжаете дальше. Ниже вы можете увидеть результат этого процесса аналогичным образом.

* 2: 25,225,200 	($50,450,400 = 2 \cdot 25,225,200$)  
* 2: 12,612,600 	($50,450,400 = 2^2 \cdot 12,612,600$)  
* 2: 6,306,300 	($50,450,400 = 2^3 \cdot 6,306,300$)  
* 2: 3,153,150 	($50,450,400 = 2^4 \cdot 3,153,150$)  
* 2: 1,576,575 	($50,450,400 = 2^5 \cdot 1,576,575$)
* 3: 525,525 ($50,450,400 = 2^5 \cdot 3 \cdot 525,525$)
* 3: 175,175 ($50,450,400 = 2^5 \cdot 3^2 \cdot 175,175$)
* 5: 35,035 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5 \cdot 35,035$)
* 5: 7,007 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7,007$)
* 7: 1,001 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7 \cdot 1,001$)
* 7: 143 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 143$)
* 11: 13 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$)
* Поскольку 13 является простым числом, результатом будет $2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$.

Решение этой задачи вручную занимает некоторое время. Компьютер, конечно, может сделать все это за долю секунды. Фактически, компьютер часто может даже факторизовать чрезвычайно большие целые числа за долю секунды.

Однако есть некоторые исключения. Предположим, что мы сначала случайным образом выбираем два очень больших простых числа. Обычно их обозначают $p$ и $q$, и я буду придерживаться этой конвенции здесь.

Для конкретности, скажем, что $p$ и $q$ оба являются 1024-битными простыми числами и что им действительно требуется как минимум 1024 бита для их представления (так что первый бит должен быть 1). Так, например, 37 не могло бы быть одним из простых чисел. Вы, конечно, можете представить 37 с помощью 1024 битов. Но очевидно, *вам не нужно* столько битов, чтобы представить его. Вы можете представить 37 любой последовательностью, которая имеет 6 битов или больше. (В 6 битах 37 будет представлено как $100101$).

Важно оценить, насколько велики $p$ и $q$, если выбраны при вышеуказанных условиях. В качестве примера я выбрал случайное простое число, которое требует как минимум 1024 бита для представления ниже.
* 14,752,173,874,503,595,484,930,006,383,670,759,559,764,562,721,397,166,747,289,220,945,457,932,666,751,048,198,854,920,097,085,690,793,755,254,946,188,163,753,506,778,089,706,699,671,722,089,715,624,760,049,594,106,189,662,669,156,149,028,900,805,928,183,585,427,782,974,951,355,515,394,807,209,836,870,484,558,332,897,443,152,653,214,483,870,992,618,171,825,921,582,253,023,974,514,209,142,520,026,807,636,589

Предположим, что после случайного выбора простых чисел $p$ и $q$ мы умножаем их, чтобы получить целое число $N$. Это последнее число, таким образом, является числом из 2048 бит, которое требует для своего представления как минимум 2048 бит. Оно гораздо, гораздо больше, чем любое из чисел $p$ или $q$.

Предположим, вы даете компьютеру только $N$ и просите его найти два простых множителя $N$ размером в 1024 бита каждый. Вероятность того, что компьютер обнаружит $p$ и $q$, чрезвычайно мала. Можно сказать, что это практически невозможно. Это так, даже если бы вы использовали суперкомпьютер или даже сеть суперкомпьютеров.

Для начала предположим, что компьютер пытается решить проблему, перебирая числа размером в 1024 бита, проверяя в каждом случае, являются ли они простыми и являются ли они множителями $N$. Тогда набор простых чисел для проверки приблизительно равен $1.265 \cdot 10^{305}$. [2]

Даже если вы возьмете все компьютеры на планете и заставите их пытаться найти и проверить 1024-битные простые числа таким образом, шанс в один из миллиарда успешно найти простой множитель $N$ потребовал бы периода вычислений, гораздо превышающего возраст Вселенной.

Теперь на практике компьютер может справиться лучше, чем было описано. Существует несколько алгоритмов, которые компьютер может применить для более быстрого получения факторизации. Однако суть в том, что даже используя эти более эффективные алгоритмы, задача для компьютера все еще остается вычислительно невыполнимой. [3]

Важно, что сложность факторизации в только что описанных условиях основывается на предположении, что не существует вычислительно эффективных алгоритмов для вычисления простых множителей. Мы не можем доказать, что эффективный алгоритм не существует. Тем не менее, это предположение очень правдоподобно: несмотря на обширные усилия, продолжающиеся сотни лет, мы еще не нашли такого вычислительно эффективного алгоритма.

Следовательно, проблема факторизации в определенных условиях может с уверенностью считаться сложной задачей. В частности, когда $p$ и $q$ являются очень большими простыми числами, их произведение $N$ несложно вычислить; но факторизация, зная только $N$, практически невозможна.

**Примечания:**

[1] Факторизация также может быть важна для работы с другими типами математических объектов, кроме чисел. Например, она может быть полезна для факторизации полиномиальных выражений, таких как $x^2 - 2x + 1$. В нашем обсуждении мы будем сосредотачиваться только на факторизации чисел, в частности целых чисел.
[2] Согласно **теореме о простых числах**, количество простых чисел, меньших или равных $N$, приблизительно равно $N/\ln(N)$. Это означает, что вы можете приблизительно оценить количество простых чисел длиной 1024 бита по формуле:
$$ \frac{2^{1024}}{\ln(2^{1024})} - \frac{2^{1023}}{\ln(2^{1023})} $$

...что равно приблизительно $1.265 \times 10^{305}$.

[3] То же самое верно и для задач дискретного логарифмирования. Поэтому асимметричные конструкции работают с гораздо большими ключами, чем симметричные криптографические конструкции.

## Результаты теории чисел
<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

К сожалению, проблема факторизации не может быть использована напрямую для асимметричных криптографических схем. Однако, мы можем использовать более сложную, но связанную с этим проблему: проблему RSA.

Для понимания проблемы RSA нам потребуется понять ряд теорем и предложений из теории чисел. Они представлены в этом разделе в трех подразделах: (1) порядок N, (2) обратимость по модулю N, и (3) теорема Эйлера.

Некоторый материал в этих трех подразделах уже был представлен в *Главе 3*. Но я здесь повторю этот материал для удобства.

### Порядок N

Целое число $a$ является **взаимно простым** или **относительно простым** с целым числом $N$, если наибольший общий делитель между ними равен 1. Хотя по соглашению 1 не является простым числом, оно является взаимно простым с любым целым числом (как и $-1$).

Например, рассмотрим случай, когда $a = 18$ и $N = 37$. Очевидно, что они взаимно просты. Наибольшее целое число, которое делит как 18, так и 37, равно 1. В отличие от этого, рассмотрим случай, когда $a = 42$ и $N = 16$. Очевидно, что они не являются взаимно простыми. Оба числа делятся на 2, что больше 1.

Теперь мы можем определить порядок $N$ следующим образом. Предположим, что $N$ - это целое число больше 1. **Порядок N** - это количество всех взаимно простых с $N$ чисел так, что для каждого взаимно простого $a$ выполняется следующее условие: $1 \leq a < N$.

Например, если $N = 12$, то 1, 5, 7 и 11 - это единственные взаимно простые числа, которые соответствуют вышеуказанному требованию. Следовательно, порядок 12 равен 4.

Предположим, что $N$ является простым числом. Тогда любое целое число меньше $N$, но больше или равное 1, является взаимно простым с ним. Это включает все элементы в следующем наборе: $\{1,2,3,….,N - 1\}$. Следовательно, когда $N$ является простым, порядок $N$ равен $N - 1$. Это утверждается в предложении 1, где $\phi(N)$ обозначает порядок $N$.

**Предложение 1**. $\phi(N) = N - 1$, когда $N$ является простым
Предположим, что $N$ не является простым числом. Тогда вы можете вычислить его порядок, используя **функцию Эйлера Фи**. Хотя вычисление порядка малого целого числа относительно просто, функция Эйлера Фи становится особенно важной для больших целых чисел. Предложение функции Эйлера Фи приведено ниже.
**Теорема 2**. Пусть $N$ равно $p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_i^{e_i} \cdot \ldots \cdot p_n^{e_n}$, где множество $\{p_i\}$ состоит из всех различных простых множителей $N$ и каждый $e_i$ указывает, сколько раз простой множитель $p_i$ встречается для $N$. Тогда,

$$\phi(N) = p_1^{e_1 - 1} \cdot (p_1 - 1) \cdot p_2^{e_2 - 1} \cdot (p_2 - 1) \cdot \ldots \cdot p_n^{e_n - 1} \cdot (p_n - 1)$$

**Теорема 2** показывает, что как только вы разложите любое составное число $N$ на его различные простые множители, легко вычислить порядок $N$.

Например, предположим, что $N = 270$. Это явно не простое число. Разложение $N$ на его простые множители дает выражение: $2 \cdot 3^3 \cdot 5$. Согласно функции Эйлера Фи, порядок $N$ тогда следующий:

$$\phi(N) = 2^{1 - 1} \cdot (2 - 1) + 3^{3 - 1} \cdot (3 - 1) + 5^{1 - 1} \cdot (5 - 1) = 1 \cdot 1 + 9 \cdot 2 + 1 \cdot 4 = 1 + 18 + 4 = 23$$

Предположим далее, что $N$ является произведением двух простых чисел, $p$ и $q$. **Теорема 2** выше, тогда, утверждает, что порядок $N$ следующий:

$$p^{1 - 1} \cdot (p - 1) \cdot q^{1 - 1} \cdot (q - 1) = (p - 1) \cdot (q - 1)$$

Это ключевой результат для проблемы RSA в частности и изложен в **Предложении 2** ниже.

**Предложение 2**. Если $N$ является произведением двух простых чисел, $p$ и $q$, порядок $N$ является произведением $(p - 1) \cdot (q - 1)$.

Для иллюстрации предположим, что $N = 119$. Это целое число может быть разложено на два простых числа, а именно 7 и 17. Следовательно, функция Эйлера Фи предполагает, что порядок 119 следующий:

$$\phi(119) = (7 - 1) \cdot (17 - 1) = 6 \cdot 16 = 96$$

Другими словами, целое число 119 имеет 96 взаимно простых чисел в диапазоне от 1 до 119. Фактически, этот набор включает все целые числа от 1 до 119, которые не являются кратными ни 7, ни 17.
Отсюда и далее давайте обозначим множество взаимно простых чисел, определяющих порядок $N$, как $C_N$. Например, для $N = 119$, множество $C_{119}$ слишком велико, чтобы перечислить его полностью. Но некоторые из элементов следующие:
$$C_{119} = \{1, 2, \dots 6, 8 \dots 13, 15, 16, 18, \dots 33, 35 \dots 96\}$$

### Обратимость по модулю N

Мы можем сказать, что целое число $a$ является **обратимым по модулю N**, если существует по крайней мере одно целое число $b$ такое, что $a \cdot b \mod N = 1 \mod N$. Любое такое целое число $b$ называется **обратным** (или **мультипликативно обратным**) к $a$ при уменьшении по модулю $N$.

Предположим, например, что $a = 5$ и $N = 11$. Существует множество целых чисел, на которые вы можете умножить 5, так что $5 \cdot b \mod 11 = 1 \mod 11$. Рассмотрим, например, целые числа 20 и 31. Легко видеть, что оба эти числа являются обратными к 5 при уменьшении по модулю 11.

* $5 \cdot 20 \mod 11 = 100 \mod 11 = 1 \mod 11$
* $5 \cdot 31 \mod 11 = 155 \mod 11 = 1 \mod 11$

Хотя у 5 есть много обратных чисел по модулю 11, можно показать, что существует только одно положительное обратное число к 5, которое меньше 11. Фактически, это не уникально для нашего конкретного примера, но является общим результатом.

**Утверждение 3**. Если целое число $a$ обратимо по модулю $N$, то должно быть так, что ровно одно положительное обратное к $a$ меньше $N$. (Так что это уникальное обратное к $a$ должно входить в множество $\{1, \dots, N - 1\}$).

Давайте обозначим уникальное обратное к $a$ из **Утверждения 3** как $a^{-1}$. В случае, когда $a = 5$ и $N = 11$, вы можете видеть, что $a^{-1} = 9$, учитывая, что $5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$.

Заметьте, что вы также можете получить значение 9 для $a^{-1}$ в нашем примере, просто уменьшив любое другое обратное к $a$ по модулю 11. Например, $20 \mod 11 = 31 \mod 11 = 9 \mod 11$. Так что всякий раз, когда целое число $a > N$ обратимо по модулю $N$, тогда $a \mod N$ также должно быть обратимо по модулю $N$.

Не обязательно, чтобы обратное к $a$ существовало при уменьшении по модулю $N$. Предположим, например, что $a = 2$ и $N = 8$. Не существует $b$, или какого-либо $a^{-1}$ конкретно, так что $2 \cdot b \mod 8 = 1 \mod 8$. Это потому, что любое значение $b$ всегда будет производить кратное 2, так что никакое деление на 8 никогда не даст остатка, равного 1.
Как точно мы можем узнать, имеет ли некоторое целое число $a$ обратное по модулю данного $N$? Как вы могли заметить на примере выше, наибольший общий делитель между 2 и 8 больше 1, а именно 2. И это на самом деле иллюстрирует следующий общий результат:
**Утверждение 4**. Обратное число целого числа $a$ по модулю $N$ существует, и, в частности, существует уникальное положительное обратное число, меньшее $N$, тогда и только тогда, когда наибольший общий делитель между $a$ и $N$ равен 1 (то есть, если они взаимно просты).

В случае, когда $a = 5$ и $N = 11$, мы пришли к выводу, что $a^{-1} = 9$, учитывая, что $5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$. Важно отметить, что обратное также верно. То есть, когда $a = 9$ и $N = 11$, получается, что $a^{-1} = 5$.

### Теорема Эйлера

Перед тем как перейти к проблеме RSA, нам нужно понять еще одну критически важную теорему, а именно **теорему Эйлера**. Она утверждает следующее:

**Теорема 3**. Предположим, что два целых числа $a$ и $N$ взаимно просты. Тогда $a^{\phi(N)} \mod N = 1 \mod N$.

Это замечательный результат, но немного сбивающий с толку сначала. Давайте обратимся к примеру, чтобы понять его.

Предположим, что $a = 5$ и $N = 7$. Эти числа действительно взаимно просты, как требует теорема Эйлера. Мы знаем, что порядок числа 7 равен 6, учитывая, что 7 - простое число (см. **Утверждение 1**).

Теперь теорема Эйлера утверждает, что $5^6 \mod 7$ должно быть равно $1 \mod 7$. Ниже приведены расчеты, показывающие, что это действительно так.

* $5^6 \mod 7 = 15,625 \mod 7 = 1 \mod N$

Целое число 7 делит 15,624 ровно 2,233 раза. Следовательно, остаток от деления 16,625 на 7 равен 1.

Далее, используя функцию Эйлера $\phi$, **Теорема 2**, вы можете вывести **Утверждение 5** ниже.

**Утверждение 5**. $\phi(a \cdot b) = \phi(a) \cdot \phi(b)$ для любых положительных целых чисел $a$ и $b$.

Мы не будем показывать, почему это так. Но просто отметим, что вы уже видели доказательство этого утверждения по факту, что $\phi(p \cdot q) = \phi(p) \cdot \phi(q) = (p - 1) \cdot (q - 1)$, когда $p$ и $q$ являются простыми числами, как указано в **Утверждении 2**.

Теорема Эйлера в сочетании с **Утверждением 5** имеет важные следствия. Смотрите, что происходит, например, в приведенных ниже выражениях, где $a$ и $N$ взаимно просты.

* $a^{2 \cdot \phi(N)} \mod N = a^{\phi(N)} \cdot a^{\phi(N)} \mod N = 1 \cdot 1 \mod N = 1 \mod N$
* $a^{\phi(N) + 1} \mod N = a^{\phi(N)} \cdot a^1 \mod N = 1 \cdot a^1 \mod N = a \mod N$
* $a^{8 \cdot \phi(N) + 3} \mod N = a^{8 \cdot \phi(N)} \cdot a^3 \mod N = 1 \cdot a^3 \mod N = a^3 \mod N$

Таким образом, сочетание теоремы Эйлера и **Предложения 5** позволяют нам просто вычислить ряд выражений. В общем, мы можем сформулировать вывод, как в **Предложении 6**.

**Предложение 6**. $a^x \mod N = a^{x \mod \phi(N)}$

Теперь нам нужно собрать все вместе в хитром последнем шаге.

Так как $N$ имеет порядок $\phi(N)$, который включает элементы множества $C_N$, мы знаем, что целое число $\phi(N)$, в свою очередь, также должно иметь порядок и множество взаимно простых чисел. Пусть $\phi(N) = R$. Тогда мы знаем, что существует также значение для $\phi(R)$ и множество взаимно простых чисел $C_R$.

Предположим, что мы теперь выбираем целое число $e$ из множества $C_R$. Мы знаем из **Предложения 3**, что это целое число $e$ имеет только один уникальный положительный обратный элемент меньше $R$. То есть, $e$ имеет один уникальный обратный элемент из множества $C_R$. Назовем этот обратный элемент $d$. Учитывая определение обратного элемента, это означает, что $e \cdot d = 1 \mod R$.

Мы можем использовать этот результат, чтобы сделать заявление о нашем исходном целом числе $N$. Это суммировано в **Предложении 7**.

**Предложение 7**. Предположим, что $e \cdot d \mod \phi(N) = 1 \mod \phi(N)$. Тогда для любого элемента $a$ из множества $C_N$ должно быть так, что $a^{e \cdot d \mod \phi(N)} = a^{1 \mod \phi(N)} = a \mod N$.

Теперь у нас есть все необходимые теоретические результаты чисел, чтобы четко сформулировать проблему RSA.

## Криптосистема RSA
<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>

Теперь мы готовы сформулировать проблему RSA. Предположим, вы создаете набор переменных, состоящий из $p$, $q$, $N$, $\phi(N)$, $e$, $d$ и $y$. Назовите этот набор $\Pi$. Он создается следующим образом:

1. Генерируйте два случайных простых числа $p$ и $q$ одинакового размера и вычислите их произведение $N$.
2. Вычислите порядок $N$, $\phi(N)$, по следующему произведению: $(p - 1) \cdot (q - 1)$.
3. Выберите $e > 2$ так, чтобы оно было меньше и взаимно просто с $\phi(N)$.
4. Вычислите $d$, установив $e \cdot d \mod \phi(N) = 1$.
5. Выберите случайное значение $y$, которое меньше и взаимно просто с $N$.
Проблема RSA заключается в нахождении такого $x$, что $x^e = y$, при этом известна только часть информации о $\Pi$, а именно переменные $N$, $e$ и $y$. Когда $p$ и $q$ очень велики, обычно рекомендуется, чтобы их размер составлял 1024 бита, считается, что решить проблему RSA сложно. Теперь вы можете понять, почему это так, исходя из предыдущего обсуждения.

Простой способ вычислить $x$, когда $x^e \mod N = y \mod N$, - это просто вычислить $y^d \mod N$. Мы знаем, что $y^d \mod N = x \mod N$ на основе следующих вычислений:

$$ y^d \mod N = x^{e \cdot d} \mod N = x^{e \cdot d \mod \phi(N)} \mod N = x^{1 \mod \phi(N)} \mod N = x \mod N. $$

Проблема в том, что мы не знаем значение $d$, так как оно не дано в задаче. Следовательно, мы не можем напрямую вычислить $y^d \mod N$, чтобы получить $x \mod N$.

Однако мы могли бы косвенно вычислить $d$ из порядка $N$, $\phi(N)$, так как мы знаем, что $e \cdot d \mod \phi(N) = 1 \mod \phi(N)$. Но по предположению задача также не дает значение для $\phi(N)$.

Наконец, порядок можно было бы вычислить косвенно с помощью простых множителей $p$ и $q$, так что в конечном итоге мы могли бы вычислить $d$. Но по предположению значения $p$ и $q$ также не были предоставлены нам.

Говоря строго, даже если задача факторизации в рамках проблемы RSA сложна, мы не можем доказать, что проблема RSA также сложна. Возможно, существуют и другие способы решения проблемы RSA, помимо факторизации. Однако обычно принято и предполагается, что если задача факторизации в рамках проблемы RSA сложна, то сама проблема RSA также сложна.

Если проблема RSA действительно сложна, то она создает одностороннюю функцию с лазейкой. Здесь функция $f(g) = g^e \mod N$. Зная $f(g)$, любой может легко вычислить значение $y$ для конкретного $g = x$. Однако практически невозможно вычислить конкретное значение $x$, зная только значение $y$ и функцию $f(g)$. Исключение составляет случай, когда вам дан кусочек информации $d$, лазейка. В этом случае вы можете просто вычислить $y^d$, чтобы получить $x$.

Давайте рассмотрим конкретный пример, чтобы проиллюстрировать проблему RSA. Я не могу выбрать проблему RSA, которая считалась бы сложной при вышеуказанных условиях, так как числа были бы неудобными для использования. Вместо этого этот пример просто иллюстрирует, как в общем работает проблема RSA.

Для начала предположим, что вы выбрали два случайных простых числа 13 и 31. Таким образом, $p = 13$ и $q = 31$. Произведение этих двух простых чисел равно 403. Мы можем легко вычислить порядок 403. Он эквивалентен $(13 - 1) \cdot (31 - 1) = 360$.
Далее, как указано на шаге 3 задачи RSA, нам нужно выбрать взаимно простое число для 360, которое больше 2 и меньше 360. Нам не обязательно выбирать это значение случайным образом. Предположим, что мы выбираем 103. Это взаимно простое число с 360, так как их наибольший общий делитель с 103 равен 1.
На шаге 4 теперь требуется, чтобы мы вычислили значение $d$ так, чтобы $103 \cdot d \mod 360 = 1$. Это не простая задача для ручного вычисления, когда значение $N$ велико. Требуется использование процедуры, называемой **расширенным алгоритмом Евклида**.

Хотя я здесь не показываю процедуру, она дает значение 7, когда $e = 103$. Вы можете проверить, что пара значений 103 и 7 действительно удовлетворяет общему условию $e \cdot d \mod \phi(n) = 1$ на основе нижеприведенных расчетов.

* $103 \cdot 7 \mod 360 = 721 \mod 360 = 1 \mod 360$

Важно, что на основе *Предложения 4*, мы знаем, что никакое другое целое число между 1 и 360 для $d$ не даст результата $103 \cdot d = 1 \mod 360$. Кроме того, предложение подразумевает, что выбор другого значения для $e$ даст другое уникальное значение для $d$.

На шаге 5 задачи RSA нам нужно выбрать некоторое положительное целое число $y$, которое является меньшим взаимно простым числом для 403. Предположим, что мы установим $y = 2^{103}$. Возведение 2 в степень 103 дает результат ниже.

* $2^{103} \mod 403 = 10,141,204,801,825,835,211,973,625,643,008 \mod 403 = 349 \mod 403$

Задача RSA в данном конкретном примере теперь следующая: Вам даны $N = 403$, $e = 103$ и $y = 349 \mod 403$. Теперь вы должны вычислить $x$ так, чтобы $x^{103} = 349 \mod 403$. То есть, вы должны найти, что исходное значение до возведения в степень 103 было 2.

Было бы легко (по крайней мере для компьютера) вычислить $x$, если бы мы знали, что $d = 7$. В этом случае вы могли бы просто определить $x$ как ниже.

* $x = y^7 \mod 403 = 349^7 \mod 403 = 630,634,881,591,804,949 \mod 403 = 2 \mod 403$

Проблема в том, что вам не предоставлена информация, что $d = 7$. Конечно, вы могли бы вычислить $d$ из факта, что $103 \cdot d = 1 \mod 360$. Проблема в том, что вам также не дана информация, что порядок $N = 360$. Наконец, вы также могли бы вычислить порядок 403, вычислив следующий продукт: $(p - 1) \cdot (q - 1)$. Но вам также не сказано, что $p = 13$ и $q = 31$.

Конечно, компьютер все еще мог бы относительно легко решить задачу RSA для этого примера, поскольку задействованные простые числа не велики. Но когда простые числа становятся очень большими, он сталкивается с практически невыполнимой задачей.
Мы теперь рассмотрели проблему RSA, набор условий, при которых она становится сложной, и лежащую в ее основе математику. Как это может помочь с асимметричной криптографией? В частности, как мы можем использовать сложность проблемы RSA в определенных условиях для создания схемы шифрования или схемы цифровой подписи?

Один из подходов заключается в том, чтобы взять проблему RSA и разработать схемы прямым способом. Например, предположим, что вы сгенерировали набор переменных $\Pi$, как описано в проблеме RSA, и убедились, что $p$ и $q$ достаточно велики. Вы устанавливаете свой открытый ключ равным $(N, e)$ и делитесь этой информацией со всем миром. Как описано выше, вы держите в секрете значения $p$, $q$, $\phi(n)$ и $d$. Фактически, $d$ является вашим закрытым ключом.

Любой, кто хочет отправить вам сообщение $m$, которое является элементом $C_N$, может просто зашифровать его следующим образом: $c = m^e \mod N$. (Здесь шифртекст $c$ эквивалентен значению $y$ в проблеме RSA.) Вы можете легко расшифровать это сообщение, просто вычислив $c^d \mod N$.

Вы также можете попытаться создать схему цифровой подписи таким же образом. Предположим, что вы хотите отправить кому-то сообщение $m$ с цифровой подписью $S$. Вы могли бы просто установить $S = m^d \mod N$ и отправить пару $(m,S)$ получателю. Любой может проверить цифровую подпись, просто проверив, равно ли $S^e \mod N = m \mod N$. Однако любому атакующему будет очень сложно создать действительное $S$ для сообщения, учитывая, что у него нет $d$.

К сожалению, превращение самой по себе сложной проблемы, проблемы RSA, в криптографическую схему не так просто. Для прямой схемы шифрования вы можете выбирать только взаимно простые числа с $N$ в качестве ваших сообщений. Это не оставляет нам много возможных сообщений, определенно недостаточно для стандартной коммуникации. Кроме того, эти сообщения должны быть выбраны случайным образом. Это кажется несколько непрактичным. Наконец, любое сообщение, выбранное дважды, приведет к точно такому же шифртексту. Это крайне нежелательно в любой схеме шифрования и не соответствует никаким строгим современным стандартам безопасности в шифровании.

Проблемы становятся еще хуже для нашей прямой схемы цифровой подписи. Как оно есть, любой атакующий может легко подделать цифровые подписи, просто сначала выбрав взаимно простое с $N$ в качестве подписи, а затем вычислив соответствующее исходное сообщение. Это явно нарушает требование о невозможности подделки.

Тем не менее, добавив немного изощренной сложности, проблему RSA можно использовать для создания безопасной схемы шифрования открытого ключа, а также безопасной схемы цифровой подписи. Мы не будем вдаваться в детали таких конструкций здесь. [4] Важно, однако, что эта дополнительная сложность не меняет фундаментальную основную проблему RSA, на которой основаны эти схемы.

**Примечания:**

[4] Смотрите, например, Jonathan Katz и Yehuda Lindell, _Введение в современную криптографию_, CRC Press (Boca Raton, FL: 2015), стр. 410–32 о шифровании RSA и стр. 444–41 о цифровых подписях RSA.

## Оцените курс
<chapterId>f1905f78-8cf7-5031-949a-dfa8b76079b4</chapterId>
<isCourseReview>true</isCourseReview>