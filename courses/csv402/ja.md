---
name: RGBプロトコル、理論から実践へ
goal: RGBを理解し使用するために必要なスキルを身につける
objectives: 

  - RGBプロトコルの基本概念を理解する
  - クライアントサイドの検証とビットコインのコミットメントの原則をマスターする。
  - RGBコントラクトの作成、管理、移管方法を学ぶ
  - RGB対応Lightningノードの操作方法

---
# RGBプロトコルの発見

ビットコインブロックチェーンのコンセンサスルールとオペレーションに基づき、契約と資産の形でデジタル権利を実装し、執行するために設計されたプロトコルであるRGBの世界に飛び込みましょう。この包括的なトレーニングコースでは、「クライアントサイドの検証」や「シングルユースシール」の概念から、高度なスマートコントラクトの実装まで、RGBの技術的かつ実践的な基礎をガイドします。

構造化されたステップバイステップのプログラムを通じて、クライアントサイドの検証、ビットコイン上の決定論的コミットメント、ユーザー間の相互作用パターンのメカニズムを発見します。ビットコインまたはライトニングネットワーク上でRGBトークンを作成、管理、転送する方法を学びます。

あなたが開発者であれ、ビットコイン愛好家であれ、あるいは単にこのテクノロジーについてもっと知りたいと思っている人であれ、このトレーニングコースはRGBをマスターし、ビットコイン上で革新的なソリューションを構築するために必要なツールと知識を提供します。

このコースは、Fulgur'Venturesが主催し、3人の著名な講師とRGBの専門家が教えるライブセミナーに基づいている。

+++
# はじめに

<partId>c6f7a70f-d894-595f-8c0a-b54759778839</partId>

## コースプレゼンテーション

<chapterId>cf2f087b-6c6b-5037-8f98-94fc9f1d7f46</chapterId>

皆さんこんにちは。ビットコインとライトニングネットワーク上で動作するクライアントサイドの検証済みスマートコントラクトシステムであるRGBに特化したこのトレーニングコースへようこそ。このコースの構成は、この複雑なテーマを深く探求できるように設計されています。コースの構成は以下の通りです：

**第1節：理論

最初のセクションは、クライアントサイドの検証とRGBの基礎を理解するために必要な理論的概念に特化しています。このコースで発見するように、RGBは通常ビットコインでは見られない多くの技術的概念を導入しています。このセクションでは、RGB プロトコルに固有のすべての用語の定義を提供する用語集もあります。

**第2節：練習

第2章では、第1章で学んだ理論的概念の応用に焦点を当てます。RGBコントラクトの作成と操作方法を学びます。また、これらのツールを使ったプログラミングの方法も紹介します。これら最初の2つのセクションは、マキシム・オルロフスキーが担当します。

**第3節：アプリケーション

最後のセクションでは、他の講演者がRGBを使った具体的なアプリケーションを紹介し、実際の使用例を強調する。

---
このトレーニングコースは、もともと[Fulgur'Ventures](https://fulgur.ventures/)が主催した、トスカーナ州ヴィアレッジョでの2週間の上級開発ブートキャンプから発展したものです。RustとSDKに焦点を当てた最初の週は、この他のコースにあります：

https://planb.network/courses/lnp402
このコースでは、ブートキャンプの2週目、RGBに焦点を当てる。

**第1週 LNP402:**.

![RGB-Bitcoin](assets/fr/001.webp)

**週目 - 現在のトレーニング CSV402:**.

![RGB-Bitcoin](assets/fr/002.webp)

このライブ・コースの主催者、そして参加した3人の先生方に感謝します：


- マキシム・オルロフスキー *Ex Tenebrae sententia sapiens dominabitur astris.サイファー、AI、ロボット工学、トランスヒューマニズム。RGB、Prime、Radiant、lnp_bp、mycitadel_io & cyphernet_io* のクリエーター；
- ハンター・トゥルージロ *開発者、Rust、Bitcoin、Lightning、RGB* ；
- フェデリコ・テンガ *私は世界をサイファーパンクのディストピアにするために、少しでも努力している。現在はBitfinex*でRGBに取り組んでいる。

このトレーニングコースの文書版は、主に2つの資料を使って作成された：


- ライトニング・ブートキャンプでのマキシム・オルロフスキー、ハンター・トゥルージロ、フレデリコ・テンガのセミナーのビデオ；
- RGBドキュメントは、[Bitfinex](https://www.bitfinex.com/)がスポンサーとなって制作された。

# 理論上のRGB

<partId>80e797ee-3f33-599f-ab82-e82eeee08219</partId>

## 分散コンピューティングの概念の紹介

<chapterId>f52f8af5-5d7c-588b-b56d-99b97176204b</chapterId>

![video](https://youtu.be/AF2XbifPGXM)

RGBは、ビットコインブロックチェーンのコンセンサスルールとオペレーションに基づき、スケーラブルで機密性の高い方法でデジタル権利（契約と資産の形で）を適用し、執行するために設計されたプロトコルである。この第1章の目的は、RGBプロトコルにまつわる基本的な概念と用語を提示することであり、特にクライアント側の検証やシングルユースシールなどの基本的な分散コンピューティングの概念との密接な関連性を強調することである。

この章では、**分散コンセンサスシステム**の基礎を探求し、RGBがこの技術ファミリーにどのように適合するかを見ていきます。また、RGBがなぜ拡張可能でビットコイン自身のコンセンサスメカニズムから独立している一方で、必要に応じてコンセンサスメカニズムに依存することを目指しているのかを理解するのに役立つ主な原則を紹介します。

### はじめに

分散コンピューティングはコンピュータサイエンスの一分野であり、ノードのネットワーク上で情報を流通させ、処理するためのプロトコルを研究する。これらのノードとプロトコルのルールを合わせて分散システムと呼ぶ。このようなシステムを特徴づける本質的な性質には、次のようなものがある：


- 各ノードが特定のデータを独立に検証・妥当性確認**できること；
- ノードは（プロトコルに依存して）情報の完全または部分的なビューを構築することができる。これらのビューは分散システムの**状態**である；
- データのタイムスタンプが確実に押され、イベントの順序（状態の順序）についてコンセンサスが得られるようにするための、**時系列的な**操作の順序。

特に、分散システムにおける**コンセンサス**という概念は、2つの側面を含んでいる：


- 状態変化の有効性**の認識（プロトコル規則による）；
- これらの状態変化の**順序**に関する合意は、検証されたオペレーションを事後的に書き換えたり、逆に検証したりすることを不可能にする（これはビットコインでは「ダブルスペンドプロテクション」としても知られている）。

ブロックチェーンのデータ構造とProof-of-Work（PoW）アルゴリズムの併用により、機能的でパーミッションのない分散コンセンサスメカニズムの最初の実装が、サトシ・ナカモトによってビットコインで導入された。このシステムでは、ブロック履歴の信憑性は、ノード（マイナー）がブロック履歴に費やした計算能力に依存する。したがって、ビットコインは、万人に開かれた（*無許可*）分散型コンセンサスシステムの主要かつ歴史的な例である。

ブロックチェーンと分散コンピューティングの世界では、2つの基本的なパラダイムを区別することができる： *伝統的な意味での**ブロックチェーン***と、***ステート・チャネル***であり、その最も良い例がライトニング・ネットワークである。ブロックチェーンは、時系列に並べられたイベントの登録と定義され、オープンでパーミッション・フリーのネットワーク内でコンセンサスによって複製される。一方、ステート・チャネルはピアツーピア・チャネルであり、2人（またはそれ以上）の参加者がオフチェーンで更新された状態を維持することを可能にする。

ビットコインの文脈では、あなたは間違いなく、マイニング、分散化、ブロックチェーン上のトランザクションの最終性の原則、および支払いチャネルがどのように機能するかに精通しています。RGBでは、ブロックチェーンやライトニングとは異なり、スマートコントラクトの状態遷移をローカル（クライアント側）に保存して検証する、**クライアント側検証**と呼ばれる新しいパラダイムを導入しています。これは他の「DeFi」技術（_rollups_、_plasma_、_ARK_など）とも異なり、クライアントサイド検証はブロックチェーンに依存して二重支出を防ぎ、タイムスタンプシステムを持ち、オフチェーンの状態と遷移の登録を関係者のみに保持します。

![RGB-Bitcoin](assets/fr/003.webp)

このデータはネットワーク上でグローバルに複製されないため、契約の状態を保持するために必要なクライアント側のデータのセットを指します。最後に、クライアントサイドの検証を活用するプロトコルであるRGBの理論的根拠と、なぜそれが既存のアプローチ（ブロックチェーンとステートチャネル）を補完するのかを見ていきます。

### 分散コンピューティングにおけるトリレンマ

クライアントサイドの検証とRGBが、ブロックチェーンやライトニングでは解決できない問題にどのように対処しているかを理解するために、分散コンピューティングにおける3つの主要な「トリレンマ」を発見しよう：


- スケーラビリティ、分散化、プライバシー** ；
- CAP**定理（一貫性、可用性、パーティション耐性） ；
- CIA**のトリレンマ（機密性、完全性、可用性）。

#### 1.スケーラビリティ、分散化、機密性


- ブロックチェーン(ビットコイン)*2

ブロックチェーンは高度に分散化されているが、拡張性はあまり高くない。さらに、すべてがグローバルで公開された登録簿にあるため、機密性には限界がある。ゼロ知識技術（秘密取引、ミンブルウィンブルスキームなど）で機密性を向上させようとすることはできるが、パブリックチェーンでは取引グラフを隠すことはできない。


- ライトニング/州チャンネル

ライトニング・ネットワークのような）ステート・チャネルは、取引がオフチェーンで行われるため、ブロックチェーンよりもスケーラブルでプライベート性が高い。しかし、特定の要素（資金取引、ネットワーク・トポロジー）を公表する義務や、ネットワーク・トラフィックの監視により、機密性が一部損なわれる可能性がある。分散化にも問題がある。ルーティングには現金が必要で、主要なノードは集中化ポイントになりうる。これはまさにLightningで見られ始めている現象である。


- クライアント側のバリデーション（RGB）**。

この新しいパラダイムは、さらにスケーラブルで機密性が高い。なぜなら、ゼロ開示のプルーフ・オブ・ナレッジ技術を統合できるだけでなく、誰も全登録を保持していないため、トランザクションのグローバルグラフが存在しないからである。スマート・コントラクトの発行者は、（イーサリアムにおける「コントラクト・デプロイヤー」のような）中心的な役割を持つことができる。しかし、ブロックチェーンとは異なり、クライアントサイドの検証では、興味のあるコントラクトだけを保存して検証するため、既存のすべての状態をダウンロードして検証する必要がなくなり、スケーラビリティが向上する。

![RGB-Bitcoin](assets/fr/004.webp)

#### 2.CAP定理（一貫性、可用性、パーティション耐性）

CAP定理は、分散システムが一貫性（*Consistency*）、可用性（*Availability*）、分割耐性（*Partition tolerance*）を同時に満たすことは不可能であることを強調している。


- ブロックチェーン

ブロックチェーンは一貫性と可用性を好むが、ネットワークの分割は苦手だ。ブロックを見ることができなければ、行動することもネットワーク全体と同じ見解を持つこともできない。


- 稲妻**（フランス語）

状態チャネルのシステムには可用性とパーティショニング耐性があるが（ネットワークが分断されても2つのノードは互いに接続し続けることができるため）、全体的な一貫性はブロックチェーン上のチャネルの開閉に依存する。


- クライアント側のバリデーション（RGB）**。

RGBのようなシステムは、一貫性（各参加者は曖昧さを排除してローカルにデータを検証する）とパーティショニング耐性（自律的にデータを保持する）を提供するが、グローバルな可用性は保証しない（全員が関連する履歴の断片を持っていることを確認する必要があり、参加者の中には何も公表しなかったり、特定の情報の共有をやめたりする者もいるかもしれない）。

![RGB-Bitcoin](assets/fr/005.webp)

#### 3.CIAのトリレンマ（機密性、完全性、可用性）

このトリレンマは、機密性、完全性、可用性のすべてを同時に最適化することはできないことを思い起こさせる。ブロックチェーン、ライトニング、クライアントサイドの検証は、このバランスに異なる形で当てはまる。各次元で優れた保証を提供する首尾一貫したパッケージを得るためには、複数のアプローチ（ブロックチェーンのタイムスタンプ、Lightningの同期アプローチ、RGBによるローカル検証）を組み合わせる必要がある。

![RGB-Bitcoin](assets/fr/006.webp)

### ブロックチェーンの役割とシャーディングの概念

ブロックチェーン（この場合はビットコイン）は、主に_タイムスタンプ_メカニズムと二重支出からの保護として機能します。スマートコントラクトや分散型システムの完全なデータを挿入する代わりに、トランザクションに対する**暗号化されたコミットメント**（_commitments_）を単純に含める（Client-side Validationの意味で、「状態遷移」と呼ぶことにする）。このように：


- ブロックチェーンを大量のデータとロジックから解放する；
- 各ユーザーは、グローバルな状態を複製するのではなく、自分の契約部分（自分の「*シャード*」）に必要な履歴だけを保存する。

シャーディングとは、分散型データベース（FacebookやTwitterなどのソーシャルネットワークのMySQLなど）に端を発する概念である。データ量と同期の待ち時間の問題を解決するために、データベースは_shard_（アメリカ、ヨーロッパ、アジアなど）に分割される。各セグメントはローカルに一貫性があり、他のセグメントとは部分的にしか同期していない。

RGBタイプのスマート・コントラクトでは、コントラクト自体に従ってシャードする。各コントラクトは独立したシャードです。例えば、USDTトークンだけを保持している場合、USDCのような別のトークンの履歴全体を保存したり検証したりする必要はありません。ビットコインでは、ブロックチェーンはシャーディングを行いません。クライアント側の検証では、各参加者は自分が保持または使用する契約データのみを保持します。

したがって、エコシステムを次のように想像することができる：


- ブロックチェーン（ビットコイン）**は、最小限のレジスタの完全な複製を保証し、タイムスタンプ層として機能する基盤である；
- ライトニング・ネットワーク**は、ビットコイン・ブロックチェーンのセキュリティと最終決済をベースとしながらも、高速で機密性の高い取引を実現します；
- RGBとクライアント側の検証**により、ブロックチェーンを乱雑にしたり機密性を失ったりすることなく、より複雑なスマート・コントラクト・ロジックを追加できる。

![RGB-Bitcoin](assets/fr/007.webp)

これら3つの要素は、「レイヤー2」、「レイヤー3」といった直線的なスタックではなく、三角形の全体を形成する。ライトニングはビットコインに直接接続することも、RGBデータを組み込んだビットコイン取引に関連付けることもできる。同様に、「BiFi」用途（ビットコイン上の金融）は、機密性、スケーラビリティ、契約ロジックのニーズに応じて、ブロックチェーン、ライトニング、RGBと組み合わせることができる。

![RGB-Bitcoin](assets/fr/008.webp)

### 状態遷移の概念

どのような分散システムにおいても、検証メカニズムの目的は、**状態変更の有効性と時系列順序を決定できる**ことである。その目的は、プロトコルのルールが遵守されていることを検証し、これらの状態変化が確定的で揺るぎない順序で互いに続いていることを証明することである。

この検証が**Bitcoin**の文脈でどのように機能するのかを理解し、より一般的に、Client-side Validationの背後にある哲学を把握するために、Client-side Validationがそれらとどのように異なり、どのような最適化を可能にするのかを見る前に、まずBitcoinブロックチェーンのメカニズムを振り返ってみましょう。

![RGB-Bitcoin](assets/fr/009.webp)

ビットコインのブロックチェーンの場合、取引の検証は単純なルールに基づいている：


- すべてのネットワークノードはすべてのブロックとトランザクションをダウンロードする；
- これらのトランザクションを検証し、UTXOセット（すべての未使用出力）の正しい進化を検証する；
- このデータは（ブロックの形で）保存され、必要に応じて履歴を再生することができる。

![RGB-Bitcoin](assets/fr/010.webp)

しかし、このモデルには2つの大きな欠点がある：


- スケーラビリティ**：各ノードは全員のトランザクションを処理し、検証し、アーカイブする必要があるため、トランザクション容量には明らかな限界があり、特に最大ブロックサイズ（クッキーを除くビットコインの場合、10分間で平均1MB）と連動している；
- プライバシー**：すべての情報は公開され、保存される（金額、宛先アドレスなど）。

![RGB-Bitcoin](assets/fr/012.webp)

実際には、このモデルはベースレイヤー（レイヤー1）としてのビットコインには有効だが、高いトランザクションスループットとある程度の機密性を同時に必要とする、より複雑な用途には不十分となる可能性がある。

ネットワーク全体がすべてのトランザクションを検証して保存するのではなく、各参加者（クライアント）が自分に関係する履歴の一部だけを検証するのである：


- ある資産（またはその他のデジタル資産）を受け取ったとき、その資産につながる操作の連鎖（状態遷移）を知り、検証し、その正当性を証明すればよい；
- この一連の操作は、***Genesis***（最初の発行）から最新のトランザクションまで、非循環有向グラフ（DAG）またはシャード、すなわち全体の履歴の一部を形成する。

![RGB-Bitcoin](assets/fr/013.webp)

同時に、ネットワークの残りの部分（より正確には、Bitcoinのような基礎となるレイヤー）が、このデータの詳細を見ることなく最終的な状態をロックできるように、クライアント側の検証は、***コミットメント***という概念に依存している。

コミットメント*とは、ビットコインのトランザクションに挿入される暗号コミットメントのことで、一般的には_hash_（たとえばSHA-256）であり、プライベートデータが含まれていることを証明するものです。

これらのコミットメントのおかげで、我々は証明することができる：


- 情報の存在（ハッシュにコミットされるため）；
- この情報の先行性（ブロックチェーンに固定され、日付とブロックの順番でタイムスタンプが押されるため）。

しかし、正確な内容は明らかにされず、機密性が保たれる。

具体的に言うと、RGBの状態遷移の仕組みはこうだ：


- 新しい状態遷移（例えばRGBトークンの転送）を準備する；
- このトランジションに対する暗号コミットメントを生成し、ビットコイン取引に挿入する（これらのコミットメントはRGBプロトコルでは「*アンカー*」と呼ばれる）；
- 取引相手（受信者）は、この資産に関連する顧客側の履歴を検索し、スマートコントラクトの発生から、あなたがそれに送信するトランジションまで、エンドツーエンドの一貫性を検証する。

![RGB-Bitcoin](assets/fr/014.webp)

クライアント側のバリデーションには、2つの大きな利点がある：


- スケーラビリティ:**

ブロックチェーンに含まれるコミットメント（*コミットメント*）は小さい（数十バイトのオーダー）。これによって、ハッシュのみを含める必要があるため、ブロックスペースが飽和することはない。また、各ユーザーは自分の履歴の断片（自分の_stash_）を保存するだけでよいため、オフチェーンプロトコルの進化も可能になる。


- プライバシー

取引そのもの（つまりその詳細な内容）はオンチェーンで公開されません。フィンガープリント（*ハッシュ*）だけが公開される。したがって、金額、アドレス、コントラクトロジックは非公開のままであり、レシーバーは過去のすべてのトランザクションを検査することで、自分のシャードの妥当性をローカルで検証することができる。受信者がこのデータを公開する理由は、紛争が発生した場合や証明が必要な場合を除けばない。

RGBのようなシステムでは、異なるコントラクト（または異なるアセット）からの複数の状態遷移を、単一の_commitment_を介して単一のビットコイントランザクションに集約することができる。このメカニズムは、オンチェーンのトランザクションとオフチェーンのデータ（クライアントサイドで検証されたトランジション）の間に決定論的でタイムスタンプ付きのリンクを確立し、複数のシャードを単一のアンカーポイントに同時に記録することを可能にし、オンチェーンのコストとフットプリントをさらに削減します。

実際には、このビットコイン取引が検証されると、ブロックチェーンにすでに記録されているハッシュを変更することが不可能になるため、基礎となる契約の状態が恒久的に「ロック」される。

![RGB-Bitcoin](assets/fr/015.webp)

### 隠し場所のコンセプト

隠し場所**は、RGBスマートコントラクトの整合性と履歴を維持するために参加者が絶対に保持しなければならないクライアント側のデータのセットです。共有情報から特定の状態をローカルに再構築できるLightningチャネルとは異なり、RGBコントラクトのスタッシュは他の場所に複製されません。履歴の共有に責任があるため、それを紛失した場合、誰もそれを復元することはできません。これが、RGBで信頼できるバックアップ手順を持つシステムを採用する必要がある理由です。

![RGB-Bitcoin](assets/fr/016.webp)

### シングルユース・シール：その起源と運用

通貨のような資産を受け入れる場合、2つの保証が不可欠である：


- 受け取った商品の真偽；
- 二重出費を避けるため、受け取った品物の一意性。

銀行券のような物理的な資産の場合、複製されていないことを証明するには物理的な存在だけで十分だ。しかし、資産が純粋に情報的なものであるデジタルの世界では、情報は容易に増殖し、複製される可能性があるため、この検証はより複雑になる。

先に見たように、送信者が状態遷移の履歴を明らかにすることで、RGBトークンの真正性を確保することができる。開始トランザクション以降のすべてのトランザクションにアクセスすることで、トークンの真正性を確認できる。この原理はビットコインに似ており、コインの履歴を元のcoinbaseトランザクションまで遡ることで、その正当性を確認することができる。ただし、ビットコインとは異なり、RGBにおけるこの状態遷移の履歴は非公開であり、クライアント側に保持される。

RGBトークンの二重使用を防ぐため、私たちは「**シングルユースシール**」と呼ばれるメカニズムを使用しています。このシステムは、各トークンが一度使用されると、不正に二度目は再使用できないことを保証します。

シングル・ユース・シールは、ピーター・トッドによって2016年に提案された暗号プリミティブで、物理的な封印の概念に似ている。一度容器に封印が施されると、不可逆的に封印を解かない限り、開封や変更は不可能になる。

![RGB-Bitcoin](assets/fr/018.webp)

このアプローチをデジタルの世界に置き換えることで、一連の出来事が実際に起こったこと、そしてもはや事後的に変更することができないことを証明することが可能になる。このように、シングル・ユース・シールは、「ハッシュ＋タイムスタンプ」という単純なロジックを超えて、**一度だけ**閉じることができるシールという概念を追加している。

![RGB-Bitcoin](assets/fr/017.webp)

シングル・ユース・シールが機能するためには、発行の有無を証明することが可能で、いったん情報が広まると改ざんが難しい（不可能ではないにしても）発行証明媒体が必要だ。ブロックチェーン**（ビットコインのような）は、この役割を果たすことができる。そのアイデアは次のようなものだ：


- あるメッセージ `h(m)` に関するあるコミットメントが、メッセージ `m` の内容を明かすことなく聴衆に公開されたことを証明したい；
- h(m')`の代わりに他の競合する`h(m')`メッセージ・コミットメントが公表されていないことを証明したい；
- また、メッセージ `m` がある日付より前に存在していることをチェックできるようにしたい。

ブロックチェーンは、この役割に理想的に適している。トランザクションがブロックに含まれるとすぐに、ネットワーク全体がその存在と内容について、改ざん不可能な同じ証明を持つことになる（少なくとも部分的には、「コミットメント」がメッセージの真正性を証明する一方で詳細を隠すことができるため）。

したがって、シングル・ユース・シールは、（現段階ではまだ未知の）メッセージを、すべての関係者が検証できる方法で、一度だけ公表するという正式な約束とみなすことができる。

単純なコミットメント（ハッシュ）やタイムスタンプが存在する日付を証明するのとは異なり、シングルユースシールは、**代替コミットメント**が共存できないという追加保証を提供します。

次の比較は、この原則を理解するのに役立つ：


- 暗号コミットメント（ハッシュ）**：ハッシュ関数を使えば、あるデータ（数値）のハッシュを公開することでコミットできる。そのデータは、事前イメージを公開するまで秘密のままだが、事前に知っていたことを証明できる；
- タイムスタンプ（ブロックチェーン）**：このハッシュをブロックチェーンに挿入することで、正確な時点（ブロックに含まれる時点）でそれを知っていたことも証明する；
- シングルユースシール**：シングルユーズシールでは、コミットメントを一意にすることで、さらに一歩進める。単一のハッシュでは、矛盾するコミットメントを並行して複数作成することができる（家族に「男の子です*」と発表し、個人的な日記に「女の子です*」と発表する医師の問題）。シングルユーズシールは、コミットメントをビットコインブロックチェーンなどのプルーフ・オブ・パブリケーション媒体に接続することで、この可能性を排除し、UTXOの支出がコミットメントを決定的に封印する。一度使用されたUTXOは、コミットメントを置き換えるために再度使用することはできません。

| シングル・ユース・シール｜タイムスタンプ｜シンプルなコミットメント（ダイジェスト/ハッシュ）｜シングル・ユース・シール

| -------------------------------------------------------------------------------- | ------------------------------- | ---------- | ---------------- |

| はい｜はい｜はい｜はい｜はい｜コミットメントの公表はメッセージを明らかにしない

| コミットメントの日付の証明／ある日付以前のメッセージの存在｜不可能｜可能｜あり得る｜あり得る｜あり得る

| 他のコミットメントが存在し得ないことの証明｜不可能｜可能

単回使用シールは主に3つの段階で機能する：

**シールの定義


- アリスは事前にシールを公開するためのルール（いつ、どこで、どのようにメッセージを公開するか）を定義する；
- ボブはこれらの条件を受諾または承認する。

![RGB-Bitcoin](assets/fr/021.webp)

**シール・クロージング


- 実行時に、アリスは実際のメッセージ(通常、ハッシュなどの_commitment_ の形で)を公開することで封印を閉じる；
- また、封印が閉鎖され取り消し不能であることを証明する**証人**（暗号学的証明）も提供する。

![RGB-Bitcoin](assets/fr/019.webp)

**シール検証


- 封印が閉じられると、ボブはもう封印を解くことはできない；
- ボブは、印鑑、**証人**、メッセージ（または彼のコミットメント）を収集し、すべてが一致し、競合する印鑑や異なるバージョンがないことを確認する。

そのプロセスは次のようにまとめられる：

```txt
# Défini par Alice, validé ou accepté par Bob
seal <- Define()
# Fermeture du sceau par Alice avec le message
witness <- Close(seal, message)
# Vérification par Bob
bool <- Verify(seal, witness, message)
```

しかし、クライアント側の検証はもう一歩進んでいる。シールの定義自体がブロックチェーンの外部に残っている場合、誰かが問題のシールの存在や正当性に異議を唱えることが（理論的には）可能になってしまう。この問題を克服するために、連鎖するシングル・ユース・シールが使用される：


- 各閉じた印鑑には、次の印鑑の定義が含まれている；
- これらのクロージャを（その_コミットメントとともに）ブロックチェーン内に（ビットコイントランザクションで）登録する；
- したがって、以前の印章を修正しようとすれば、ビットコインに組み込まれた歴史と矛盾することになる。

これこそがRGBシステムなのだ：


- 公開されたメッセージは、クライアント側で検証されたデータへのコミットメントである；
- 印鑑の定義はビットコインUTXOに関連している；
- このUTXOが使用されるか、同じコミットメントに新しいアウトプットがクレジットされると、シールは閉じられる；
- これらのUTXOを使用するトランザクションチェーンは、発行証明に対応する。RGB上のすべての遷移や状態の変化は、このようにビットコインに固定されている。

結論から言うと


- 封印の定義とは、将来の約束を封印するためのUTXOのことです；
- このUTXOを使用し、コミットメントを含むトランザクションを作成するときに、_seal closing_が発生する；
- 証人は取引そのものであり、あなたがこの内容で印鑑を閉じたことを証明する；
- 封印が解かれていないことを証明することはできないが（UTXOがまだ使われていない、あるいはまだ見たことのないブロックで使われることはない、と絶対に断言することはできない）、本当に封印が解かれたことを証明することはできる。

状態遷移を検証するとき、それが競合するコミットメントで以前に使用されたものではない、一意のUTXOに対応することをチェックします。これが、オフチェーン・スマートコントラクトにおける二重支出のないことを保証している。

### 複数のコミットメントとルーツ

RGBスマートコントラクトは、複数のシングルユースシール（複数のUTXO）を同時に使用する必要があるかもしれない。さらに、1つのビットコイントランザクションが複数の異なるコントラクトを参照し、それぞれが独自の状態遷移をシーリングすることもある。このため、コミットメントが重複して存在しないことを決定論的かつ一意に証明する**マルチコミットメント**メカニズムが必要となる。これはビットコイントランザクションと1つ以上のクライアント側のコミットメント（状態遷移）をリンクする特別な構造で、それぞれが異なるコントラクトに属する可能性がある。次の章でこの概念を詳しく見ていく。

![RGB-Bitcoin](assets/fr/023.webp)

プロジェクトの2つの主要なGitHubリポジトリ（LNPBP組織下）には、第1章で学んだこれらのコンセプトの基本的な実装がまとめられている：


- client_side_validation** ：ローカル検証用のRustプリミティブを含む；
- single_use_seals**：これらのシールを安全に定義し、閉じるロジックを実装します。

![RGB-Bitcoin](assets/fr/020.webp)

理論的には、これらのソフトウェア・レンガはビットコインにとらわれないものであり、他のどのようなプルーフ・オブ・パブリケーション媒体（別のレジストリ、ジャーナルなど）にも適用できる。実際には、RGBはその堅牢性と広範なコンセンサスのためにビットコインに依存している。

![RGB-Bitcoin](assets/fr/021.webp)

### 一般からの質問

#### シングルユース・シールの普及に向けて

ピーター・トッド氏はまた、_Open Timestamps_プロトコルを作成し、Single-use Sealのコンセプトはこれらのアイデアの自然な拡張です。RGBの他にも、マージマイニングに頼らずにサイドチェーンを構築したり、BIP300のようなドライブチェーンに関連する提案など、他のユースケースを想定することができます。単一のコミットメントを必要とするあらゆるシステムは、原理的にこの暗号プリミティブを利用することができる。今日、RGBは最初の本格的な実装である。

#### データ可用性の問題

クライアントサイド検証では、各ユーザーが履歴の自分自身の一部を保存するため、データの可用性はグローバルに保証されません。契約発行者が特定の情報を保留または取り消した場合、オファーの実際の推移を知ることができない可能性があります。場合によっては（ステーブルコインなど）、発行者は流通量を証明するために公開データを維持することが求められるが、技術的な義務はない。そのため、無制限に供給される意図的に不透明な契約を設計することが可能であり、信頼性に疑問が生じる。

#### シャーディングとコントラクトの分離

各コントラクトは孤立した_shard_を表す：例えば、USDTとUSDCは履歴を共有する必要はない。アトミックスワップはまだ可能だが、これは両者のレジスタをマージすることではない。すべては暗号化されたコミットメントによって行われ、各参加者に全履歴グラフを開示することはない。

### 結論

クライアントサイド検証のコンセプトがブロックチェーンと_state channels_にどのようにフィットするか、分散コンピューティングのトリレンマにどのように対応するか、そしてどのようにビットコインブロックチェーンをユニークに活用して二重支出を回避し、*タイムスタンプ*のために活用するかを見てきた。このアイデアは、**Single-use Seal**という概念に基づいており、自由に再使用することができないユニークなコミットメントを作成することができます。このようにして、各参加者は厳密に必要な履歴のみをアップロードし、ビットコインのセキュリティを背景として保持しながら、スマートコントラクトのスケーラビリティと機密性を高める。

次のステップでは、このSingle-use Sealメカニズムがビットコインで（UTXOを介して）どのように適用されるのか、アンカーがどのように作成され検証されるのか、そして完全なスマートコントラクトがRGBでどのように構築されるのかをより詳細に説明する。特に、多重コミットメントの問題、つまりビットコイン取引が脆弱性や二重コミットメントを導入することなく、異なるコントラクトの複数の状態遷移を同時に封印することを証明する技術的課題を見ていきます。

第2章のより技術的な詳細に飛び込む前に、主要な定義（Client-side Validation、Single-use Seal、アンカーなど）を読み返し、全体的なロジックを心に留めておいてほしい。私たちはビットコイン・ブロックチェーンの強み（セキュリティ、分散化、タイムスタンプ）とオフチェーン・ソリューションの強み（スピード、機密性、スケーラビリティ）を調和させようとしており、これこそがRGBとClient-side Validationが達成しようとしていることなのだ。

## コミットメント層

<chapterId>cc2fe85a-9cc7-5b8c-a00a-c0a867241061</chapterId>

![video](https://youtu.be/FS6PDprWl5Q)

この章では、ビットコインブロックチェーン内のクライアント側検証とシングルユースシールの実装について見ていきます。RGBの**コミットメントレイヤー**（レイヤー1）の主な原則を、特にRGBがビットコイン取引でシールを定義して閉じるために使用する**TxO2**スキームに焦点を当てて紹介します。次に、まだ詳しく取り上げられていない2つの重要な点について説明する：


- 決定論的なビットコインのコミットメント_；
- マルチプロトコルコミットメント。

これらのコンセプトを組み合わせることで、1つのUTXO、ひいては1つのブロックチェーンの上に、複数のシステムやコントラクトを重ね合わせることができる。

記述されている暗号操作は、絶対的な意味では他のブロックチェーンや出版メディアにも適用できるが、ビットコインの特徴（分散化、検閲への耐性、万人への開放性という点）は、**RGB**が必要とするような高度なプログラマビリティを開発するための理想的な基盤となっていることを忘れてはならない。

### ビットコインにおけるコミットメント方式とRGBによる使用

トランザクションの特定の場所にコミットメント（_commitment_）を含める約束をし、この場所がメッセージに閉じるシールのように機能します。しかし、ビットコインのブロックチェーンでは、このコミットメントをどこに置くかを選択するオプションがいくつかあります。

このロジックを理解するために、基本原理を思い出してみよう：_single-use seal_を閉じるには、指定されたメッセージに_commitment_を挿入することで封印された領域を使う。ビットコインでは、これはいくつかの方法で行うことができます：


- 公開鍵またはアドレス**を使用する

特定の公開鍵やアドレスを「シングル・ユース・シール」と決めることができる。この鍵やアドレスが取引でオン・チェーンに登場した時点で、その封印は特定のメッセージで閉じられたことになる。


- ビットコイン**トランザクション出力を使用する

つまり、「シングル・ユース・シール」は正確な「アウトポイント」（TXID＋出力番号のペア）として定義される。この_outpoint_を使い切った時点で、そのシールは閉じられる。

RGBに取り組んでいる間、私たちはビットコインにこれらのシールを実装する少なくとも4つの異なる方法を特定した：


- 公開鍵で捺印を定義し、_output_でそれを閉じる；
- outpoint_で封印を定義し、_output_で封印を閉じる；
- 公開鍵の値で印鑑を定義し、_input_.NETでそれを閉じる；
- 印鑑を_outpoint_で定義し、_input_で閉じる。

| 印章の定義｜印章の閉鎖｜追加要求事項｜主な用途｜可能な係合スキーム｜印章の定義｜印章の閉鎖｜追加要求事項｜主な用途｜可能な係合スキーム

| ------------- | ------------------------- | --------------------- | ----------------------------------------------------------------- | ---------------------------- | ------------------------------ |

| P2(W)PKH｜現時点ではなし｜キーツウィーク、タプトウィーク、オプレット

| TxO2｜トランザクション出力｜トランザクション出力｜ビットコインの決定論的なコミットメントが必要｜RGBv1（ユニバーサル）｜Keytweak、tapret、opret

| PkI｜公開鍵の値｜トランザクションエントリ｜タップルートのみ＆レガシーウォレットと互換性なし｜ビットコインベースのアイデンティティ｜Sigtweak, witweak｜シグウィーク、ウィットウィーク

| TxO1｜トランザクション出力｜トランザクション入力｜Taprootのみ＆レガシーウォレットと互換性なし｜現時点ではなし｜Sigtweak, witweak｜シグウィーク、ウィットウィーク

RGBでは、シール**の定義として**アウトポイント**を使用し、このアウトポイントを使用するトランザクションのアウトプットにコミットメントを配置することにしたので、これらの各構成について詳しく説明することはしない。したがって、以下の概念を導入することができる：


- 「シール定義 "** ：指定された_outpoint_（TXID + 出力番号で識別）；
- "封印終了 "**：この_outpoint_を使用するトランザクションで、メッセージに_commitment_が追加される。

この方式は、RGBアーキテクチャーとの互換性のために選択されたが、異なる用途には他の構成も有用であろう。

TxO2 "の "O2 "は、定義とクロージャーの両方が、トランザクション・アウトプットの支出（または作成）に基づいていることを思い出させる。

### TxO2ダイアグラムの例

注意点として、_single-use seal_を定義する場合、必ずしもオンチェーン・トランザクションを公開する必要はない。例えば、アリスはすでに未使用のUTXOを持っていれば十分だ。彼女は決めることができる：「この_outpoint_（すでに存在する）は今、私の印鑑です。そしてこのUTXOが使われるまで、そのシールはオープンであるとみなされる。

![RGB-Bitcoin](assets/fr/024.webp)

このトランザクションはしばしば「_witness transaction_」と呼ばれる（_segwit_とは無関係で、単に我々がそう呼んでいるだけである）。この新しいトランザクションには、メッセージに対するコミットメントが含まれる。

![RGB-Bitcoin](assets/fr/025.webp)

この例では：


- ボブ（またはアリスが完全な証明を明らかにすることを選んだ人々）以外は、この取引にあるメッセージが隠されていることを知らない；
- アウトポイント_が使われたことは誰でもわかるが、メッセージが実際にトランザクションに固定されているという証拠を握っているのはボブだけである。

このTxO2スキームを説明するために、PGP鍵を失効させるメカニズムとして、_single-use seal_を使うことができる。サーバーに失効証明書を公開する代わりに、アリスはこう言うことができる：「このビットコインの出力は、もし使われたら、私のPGP鍵が失効したことを意味します。

したがって、アリスは特定のUTXOを持ち、そのUTXOには（彼女だけが知っている）ある状態やデータがローカル（クライアント側）で関連付けられている。

アリスはボブに、このUTXOが使われると特定のイベントが発生したとみなされることを知らせる。外からはビットコインの取引しか見えないが、ボブはこの支出には隠された意味があることを知っている。

![RGB-Bitcoin](assets/fr/026.webp)

アリスはこのUTXOを使うと、新しい鍵、あるいは単に古い鍵の失効を示すメッセージの封印を閉じる。このようにして、オンチェーンを監視している人は誰でもUTXOが使われたことを見ることができますが、完全な証明を持っている人だけが、それが正確にPGP鍵の失効であることを知ることができます。

![RGB-Bitcoin](assets/fr/027.webp)

ボブや関係者が隠されたメッセージをチェックするためには、アリスは彼にチェーン外の情報を提供しなければならない。

![RGB-Bitcoin](assets/fr/028.webp)

したがって、アリスはボブに：


- メッセージそのもの（例えば、新しいPGPキー）；
- メッセージがトランザクションに関与していたことを暗号的に証明する（_extra transaction proof_または_anchor_と呼ばれる）。

![RGB-Bitcoin](assets/fr/029.webp)

第三者はこの情報を持っていない。第三者には、UTXOが使用されたことだけが分かる。したがって、機密性は保証されている。

構造を明確にするために、2つのトランザクションにプロセスをまとめてみよう：


- トランザクション1**：これにはシールの定義、つまりシールとなるアウトポイントが含まれる。

![RGB-Bitcoin](assets/fr/031.webp)


- トランザクション2**：この_outpoint_を使う。これは封印を閉じ、同じトランザクションでメッセージに_commitment_を挿入します。

![RGB-Bitcoin](assets/fr/033.webp)

したがって、2番目の取引を「目撃者取引」と呼ぶことにする。

これを別の角度から説明すると、2つのレイヤーを表現することができる：


- 最上層（ブロックチェーン、パブリック）**：誰もが取引を見ることができ、_アウトポイント_が使われたことを知ることができる；
- 下層（クライアント側、プライベート）**：アリス（または関係者）だけが、暗号証明と彼女がローカルに保持するメッセージによって、この費用がこのようなメッセージに対応することを知っている。

![RGB-Bitcoin](assets/fr/034.webp)

しかし、封印を閉じる際、「誓約書」をどこに挿入すべきかという問題が生じる。

前のセクションでは、クライアント側の検証モデルをRGBや他のシステムにどのように適用できるかについて簡単に触れた。ここでは、**決定論的なビットコインのコミットメント**に関する部分と、それらをトランザクションに統合する方法に取り組む。このアイデアは、なぜ単一のコミットメントを_witness transaction_に挿入しようとするのかを理解することであり、何よりも他の未公開の競合コミットメントが存在しないことを保証する方法を理解することである。

### 取引におけるコミットメントの場所

あるメッセージがトランザクションに埋め込まれていることを誰かに証明するとき、あなたは同じトランザクションの中に、あなたに明かされていない別のコミットメント（隠された第2のメッセージ）が存在しないことを保証できる必要がある。クライアントサイドのバリデーションが頑健であり続けるためには、トランザクションの中に単一のコミットメントを置くための**決定論的な**メカニズムが必要である。

証人の取引は有名なUTXO（またはシールの定義）を消費し、この消費はシールの閉鎖に相当する。技術的に言えば、各アウトポイントは一度しか使用できないことが分かっている。これこそが、ビットコインの二重支出に対する抵抗力を支えている。しかし、支出トランザクションには複数の入力_、複数の出力_があったり、複雑な方法（コイン結合、ライトニングチャネルなど）で構成されたりする可能性がある。そのため、この構造のどこに「コミットメント」を挿入するかを明確かつ統一的に定義する必要がある。

どのような方法（PkO、TxO2など）であれ、コミットメントを挿入することができる：


- .NET経由の入力**で
    - Sigtweak**（「Sign-to-contract」の原則に似ており、ECDSA署名の`r`コンポーネントを修正する） ；
    - Witweak**（トランザクションの_segregated witness_データが変更される）。
- .NET経由の出力**で：
    - Keytweak**（受信者の公開鍵がメッセージと一緒に "細工 "される） ；
    - Opret**（メッセージは使用不可能な出力 `OP_RETURN` に置かれます） ；
    - Tapret**（または_Taptweak_）は、taprootに依存して、taproot鍵のスクリプト部分にコミットメントを挿入し、公開鍵を決定論的に変更する。

![RGB-Bitcoin](assets/fr/035.webp)

それぞれの方法の詳細は以下の通り：

![RGB-Bitcoin](assets/fr/038.webp)

***シグ・トゥ・コントラクト（サイン・トゥ・コントラクト）：***。

これは「**Sign-to-contract**」として知られる手法である。ランダムに生成されたnonceを、データを含むハッシュで置き換える。こうすることで、トランザクションに余分なスペースを追加することなく、署名が暗黙のうちにあなたのコミットメントを明らかにする。この方法には多くの利点がある：


- オンチェーン・オーバーロードはない(基本的なnonceと同じ場所を使う)；
- 理論的には、nonceは最初はランダムなデータなので、これはかなり離散的である。

しかし、2つの大きな欠点が浮かび上がってきた：


- Taprootの前のマルチシグ：複数の署名者がいる場合、どの署名が_commitment_を実行するかを決める必要があります。署名の順番はさまざまで、署名者が拒否すると、_commitment_の結果をコントロールできなくなります；
- MuSigと共有nonce：Schnorr multisig（*MuSig*）では、nonce生成はマルチパーティアルゴリズムであり、nonceを個別に微調整することは事実上不可能である。

実際には、**sig tweak**は既存のハードウェア（ハードウェアウォレット）やフォーマット（Lightningなど）との互換性も低い。そのため、この素晴らしいアイデアを実践するのは難しい。

***主な調整点（有料契約）：***。

キー・トゥイーク(**key tweak**)は、_pay-to-contract_の歴史的概念を取り上げる。公開鍵 `X` を受け取り、値 `H(message)` を追加することでそれを微調整する。具体的には、`X = x * G`、`h = H(message)`とすると、新しい鍵は `X' = X + h * G`となる。この調整された鍵は、`メッセージ`に対するコミットメントを隠す。元の秘密鍵の所有者は、自分の秘密鍵 `x` に `h` を加えることで、自分がその出力を使う鍵を持っていることを証明できる。理論的には、これはエレガントである：


- commitment_はフィールドを追加することなく入力される；
- オンチェーン・データを追加で保存することはない。

しかし実際には、次のような困難に直面する：


- 標準的な公開鍵は "微調整 "されているため、ウォレットはもはや認識できず、UTXOと通常の鍵を簡単に関連付けることはできない；
- ハードウェア・ウォレットは、その標準的な派生物に由来しない鍵で署名するようには設計されていない；
- スクリプトやディスクリプタなどを適応させる必要がある。

RGBの文脈では、この道は2021年まで想定されていたが、現在の規格とインフラで機能させるには複雑すぎることが判明した。

***微調整:***

もう一つのアイデアは、_inscriptions Ordinals_のようなある種のプロトコルが実践しているもので、データをトランザクションの`witness`セクションに直接置くというものである（それゆえ、"witness tweak "という表現がある）。しかし、この方法は：


- エンゲージメントを即座に可視化する（文字通り、生データを証人に貼り付ける）；
- 検閲の対象となる可能性がある（マイナーまたはノードは、それが大きすぎる場合、または他の任意の特性の場合、リレーを拒否することができる）；
- RGBの目的である慎重さと軽快さに反して、ブロック内のスペースを消費する。

さらに、witnessは特定の文脈で枝刈りできるように設計されているため、ロバストな証明を行うことがより複雑になる可能性がある。

*オープンリターン(opret) :****。

OP_RETURN`はトランザクションの特別なフィールドにハッシュやメッセージを格納することができます。しかし、それはすぐに検出可能です。トランザクションに_commitment_があることを誰もが見ることができ、それは余分な出力を追加するだけでなく、検閲または破棄することができます。これは透明性とサイズを増加させるので、クライアント側の検証ソリューションの観点からはあまり満足のいくものではないと考えられている。

```txt
34-byte_Opret_Commitment =
OP_RETURN   OP_PUSHBYTE_32   <mpc::Commitment>
|_________| |______________| |_________________|
1-byte       1-byte         32 bytes
```

### タプレ

最後の選択肢は、**Tapret*スキームによる**Taproot**（BIP341で導入）の使用である。 *Tapret*は決定論的コミットメントのより複雑な形式で、ブロックチェーン上のフットプリントとコントラクト操作の機密性の点で改善をもたらします。主なアイデアは、[taproot transaction](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)の`Script Path Spend`部分にコミットメントを隠すことである。

![RGB-Bitcoin](assets/fr/036.webp)

コミットメントがどのようにタップルートトランザクションに挿入されるかを説明する前に、コミットメントの**正確な**形式を見てみよう。コミットメントは**相対的に**64バイト文字列に対応しなければならない[構築済み](https://github.com/BP-WG/bp-core/blob/master/dbc/src/tapret/mod.rs#L179-L196)：

```txt
64-byte_Tapret_Commitment =
OP_RESERVED ...  ... .. OP_RESERVED   OP_RETURN   OP_PUSHBYTE_33  <mpc::Commitment>  <Nonce>
|___________________________________| |_________| |______________| |_______________|  |______|
OP_RESERVED x 29 times = 29 bytes      1 byte         1 byte          32 bytes        1 byte
|________________________________________________________________| |_________________________|
TAPRET_SCRIPT_COMMITMENT_PREFIX = 31 bytes                    MPC commitment + NONCE = 33 bytes
```


- 29バイトの`OP_RESERVED`、それに続く`OP_RETURN`、そして`OP_PUSHBYTE_33`が31バイトの_prefix_部を形成する；
- 次に32バイトの_commitment_（通常は**MPC**のMerkleルート）が来て、これに1バイトの**Nonce**を加える（この2番目の部分は合計33バイト）。

つまり、64バイトの`Tapret`メソッドは、`OP_RESERVED`を29バイト前置し、Nonceとして1バイト追加した`Opret`のように見える。

実装、機密性、スケーリングの面で柔軟性を維持するため、Tapretスキームは要件に応じて様々なユースケースを考慮している：


- 既存のスクリプトパス構造を使用せずに、タプレットコミットメントをタプレットトランザクションに組み込むユニークな方法；
- スクリプトパスがすでに装備されているTaprootトランザクションにTapretコミットメントを統合する。

この2つのシナリオをそれぞれ詳しく見てみよう。

#### 既存のスクリプトパスなしでタプレットを組み込む

この最初のケースでは、内部公開鍵 `P` *（内部鍵*）のみを含むタップルート出力鍵（*タップルート出力鍵*） `Q` から開始し、スクリプトパス（*スクリプトパス*）は関連付けません：

![RGB-Bitcoin](assets/fr/047.webp)


- P`: _Key Path Spend_ の内部公開鍵。
- G`：楕円曲線[secp256k1](https://en.bitcoin.it/wiki/Secp256k1)の生成点。
- t = tH_TWEAK(P)`は、[BIP86](https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki#address-derivation)に従って、_タグ付きハッシュ_(例えば`SHA-256(SHA-256(TapTweak) || P)`)によって計算された微調整係数である。これにより、隠されたスクリプトがないことが証明される。

Tapret**コミットメントを含めるには、以下のように、**固有のスクリプト**を持つ**スクリプト・パス支出**を追加する：

![RGB-Bitcoin](assets/fr/048.webp)


- t = tH_TWEAK(P || Script_root)`は、**Script_root**を含む新しい微調整係数となる。
- これは単に`SHA-256(SHA-256(TapBranch) || 64-byte_Tapret_Commitment)`型のハッシュである。

タップルートツリーにおける包含と一意性の証明は、内部公開鍵 `P` 1つに集約される。

#### 既存のスクリプトパスへのタプレットの統合

2つ目のシナリオは、より複雑な`Q`タップルート**の出力に関するもので、この出力にはすでにいくつかのスクリプトが含まれている。例えば、3つのスクリプトからなるツリーがある：

![RGB-Bitcoin](assets/fr/049.webp)


- tH_LEAF(x)` はリーフスクリプトの正規化タグ付きハッシュ関数を示す。
- a,b,c`は、すでにタップルート構造に含まれているスクリプトを表す。

タプレのコミットメントを追加するには、ツリーの最初のレベルに*使用不可能なスクリプト*を挿入し、既存のスクリプトを1つ下のレベルに移動させる必要がある。視覚的には、ツリーは：

![RGB-Bitcoin](assets/fr/050.webp)


- tHABC` は、最上位のグループ`A, B, C`のタグ付きハッシュを表す。
- tHT`は64バイトの`タプレット`に対応するスクリプトのハッシュを表す。

タップルートのルールによれば、各ブランチ／リーフは辞書式ハッシュ順序に従って結合されなければならない。2つのケースが考えられる：


- tHT` > `tHABC`: タプレットのコミットメントはツリーの右に移動する。一意性の証明に必要なのは `tHABC` と `P` だけである；
- tHT` < `tHABC`**: タプレのコミットメントは左に置かれる。右側に他のタプレットのコミットメントがないことを証明するには、`tHAB`と`tHC`を明らかにして、他のそのようなスクリプトがないことを証明しなければならない。

最初のケース（`tHABC < tHT`）の視覚的な例：

![RGB-Bitcoin](assets/fr/051.webp)

番目の場合（`tHABC > tHT`）の例：

![RGB-Bitcoin](assets/fr/052.webp)

#### ノンスによる最適化

機密性を向上させるために、`<Nonce>`の値（64バイトの `Tapret`の最後のバイト）を "マイニング"（正確には "ブルートフォース"）して、`tHABC < tHT`となるようなハッシュ`tHT`を得ようとすることができる。この場合、コミットメントは右側に置かれ、ユーザーはタプレットの一意性を証明するために既存のスクリプトの全内容を明かす必要がなくなる。

要約すると、`Tapret`は、RGBのクライアントサイド検証およびシングルユースシールロジックに不可欠な一意性と曖昧性の要件を尊重しつつ、コミットメントをタップルートトランザクションに組み込む離散的かつ決定論的な方法を提供する。

#### 有効な出口

RGBコミットメントトランザクションの場合、有効なビットコインコミットメントスキームの主な要件は以下の通りである：トランザクション（*ウィットネス・トランザクション*）は証明可能な単一のコミットメントを含んでいなければならない。この要件により、同じトランザクション内でクライアント側で検証されたデータの代替履歴を構築することが不可能になる。つまり、_single-use seal_が閉じるメッセージは一意である。

この原則を満たすために、またトランザクション内の出力数に関係なく、**1つの出力**だけがコミットメント(*commitment*)を含むことができることを要求する。使用されるスキーム（*Opret*または*Tapret*）のそれぞれについて、RGBの_commitment_を含むことができる唯一の有効な出力は、：


- OP_RETURN`（存在する場合）は、*Opret* スキームで最初に出力される；
- Tapret*スキームの最初のタップルート出力（存在する場合）。

トランザクションが1つの`Opret`コミットメントと1つの`Tapret`コミットメントを2つ の別々の出力に含むことは十分可能であることに注意すること。Seal Definitionの決定論的な性質のおかげで、これら2つのコミットメントはクライアント側で検証された2つの異なるデータに対応します。

### RGBの分析と実際的な選択

RGBを始めたとき、トランザクション内のコミットメントを決定論的な方法でどこにどのように置くかを決定するために、これらすべての方法を見直した。私たちはいくつかの基準を定義した：


- さまざまなシナリオ（マルチシグ、ライトニング、ハードウェアウォレットなど）との互換性；
- チェーン上のスペースへの影響 ；
- 導入とメンテナンスの難しさ；
- 守秘義務と検閲への抵抗。

| トレースとオンチェーンのサイジング｜クライアントサイドのサイジング｜ポートフォリオの統合｜ハードウェアの互換性｜ライトニングの互換性｜タップルートの互換性

| --------------------------------------------------- | ------------------------ | ------------------ | ----------------------------- | ------------------------ | ----------------------- | --------------------- |

| Keytweak (決定論的P2C) | 🟢 | 🔴 BOLT, 🔴 Bifrost, 🟠 Taproot, 🟢 MuSig

| Sigtweak（決定論的S2C）｜🟢｜🔴 BOLT、🔴 Bifrost｜🟠 Taproot、🔴 MuSig｜。



| Tapretアルゴリズム：左上ノード｜🔴｜↪So_1F7E2｜↪So_1F7E2｜↪So_1F7E2｜↪So_1F7E2｜BOLT｜↪So_1F7E2｜Bifrost｜↪So_1F7E2｜Taproot｜↪So_1F7E2｜MuSig｜｜...

| Tapret algorithm #4: any node + proof | 🟠 | 🟢 BOLT, 🟢 Bifrost | 🟢 Taproot, 🟢 MuSig |.

| 決定論的コミットメント方式｜標準｜オン・チェーン・コスト｜顧客サイドのエビデンスの大きさ

| ------------------------------------------------------------- | -------------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |

| 鍵ツイーク（決定論的P2C）｜LNPBP-1, 2｜0バイト｜33バイト（ツイーク前の鍵

| Sigtweak（決定論的S2C）｜WIP（LNPBP-39）｜0バイト｜0バイト｜0バイト｜0バイト

| オプレット（OP_RETURN）｜-｜36（v）バイト（TxOut追加）｜0バイト｜（TxOut追加

| タプレットアルゴリズム：左上のノード｜LNPBP-6｜n-of-mのマルチシグで32バイトのウィットネス（8バイト）、スクリプトパスごとに消費｜タップルートのスクリプトレスで0バイト。

| タプレットアルゴリズム#4：任意のノード＋一意性の証明｜LNPBP-6｜単一のスクリプトの場合は証人に32バイト（8バイト）、その他のほとんどの場合は証人に0バイト｜タップルートにスクリプトがない場合は0バイト、タップツリーにスクリプトが1ダースあるまでは65バイト

| レイヤ｜オンチェーンコスト（バイト/バイト）｜オンチェーンコスト（バイト/バイト）｜オンチェーンコスト（バイト/バイト）｜オンチェーンコスト（バイト/バイト）｜オンチェーンコスト（バイト/バイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト

| ------------------------------ | ---------------------------- | ---------------------------- | ---------------------------- | ---------------------------- | ---------------------------- | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ |

| **タイプ** | **タプレット** | **タプレット#4** | **キートゥイーク** | **シグトゥイーク** | **オプレット** | **タプレット** | **タプレット#4** | **キートゥイーク** | **シグトゥイーク** | **オプレット** | **タイプ** | **タプレット#4** | **キートゥイーク** | **シグトゥイーク** | **オプレット

| シングル・シグ｜0｜0｜0｜0｜32｜0｜0｜32｜0?| 0 | 0 |

| ミューシグ（n-of-n）｜0｜0｜0｜32｜0｜0｜32｜？> 0 | 0 |





| マルチシグ2-of-3（タイムアウトあり）｜32/8｜0｜0｜0｜n/a｜32｜64｜65｜32｜n/a｜0｜0｜0

| レイヤー｜オンチェーンコスト（vバイト）｜オンチェーンコスト（vバイト）｜オンチェーンコスト（vバイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト）｜クライアント側コスト（バイト

| -------------------------------- | ---------------------- | ---------------------- | ---------------------- | ------------------------ | ------------------------ |

| タイプ** | **ベース** | **タプレ#2** | **タプレ#4** | **タプレ#2** | **タプレ#4** | **タプレ#4

| ミューシグ（n-of-n）｜16.5｜0｜0｜0｜0｜0｜0｜0

| FROST（n-of-m）｜？| 0 | 0 | 0 | 0 |

| マルチa（n-of-m）｜1+16n+8m｜8｜8｜33*m｜65

| MuSig branch / Multi_a (n-of-m) | 1+16n+8n+8xlog(n) | 8 | 0 | 64 | 65



| 方法｜機密性と拡張性｜相互運用性｜互換性｜移植性｜複雑さ

| ----------------------------------------- | ------------------------------ | ---------------- | ------------- | ----------- | ---------- |

| キーツイーク（決定論的P2C）｜🟢｜🔴｜🟡｜🟡｜🟡｜







| アルゴ・タプレ 第4回任意のノード＋証明｜🜎｜🟢｜🟠｜🔴｜。

研究の過程で、どのコミットメント方式も、現在のLightning標準（Taproot、_muSig2_、または追加の_コミットメント_サポートを採用していない）と完全に互換性がないことが明らかになった。現在、Lightningのチャネル構築（*BiFrost*）を変更し、RGBコミットメントの挿入を可能にするための取り組みが進められている。これは、トランザクション構造、キー、チャネル更新の署名方法を見直す必要がある別の領域です。

分析の結果、実際には他の方法（キー・トゥイーク、シグ・トゥイーク、立会人トゥイークなど）でも別の形で複雑な問題が発生することがわかった：


- オンチェーンの量が多いかどうかだ；
- 既存のウォレットコードと根本的に相性が悪いか、どちらかだ；
- 非協力的なマルチシグでは、どちらかの解決策は実行不可能である。

RGBについては、特に2つの方法が際立っている： ***Opret***と***Tapret***はどちらも "Transaction Output "に分類され、プロトコルで使用されるTxO2モードと互換性がある。

### マルチ・プロトコル・コミットメント - MPC

このセクションでは、**RGB**がどのように決定論的スキーム（`Opret`または`Tapret`に従う）を介してビットコイン取引に記録された単一のコミットメント（*commitment*）内の複数のコントラクト（またはより正確には、それらの_transition bundles_）の集約を処理するかを見ていきます。これを達成するために、様々なコントラクトのメルケル化の順序は、**MPCツリー**（_Multi Protocol Commitment Tree_）と呼ばれる構造で行われます。このセクションでは、このMPCツリーの構築、そのルートの取得方法、そして複数のコントラクトが同じトランザクションを機密かつ明確に共有する方法について見ていく。

マルチ・プロトコル・コミットメント（MPC）は、2つのニーズを満たすように設計されている：


- mpc::Commitment` ハッシュの構築: これは `Opret` または `Tapret` スキームに従ってビットコインのブロックチェーンに含まれ、検証されるすべての状態変更を反映しなければならない；
- 複数のコントラクトを単一の_commitment_に同時に保存することで、複数のアセットまたはRGBコントラクトの個別の更新を単一のビットコイントランザクションで管理することができます。

具体的には、それぞれの _transition bundle_ は特定のコントラクトに属します。この情報はすべて**MPCツリー**に挿入され、そのルート（`mpc::Root`）は再びハッシュ化されて`mpc::Commitment`となる。選択された決定論的方法に従って、ビットコイントランザクション（_witness transaction_）に置かれるのはこの最後のハッシュである。

![RGB-Bitcoin](assets/fr/042.webp)

#### MPCルートハッシュ

実際に（`Opret`または`Tapret`で）オンチェーンに書き込まれる値は `mpc::Commitment` と呼ばれる。これは[BIP-341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)の式に従って計算される：

```txt
mpc::Commitment = SHA-256(SHA-256(mpc_tag) || SHA-256(mpc_tag) || depth || cofactor || mpc::Root )
```

ここで：


- mpc_tag` はタグです：urn:ubideco:mpc:commit#2024-01-31`で、[RGBタグ付け規約](https://github.com/RGB-WG/rgb-core/blob/master/doc/Commitments.md)に従って選択される；
- depth`（1バイト）は*MPCツリー*の深さを示す；
- cofactor`（16ビット、リトルエンディアン）は、ツリー内の各コントラクトに割り当てられる位置の一意性を促進するために使用されるパラメータである；
- mpc::Root`は*MPC Tree*のルートで、次のセクションで説明するプロセスに従って計算される。

![RGB-Bitcoin](assets/fr/044.webp)

#### MPCツリー建設

このMPCツリーを構築するには、各契約がユニークな葉の位置に対応するようにする必要がある。ここで、：


- i = {0,1,...,C-1}`の中の`i`でインデックスされた、含まれるc`の契約；
- 各契約 `c_i` に対して、識別子 `ContractId(i) = c_i` がある。

次に、幅 `w` 、深さ `d` のツリーを `2^d = w` となるように構築する。ツリー内の各契約の位置 `pos(c_i)` は ：

```txt
pos(c_i) = c_i mod (w - cofactor)
```

ここで、`係数`は、各契約で異なるポジションが得られる確率を高める整数である。実際には、反復的なプロセスに従って構築される：


- 最小の深さ（正確な契約数を隠すため、慣例として`d=3`）から始める；
- 我々は様々な`係数`を試す（最大`w/2`まで、またはパフォーマンス上の理由から最大500まで）；
- すべてのコントラクトを衝突させることなく配置できなかった場合、`d`をインクリメントしてやり直す。

目的は、衝突のリスクを最小限に抑えながら、高すぎる木を避けることである。なお、衝突現象は【記念日のパラドックス】(https://en.wikipedia.org/wiki/Birthday_problem)と連動したランダムな分布論理に従っている。

#### 生息する葉

契約 `i = {0,1,...,C-1}` に対して `C` 個の異なる位置 `pos(c_i)` が得られると、各シートはハッシュ関数（*タグ付きハッシュ*）で埋められる：

```txt
tH_MPC_LEAF(c_i) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || 0x10 || c_i || BundleId(c_i))
```

ここで：


- merkle_tag = urn:ubideco:merkle:node#2024-01-31`は、常にRGBのメルクル規約に従って選択される；
- 0x10`は_contract leaf_を識別する；
- c_i`は32バイトの契約識別子（ジェネシスのハッシュから派生）である；
- bundleId(c_i)` は 32 バイトのハッシュで、`c_i` に関連する `State Transitions` のセットを記述します（*Transition Bundle* に集められます）。

#### 無人の葉

コントラクトに割り当てられていない残りのリーフ（つまり `w - C` のリーフ）には、「ダミー」の値（_entropy leaf_）が入れられる：

```txt
tH_MPC_LEAF(j) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || 0x11 || entropy || j )
```

ここで：


- merkle_tag = urn:ubideco:merkle:node#2024-01-31`は、常にRGBのメルクル規約に従って選択される；
- 0x11`は_entropy leaf_を表す；
- エントロピー`は64バイトのランダムな値で、ツリーを構築する人が選ぶ；
- j`はこの葉のツリー内での位置（32ビットのリトルエンディアン）である。

#### MPCノード

w`の葉を生成した後（居住しているかどうかにかかわらず）、メルケル化に進む。内部ノードは以下のようにハッシュ化される：

```txt
tH_MPC_BRANCH(tH1 || tH2) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || b || d || w || tH1 || tH2)
```

ここで：


- merkle_tag = urn:ubideco:merkle:node#2024-01-31`は、常にRGBのメルクル規約に従って選択される；
- b`は分岐係数（8ビット）である。ほとんどの場合、木はバイナリで完全なので、`b=0x02`である；
- d`はツリー内のノードの深さ；
- w`はツリーの幅（256ビットのリトルエンディアン・バイナリ）である；
- tH1`と`tH2`は子ノード（またはリーフ）のハッシュで、すでに上で示したように計算されている。

このように進めていくと、ルート `mpc::Root` が得られる。そして、`mpc::Commitment` を計算し（上で説明したように）、オンチェーンに挿入することができる。

これを説明するために、`C=3`（3つの契約）の例を想像してみよう。その位置は`pos(c_0)=7`、`pos(c_1)=4`、`pos(c_2)=2`と仮定する。その他の葉（位置0, 1, 3, 5, 6）は_entropy leaves_である。下図は、ルートへのハッシュのシーケンスを：


- BUNDLE_i` は `BundleId(c_i)` を表す；
- tH_MPC_LEAF(A)`などは、葉を表している（契約を表すものもあれば、エントロピーを表すものもある）；
- 各ブランチ `tH_MPC_BRANCH(...)` は、その2つの子のハッシュを結合する。

最終的な結果は**mpc::Root**で、次に`mpc::Commitment`となる。

![RGB-Bitcoin](assets/fr/053.webp)

#### MPCシャフトチェック

ベリファイアが `c_i` のコントラクト（とその `BundleId`）が最終的な `mpc::Commitment` に含まれていることを確認したい場合、単純に Merkle プルーフを受け取る。この証明は、リーフ（この場合は `c_i` の _contract leaf_）を辿ってルートに戻るために必要なノードを示している。MPCツリー全体を開示する必要はない。

この例では、`c_2`検証者が必要とするのは、中間ハッシュ（`tH_MPC_LEAF(D)`）、2つの `tH_MPC_BRANCH(...)`、`pos(c_2)`位置証明、`cofactor`値だけである。その後、ローカルでルートを再構築し、`mpc::Commitment` を再計算して、ビットコイントランザクションに書き込まれたものと比較することができる（`Opret` または `Tapret` 内）。

![RGB-Bitcoin](assets/fr/054.webp)

このメカニズムにより、：


- c_2`に対するステータスは、確かに集約情報ブロック（クライアント側）に含まれる；
- オンチェーンの_commitment_は単一のMPCルートを指すので、誰も同じトランザクションで代替の履歴を作ることはできない。

#### MPCの構成概要

マルチプロトコルコミットメント*（MPC）は、RGBがコミットメントの一意性と他の参加者に対する機密性を維持しながら、複数のコントラクトを単一のビットコイン取引に集約することを可能にする原理である。ツリーの決定論的な構築のおかげで、各コントラクトはユニークな位置を割り当てられ、「ダミー」リーフ（*エントロピーの葉*）の存在は、トランザクションに参加しているコントラクトの総数を部分的に隠蔽する。

Merkleツリー全体がクライアントに保存されることはない。単に、関係する契約ごとに_Merkleパス_を生成し、受信者に送信します（受信者はその後、コミットメントを検証できます）。同じUTXOを通過した複数のアセットがある場合もあります。その場合、複数の_Merkleパス_をいわゆる_マルチプロトコルコミットメントブロック_にマージすることで、データの重複を避けることができます。

したがって、それぞれの_Merkle proof_は軽量であり、特にツリーの深さはRGBで32を超えない。また、より多くの情報（断面、エントロピーなど）を保持する "Merkle block "という概念もあり、複数の枝を組み合わせたり分離したりするのに便利である。

だからこそ、RGBを完成させるのにこれほど時間がかかったのです。私たちは2019年から、すべてをクライアントサイドに置き、オフチェーンでトークンを流通させるという全体的なビジョンを持っていた。しかし、複数のコントラクトのためのシャーディング、Merkleツリーの構造、衝突の処理方法、マージ証明などの詳細については、すべて反復が必要でした。

### アンカー：グローバル・アセンブリ

私たちのコミットメント（`Opret`または`Tapret`）とMPC（*Multi Protocol Commitment*）の構築に続いて、RGBプロトコルの**Anchor**の概念に対処する必要があります。アンカーは、ビットコインのコミットメントが実際に特定の契約情報を含んでいることを検証するために必要な要素をまとめた、クライアントサイドで検証された構造です。言い換えれば、アンカーは、上記の_コミットメント_を検証するために必要なすべてのデータを要約します。

アンカーは3つのフィールドから構成される：


- Txid`
- MPCの証明
- エクストラ・トランザクション・プルーフ - ETP

これらのフィールドはそれぞれ、基礎となるビットコイン取引を再構築する問題であれ、（特に`Tapret`の場合）隠されたコミットメントの存在を証明する問題であれ、検証プロセスの一翼を担っている。

#### TxId

Txid` フィールドは `Opret` または `Tapret` コミットメントを含むビットコイントランザクションの 32 バイトの識別子に対応する。

理論的には、Single-use Sealのロジックに従って、各証人トランザクションを指し示す状態遷移の連鎖をトレースすることで、この`Txid`を見つけることが可能である。しかし、検証を容易にし高速化するために、この `Txid` は単純にアンカーに含まれ、検証者はオフチェーン履歴全体を遡る手間を省くことができる。

#### MPCプルーフ

番目のフィールドである`MPC Proof`は、この特定のコントラクト(例 `c_i`)が_Multi Protocol Commitment_に含まれていることを証明するものである。これは：


- pos_i`はMPCツリーにおけるこの契約の位置である；
- cofactor`は、位置の衝突を解決するために定義された値である；
- MPCルートを再構築し、契約識別子とその`トランジションバンドル`がルートにコミットされていることを検証するために使用されるノードとハッシュのセットである。

このメカニズムは、*MPCツリー*の構築に関する前のセクションで説明した：

```txt
pos(c_i) = c_i mod (w - cofactor)
```

次に、決定論的なメルカリゼーションスキームを使用して、すべてのリーフを集約する（コントラクト＋エントロピー）。最後に、`MPC Proof`によってルートをローカルに再構築し、オンチェーンに含まれる`mpc::Commitment`と比較する。

#### エクストラ・トランザクション・プルーフ（ETP

3番目のフィールドである**ETP**は、使用されるコミットメントのタイプに依存 する。コミットメントが `Opret` 型の場合、追加の証明は必要ありません。バリデータはトランザクションの最初の `OP_RETURN` 出力を検査し、そこで `mpc::Commitment` を直接見つけます。

**コミットメントのタイプが`Tapret`**である場合、*Extra Transaction Proof - ETP*と呼ばれる追加の証明を提供しなければならない。これには以下が含まれる：


- コミットメント*が埋め込まれたタップルート出力の内部公開鍵（`P`）；
- スクリプトの正確な位置を証明するために、`スクリプトパス消費`のパートナーノード（Tapret *commitment*がスクリプトに挿入されたとき）：
 - もし`Tapret`の*コミットメント*が右側のブランチ上にあれば、左側のノード（例えば`tHABC`）を明らかにする、
 - もし`Tapret`の*コミットメント*が左側にある場合、右側に他の*コミットメント*が存在しないことを証明するために2つのノード（例えば`tHAB`と`tHC`）を開示する必要がある。
- nonce`は、*コミットメント*をツリーの右側に配置することを可能にし、最適なコンフィギュレーションを "採掘 "するために使用されるかもしれない（証明の最適化）。

Opret`とは異なり、`Tapret`コミットメントはタップルートスクリプトの構造に組み込まれているため、*コミットメント*の場所を正しく検証するためには、タップルートツリーの一部を明らかにする必要がある。

![RGB-Bitcoin](assets/fr/045.webp)

したがって、**アンカー**は、RGBのコンテキストでビットコインのコミットメントを検証するために必要なすべての情報をカプセル化します。アンカーは関連するトランザクション（`Txid`）とコントラクトの位置づけの証明（`MPC Proof`）の両方を示し、`Tapret`の場合は追加の証明（`ETP`）を管理する。このようにして、アンカーは同じトランザクションが他の契約データに再解釈されないようにすることで、オフチェーン状態の完全性と一意性を保護する。

### 結論

この章では、：


- BitcoinでSingle-use Sealのコンセプトを適用する方法（特に_outpoint_経由）；
- トランザクションにコミットメントを決定論的に挿入するための様々な方法（Sig tweak、Key tweak、Witness tweak、op_return、Taproot/Tapret）；
- RGBがタプレットのコミットメントを重視する理由；
- マルチ・プロトコル・コミットメントによるマルチ・コントラクト管理は、特定の点を証明したいときにステート全体や他のコントラクトを公開したくない場合に不可欠である；
- また、_Anchors_の役割も見てきた。これは、すべて（トランザクションTXID、Merkleツリー証明、Taproot証明）を1つのパッケージにまとめたものである。

実際には、技術的な実装は（_client_side_validation_、_commit-verify_、_bp_core_など）いくつかの専用のRust_crate_に分かれている。基本的な概念はそこにあります：

![RGB-Bitcoin](assets/fr/046.webp)

次の章では、RGBの純粋なオフチェーンコンポーネント、すなわちコントラクトロジックを見ていきます。部分的に複製された「有限状態マシン_」として組織されたRGBコントラクトが、データの機密性を保ちながら、ビットコインスクリプトよりもはるかに高い表現力を達成する方法を見ていきます。

## スマート・コントラクトとその状態の紹介

<chapterId>04a9569f-3563-5382-bf53-0c7069343ba0</chapterId>

![video](https://youtu.be/tmAVdyXGmj4)

この章と次の章では、RGB環境内の**スマートコントラクト**の概念に注目し、これらのコントラクトがその**状態を定義し、進化させることができるさまざまな方法を探ります。単一使用シールの順序付けられたシーケンスを使用するRGBアーキテクチャが、スケーラブルな方法で、中央集中型のレジストリを介さずに、様々なタイプの***契約操作***を実行することを可能にする理由について見ていきます。また、契約状態の進化を枠組みする***ビジネスロジック***の基本的な役割についても見ていきます。

### スマート・コントラクトとデジタル無記名権

RGBの目的は、ビットコイン上でスマートコントラクトを実装するためのインフラを提供することである。スマートコントラクト」とは、複数の当事者間で交わされる契約のことで、条項を強制するために人間が介入することなく、自動的かつ計算によって強制される。言い換えれば、契約の法律は、信頼できる第三者ではなく、ソフトウェアによって執行される。

この自動化によって、所有権や契約履行を管理するための集中レジストリ（中央のプラットフォームやデータベースなど）からどのように解放されるのか、という分散化の問題が提起される。RGBが取り上げたオリジナルのアイデアは、「無記名証書」として知られる所有形態に戻ることだ。歴史的に、ある種の証券（債券、株式など）は無記名式で発行され、その文書を物理的に所持する者であれば誰でも権利を行使できるようになっていた。

![RGB-Bitcoin](assets/fr/055.webp)

RGBはこの概念をデジタル世界に適用する。権利（および義務）はオフチェーンで操作されるデータにカプセル化され、このデータの状態は参加者自身によって検証される。これによって、先験的に、公的な登録簿に基づく他のアプローチよりもはるかに高度な機密性と独立性が可能になる。

### スマート・コントラクトRGBステータスの紹介

RGBのスマートコントラクトは、.NETで定義されたステートマシンと見なすことができる：


- 状態**、すなわち、契約の現在の設定を反映する情報のセット；
- ビジネス・ロジック**（ルールのセット）であり、どのような条件下で、誰が状態を変更できるかを記述する。

![RGB-Bitcoin](assets/fr/056.webp)

これらの契約は、単純なトークンの移転に限定されないことを理解することが重要だ。伝統的な資産（トークン、株式、債券）から、より複雑な仕組み（使用権、商業条件など）まで、多種多様なアプリケーションを具現化することができる。契約コードに誰もがアクセスでき、実行可能な他のブロックチェーンとは異なり、RGBのアプローチは、契約へのアクセスと知識を参加者（"***契約参加者***"）に区分する。いくつかの役割がある：


- 契約の発行者**または作成者は、契約の創世記とその初期変数を定義する；
- 権利**（所有権*）またはその他の執行能力を持つ当事者；
- オブザーバー**、特定の情報を見ることは制限される可能性があるが、修正を引き起こすことはできない。

この役割の分離は、承認された人物だけが契約状態とやり取りできるようにすることで、検閲耐性に貢献する。また、RGBに水平方向に拡張する能力を与えます。検証の大部分はブロックチェーンの外で行われ、暗号アンカー（*コミットメント*）だけがビットコインに刻まれます。

### RGBのステータスとビジネス・ロジック

実際的な観点からは、契約の**ビジネス・ロジック**は、RGBが**スキーマ**と呼ぶものに定義されたルールとスクリプトの形をとる。スキーマは：


- 国家構造（どの分野が公的か？どの分野がどの当事者に所有されているか？
- 有効条件（状態の更新を許可する前に何をチェックしなければならないか）；
- 権限（誰が*状態遷移*を開始できるのか？ 誰が監視しかできないのか？）

同時に、**契約状態**はしばしば2つの要素に分かれる：


- A **グローバル状態**：公開部分であり、（設定によっては）すべての人が観察できる可能性がある；
- Owned States**：契約ロジックで参照されるUTXOを介して、オーナーに特別に割り当てられたプライベートな部分。

次の章で説明するように、ステータスの更新（*Contract Operation*）は、（`Opret`または`Tapret`を介して）ビットコインの_commitment_とドッキングし、*Business Logic*スクリプトに準拠しなければ有効とみなされない。

### 契約業務：国家の誕生と進化

RGBの世界では、***契約操作***とは、契約を***古い状態***から***新しい状態***に変更するあらゆるイベントのことである。これらの操作は以下のロジックに従います：


- 契約の現状に留意する；
- ルールや操作（***状態遷移***、最初の状態なら***ジェネシス***、再トリガーするパブリック*バレンシーがあるなら***状態拡張***）を適用する；
- ブロックチェーン上の新しい_コミットメント_によって変更を固定し、1つの_シングルユースシール_を閉じ、別の_シングルユースシール_を作成する；
- 関係する権利者は、トランジションが*スキーマ*に準拠していること、および関連するビットコイントランザクションがオンチェーンで登録されていることを、ローカル（*クライアントサイド*）で検証する。

![RGB-Bitcoin](assets/fr/057.webp)

最終結果は更新されたコントラクトで、現在は異なる状態になっている。この遷移は、小さな暗号フィンガープリント（コミットメント）のみがブロックチェーンに記録されるため、Bitcoinネットワーク全体が詳細に関与する必要はありません。一連のシングルユーズシールは、状態の二重支出や二重使用を防ぎます。

### オペレーション・チェーン：創世記から終末状態まで

RGBスマートコントラクトは、最初の状態である**ジェネシス**から始まる。その後、様々なコントラクト・オペレーションが互いに続き、オペレーションのDAG（*Directed Acyclic Graph*）を形成する：


- 各遷移は前の状態（収束遷移の場合は複数の状態）に基づいている；
- 時系列的な順序は、各遷移がビットコインのアンカーに含まれることで保証され、タイムスタンプが押され、Proof-of-Workによるコンセンサスのおかげで変更不可能である；
- これ以上オペレーションが進行しない場合、**Terminal State**に到達する。

![RGB-Bitcoin](assets/fr/012.webp)

このDAGトポロジーは（単純な線形チェーンの代わりに）、契約の異なる部分が、互いに矛盾しない限り、並行して発展する可能性を反映している。その後、RGBは、関係する各参加者の*クライアント側*の検証によって、矛盾を回避するように配慮する。

### 概要

RGBのスマートコントラクトは、デジタル無記名証券のモデルを導入しており、非中央集権的だが、タイムスタンプと取引の順序を保証するためにビットコインに固定されている。これらのコントラクトの自動実行は、.NETをベースにしている：


- 契約の現在の構成（権利、残高、変数など）を示す**契約状態*；
- どのトランジションが許可され、どのように検証されなければならないかを定義する**ビジネスロジック**（*スキーマ*）；
- コントラクトオペレーション**は、ビットコイントランザクションに固定されたコミットメントによって、この状態を段階的に更新する。

次の章では、オフチェーンレベルでのこれらの***状態***と***状態遷移***の具体的な表現と、それらがビットコインに組み込まれたUTXOとSingle-use Sealにどのように関連するかについて、さらに詳しく説明します。これは、クライアント側の検証に基づくRGBの内部メカニズムが、データの機密性を保持しながらスマートコントラクトの一貫性を維持するためにどのように管理されているかを見る機会となるでしょう。

## RGB契約オペレーション

<chapterId>78c44e88-50c4-5ec4-befe-456c1a9f080b</chapterId>

![video](https://youtu.be/lUTjeuM0oTA)

この章では、スマート・コントラクトの操作と状態遷移がどのように機能するかを、再びRGBプロトコルの中で見ていく。また、複数の参加者が協力して資産の所有権を移転する方法を理解することも目的とする。

### 状態遷移とそのメカニズム

一般的な原則は、状態データが所有者によって保持され、受信者によって検証される、クライアント側の検証である。しかし、RGBの特殊性は、受信者であるボブが、自分のUTXOの1つへの隠された参照を通じて、受信した資産を実際にコントロールするために、契約データに特定の情報を組み込むようアリスに要求するという事実にある。

状態遷移*（RGBにおける基本的な***契約操作***の1つである）のプロセスを説明するために、アリスとボブの間の資産譲渡を段階的に例にとってみよう：

**最初の状況

アリスはローカルで検証されたデータ（*クライアントサイド*）の***隠し場所RGB***を持っている。この隠し場所はBitcoin上の彼女のUTXOの1つを指す。つまり、このデータの_seal definition_は、アリスに属するUTXOを指している。このアイデアは、彼女が資産（例えばRGBトークン）にリンクされた特定のデジタル権利をボブに転送できるようにすることです。

![RGB-Bitcoin](assets/fr/058.webp)

**ボブはUTXOも持っている。

一方、ボブは少なくとも1つのUTXOを自分で持っており、アリスの ものとは直接リンクしていない。BobがUTXOを持っていない場合でも、*witness transaction*そのものを使ってBobに譲渡することは可能である：このトランザクションの出力はコミットメント(_commitment_)を含み、暗黙のうちに新しい契約の所有権をBobに関連付ける。

![RGB-Bitcoin](assets/fr/059.webp)

**新物件の建設（*新状態*）：**。

ボブはアリスに***インボイス***(インボイスの作成については後の章で詳しく説明する)という形でエンコードされた情報を送り、契約のルールに準拠した新しいステートを作成するよう依頼する。この状態には、BobのUTXOの1つを指す新しい*seal定義*が含まれる。こうすることで、Bobはこの新しいステートで定義された資産、例えば一定量のRGBトークンの所有権を与えられる。

![RGB-Bitcoin](assets/fr/060.webp)

*サンプル取引の準備：***。

次にアリスは、前のシールで参照されたUTXO（彼女をホルダーとして正当化したもの）を消費するビットコイントランザクションを作成する。このトランザクションの出力には、（`Opret`または`Tapret`による）*コミットメント*が挿入され、新しいRGBの状態を固定する。Opret`または `Tapret`のコミットメントは（前の章で見たように）*MPCツリー*から導出される。

**ボブへの*委託*の送信:**。

トランザクションをブロードキャストする前に、AliceはBobに、必要なすべての*クライアント側*データ（彼の*隠し場所*）と、Bobに有利な新しいステート情報を含む***Consignment***を送る。この時点で、BobはRGBコンセンサスルールを適用する：


- 委託*に含まれるすべてのRGBデータを検証し、資産の所有権を与える新しい状態も検証する；
- 委託*に含まれる*アンカー*に依拠し、証人取引の時系列（創世記から最新の移行まで）を検証し、ブロックチェーン内の対応するコミットメントを検証する。

**移行完了

もしBobが満足すれば、(例えば*委託*に署名することで)承認を与える ことができる。アリスはそれから準備されたサンプル取引をブロードキャストできる。確認されると、アリスが保持していた封印は閉じられ、ボブによる所有が正式になります。二重支出防止のセキュリティはビットコインと同じメカニズムに基づいている。

![RGB-Bitcoin](assets/fr/061.webp)

新しい状態はボブのUTXOを参照するようになり、以前アリスが持っていた所有権をボブに与える。RGBデータがアンカーされたビットコイン出力は、所有権移転の取り消し不能な証明となる。

2つのコントラクト操作（***ジェネシス**、次に***ステートトランジション***）からなる最小DAG（*Directed Acyclic Graph*）の例では、RGBステート（*クライアントサイド*レイヤー、赤）がビットコインブロックチェーン（*コミットメント*レイヤー、オレンジ）にどのように接続するかを説明することができる。

![RGB-Bitcoin](assets/fr/062.webp)

これは、ジェネシスがシール（*シールの定義*）を定義し、*状態遷移*がこのシールを閉じて別のUTXOに新しいシールを作成することを示している。

この文脈で、用語についていくつか思い出してほしい：


- 課題***の組み合わせ：
    - シール定義***（UTXOを指す）；
    - 所有状態**、すなわち所有に関連するデータ（たとえばトークンの譲渡量）。
- グローバル・ステート**は、契約の一般的なプロパティをまとめ、誰にでも見えるようにし、進化のグローバルな一貫性を保証する。

前章で説明したステート・トランジション**は、コントラクト操作の主な形式である。1つまたは複数の前のステート（ジェネシスまたは別のステート・トランジションから）を参照し、新しいステートに更新する。

![RGB-Bitcoin](assets/fr/063.webp)

この図は、*状態遷移バンドル*において、1つのサンプルトランザクションで複数のシールが閉じられ、同時に新しいシールが開かれる様子を示している。実際、RGBプロトコルの興味深い特徴は、その拡張能力です。複数のトランジションをトランジション・バンドルに集約することができ、各集約は*MPCツリー*の別個のリーフ（一意のバンドル識別子）に関連付けられます。DBC（Deterministic Bitcoin Commitment）メカニズムにより、メッセージ全体が `Tapret` または `Opret` 出力に挿入され、同時に以前のシールが閉じられ、場合によっては新しいシールが定義される。アンカー*は、ブロックチェーンに格納されたコミットメントとクライアント側の検証構造（*クライアントサイド*）を直接つなぐ役割を果たす。

以下の章では、状態遷移の構築と検証に関わるすべてのコンポーネントとプロセスを見ていきます。これらの要素のほとんどは、**RGBコア・ライブラリ**に実装されているRGBコンセンサスの一部です。

### トランジション・バンドル

RGBでは、同じコントラクトに属する(つまり、創世記の**OpId**から派生する同じ**ContractId**を共有する)異なる状態遷移をバンドルすることが可能である。最も単純なケースでは、上記の例のアリスとボブの間のように、**トランジションバンドル**は1つのトランジションだけを含む。しかし、（コイン結合やライトニングチャネルオープンなどの）マルチペイヤーオペレーションのサポートは、複数のユーザーが状態遷移を1つのバンドルにまとめることができることを意味します。

いったん収集されると、これらのトランジションは（MPC + DBCメカニズムによって）単一のビットコイントランザクションに固定される：


- 各状態遷移はハッシュ化され、遷移バンドルにグループ化される；
- トランジションバンドルはそれ自身がハッシュ化され、このコントラクトに対応するMPCツリーのリーフ（BundleId）に挿入される；
- MPCツリーは最終的に証人トランザクションの`Opret`または`Tapret`を通 じて関与し、それによって消費された印鑑は閉じられ、新しい印鑑が定義される。

技術的に言えば、MPCシートに挿入される**BundleId**は、バンドルの*InputMap*フィールドの厳密なシリアライゼーションに適用されるタグ付きハッシュから取得されます：

```txt
BundleId = SHA256( SHA256(bundle_tag) || SHA256(bundle_tag) || InputMap )
```

例えば`bundle_tag = urn:lnp-bp:rgb:bundle#2024-02-03`の場合。

InputMap*は、サンプルトランザクションの各入力 `i`について、対応する状態遷移の *OpId* への参照をリストしたデータ構造である。例えば

```txt
InputMap =
N               input_0    OpId(input_0)    input_1    OpId(input_1)   ...    input_N-1  OpId(input_N-1)
|____________________| |_________||______________| |_________||______________|       |__________||_______________|
16-bit Little Endian   32-bit LE   32-byte hash
|_________________________| |_________________________|  ...  |___________________________|
MapElement1                MapElement2                       MapElementN
```


- N` はトランザクションの中で `OpId` を参照するエントリーの総数である；
- opId(input_j)` は、バンドルに含まれる状態遷移の操作識別子である。

各エントリーを一度だけ、順序よく参照することで、2つの状態遷移で同じシールが2度使われるのを防ぐ。

### ステート生成とアクティブ・ステート

したがって、状態遷移は資産の所有権をある人から別の人に移すために使用できる。しかし、RGBプロトコルで可能な操作はこれだけではありません。プロトコルは3つの**契約操作**を定義している：


- 状態遷移** ；
- ジェネシス** ；
- 州のエクステンション**。

このうち、**Genesis**と**State Extension**は「状態生成操作」と呼ばれることがある。これは非常に重要なポイントである： **Genesis**と**State Extension**は封印を閉じません。むしろ、それらは新しい封印を定義し、ブロックチェーンの履歴で真に検証されるためには、その後の**State Transition**によって使われなければなりません。

![RGB-Bitcoin](assets/fr/064.webp)

コントラクトの**アクティブ状態**は、多くの場合、ビットコインブロックチェーンにおける創世記から始まりすべてのアンカーに続くトランザクションの履歴（DAG）から得られる最新の状態の集合として定義される。すでに廃止された（すなわち、使用済みのUTXOに接続された）古いステートは、もはやアクティブとはみなされませんが、履歴の一貫性をチェックするために不可欠なままです。

### ジェネシス

ジェネシスはすべてのRGB契約の出発点である。これはコントラクト発行者によって作成され、**スキーマ**に従って初期パラメータを定義する。RGBトークンの場合、ジェネシスは例えば：


- 最初に作成されたトークンの数とその所有者；
- 発行可能額の上限；
- 再発行規則、およびどの参加者が対象となるか。

コントラクトの最初のトランザクションであるため、ジェネシスは以前のステートを参照せず、いかなるシールも閉じない。しかし、履歴に表示され検証されるためには、ジェネシスは最初の状態遷移（多くの場合、発行者自身へのスキャン/自動支出トランザクション、またはユーザーへの最初の配布）によって**消費**（クローズ）されなければならない。

### ステート・エクステンション

状態拡張**は、スマート・コントラクトに独自の機能を提供する。この機能により、コントラクトの定義で規定された特定のデジタル権利（*バレンシー*）を、直ちに封印を閉じることなく、償還することが可能になる。多くの場合、これは：


- 分散トークンの問題；
- 資産スワップの仕組み；
- 条件付き再発行（他の資産の破棄などを含む場合もある）。

技術的に言えば、State Extensionは、以前に定義された*Valency*に対応する*Redeem*（特定のタイプのRGB入力）を参照する（例えば、Genesisや別のState Transitionで）。これは新しい印章を定義するものであり、その恩恵を受ける人や状態が利用できる。この印章が有効になるには、その後の状態遷移によって使用されなければならない。

![RGB-Bitcoin](assets/fr/065.webp)

例えば、ジェネシスは発行権（*ヴァレンシー*）を創出する。この権利は、権限を与えられた行為者が行使することができ、その行為者は国家拡張を構築する：


- ヴァレンシー（贖罪）のことである；
- UTXOを指す新しい*割り当て*（新しい*所有状態*データ）を作成する；
- この新しいUTXOの所有者によって発行される将来の状態遷移が、新しく発行されたトークンを実際に移転または配布します。

### 契約業務の構成要素

ここで、RGBの**契約操作**の各構成要素について詳しく見ていきたい。コントラクト・オペレーションは、コントラクトの状態を変更するアクションであり、クライアント側で、正当な受信者によって決定論的な方法で検証される。特に、コントラクト・オペレーションが、一方ではコントラクトの**古い状態**（*Old State*）を考慮し、他方では**新しい状態**（*New State*）の定義を考慮する方法を見ていきます。

```txt
+---------------------------------------------------------------------------------------------------------------------+
|  Contract Operation                                                                                                 |
|                                                                                                                     |
|  +-----+     +-----------------------+      +--------------------------------+      +---------+     +------------+  |
|  | Ffv |     | ContractId | SchemaId |      | TransitionType | ExtensionType |      | Testnet |     | AltLayers1 |  |
|  +-----+     +-----------------------+      +--------------------------------+      +---------+     +------------+  |
|                                                                                                                     |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|  | Metadata                                      |  | Global State                                               |  |
|  |                                               |  | +----------------------------------+                       |  |
|  | +-------------------------------------+       |  | | +-------------------+ +--------+ |                       |  |
|  | |          Structured Data            |       |  | | |  GlobalStateType  | |  Data  | |     ...     ...       |  |
|  | +-------------------------------------+       |  | | +-------------------+ +--------+ |                       |  |
|  |                                               |  | +----------------------------------+                       |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |         +------+
|                                                                                                                     +---------> OpId |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |         +------+
|  | Inputs                                        |  | Assignments                                                |  |
|  |                                               |  |                                                            |  |
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  | | Input #1                                  | |  | | Assignment #1                                          | |  |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
| OpId +--------------> PrevOpId | | AssignmentType | | Index | | |  | | | AssignmentType | | Owned State | | Seal Definition +--------------> Bitcoin UTXO |
+------+       |  | | +----------+ + ---------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  |                                               |  |                                                            |  |
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  | | Input #2                                  | |  | | Assignment #2                                          | |  |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
| OpId +--------------> PrevOpId | | AssignmentType | | Index | | |  | | | AssignmentType | | Owned State | | Seal Definition +--------------> Bitcoin UTXO |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  |                                               |  |                                                            |  |
|  |       ...           ...          ...          |  |     ...          ...             ...                       |  |
|  |                                               |  |                                                            |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|                                                                                                                     |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|  | Redeems                                       |  | Valencies                                                  |  |
|  |                                               |  |                                                            |  |
|  | +------------------------------+              |  |                                                            |  |
+------+       |  | | +----------+ +-------------+ |              |  |  +-------------+  +-------------+                          |  |
| OpId +--------------> PrevOpId | | ValencyType | |  ...   ...   |  |  | ValencyType |  | ValencyType |         ...              |  |
+------+       |  | | +----------+ +-------------+ |              |  |  +-------------+  +-------------+                          |  |
|  | +------------------------------+              |  |                                                            |  |
|  |                                               |  |                                                            |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|                                                                                                                     |
+---------------------------------------------------------------------------------------------------------------------+
```

上の図を見ると、Contract Operationには、**New State**を参照する要素と、更新された**Old State**を参照する要素が含まれていることがわかる。

新国家**の要素とは...：


- アサインメント**で定義されている：
 - シールの定義**；
 - 所有国**である。
- グローバル国家**は、変更することも充実させることもできる；
- Valencies**（おそらくState TransitionまたはGenesisで定義される）。

旧州**は.NET経由で参照される：


- 入力**は、以前の状態遷移の*割り当て*を指す（ジェネシスには存在しない）；
- Redeems**は、以前に定義されたValenciesを参照する（State Extensionsのみ）。

さらに、Contract Operationには、そのオペレーションに特化した、より一般的なフィールドが含まれる：


- ffv`（*ファストフォワード・バージョン*）：契約バージョンを示す2バイトの整数；
- transitionType` または ExtensionType`：ビジネスロジックに従って、トランジションまたはエクステンションのタイプを指定する 16 ビット整数；
- ContractId`：Genesisの契約の*OpId*を参照する32バイトの数字。トランジションとエクステンションに含まれるが、ジェネシスには含まれない；
- schemaId：ジェネシスのみに存在し、コントラクトの構造（*スキーマ*）を表す32バイトのハッシュ；
- testnet`：テストネットとメインネットのどちらを利用しているかを示すブール値。Genesisのみ；
- altlayers1`: Bitcoinに加えてデータのアンカーに使用される代替レイヤー（サイドチェーンまたはその他）を識別する変数。Genesis にのみ存在する；
- メタデータ(metadata)": 一時的な情報を格納できるフィールド。複雑な契約を検証するのに便利だが、最終的なステータスの履歴には記録してはならない。

最後に、これらすべてのフィールドはカスタマイズされたハッシュプロセスによって凝縮され、一意のフィンガープリントである `OpId` を生成する。この`OpId`はTransition Bundleに統合され、プロトコル内で認証され検証される。

したがって、各 *契約オペレーション* は `OpId` という32バイトのハッシュで識別される。このハッシュは、オペレーションを構成するすべての要素のSHA256ハッシュによって計算される。言い換えれば、それぞれの*Contract Operation*は、操作の真正性と一貫性を検証するために必要なすべてのデータを含む、独自の暗号コミットメントを持っている。

RGBコントラクトは、ジェネシスの `OpId` から派生した `ContractId` によって識別される（ジェネシス以前の操作は存在しないため）。具体的には、Genesis の `OpId` を受け取り、バイトオーダーを逆にして Base58 エンコーディングを適用する。このエンコーディングは `ContractId` を扱いやすく、認識しやすくする。

### ステータス更新の方法とルール

契約状態(**Contract State**)は、RGBプロトコルがある契約について追跡しなければならない情報の集合を表す。これは：


- 単一のグローバルステート**：これはコントラクトのパブリックでグローバルな部分であり、すべての人が見ることができる；
- 1つ以上の所有国**：各所有国は固有のシール（したがってビットコイン上のUTXO）に関連付けられます。.Ownedステートと.Ownedステートは区別される：
    - 公的**所有国家、
    - 私的**所有国家。

![RGB-Bitcoin](assets/fr/066.webp)

グローバル・ステート*は、単一のブロックとして*契約操作*に直接含まれる。Owned State*は、*Seal Definition*と並んで、それぞれの*Assignment*で定義される。

RGBの大きな特徴は、グローバル・ステートとオウン・ステートの変更方法である。一般的に2種類の動作がある：


- Mutable**: ステートエレメントがミュータブルと記述されている場合、新しい操作のたびに前のステートが新しいステートに置き換わる。古いデータは時代遅れとみなされる；
- 蓄積型**：状態要素が蓄積型と定義されている場合、新しい操作のたびに、前の状態に上書きすることなく新しい情報が追加される。その結果、一種の履歴が蓄積される。

コントラクトにおいて、ステート要素がミュータブルまたはコンマティキュアブルとして定義されていない場合、この要素は以降の操作で空のままになります（言い換えると、このフィールドの新しいバージョンはありません）。ステート（GlobalまたはOwned）がミュータブルか、累積的か、固定的かを決定するのは、コントラクトスキーマ（つまり、コード化されたビジネスロジック）です。一旦ジェネシスが定義されると、これらのプロパティは、コントラクト自体がそれを許可している場合にのみ、例えば特定のステートエクステンションを介して、変更することができます。

以下の表は、各タイプのコントラクト・オペレーションが、グローバル・ステートとオウンド・ステートをどのように操作できるか（または操作できないか）を示している：

| 創世記｜状態拡張｜状態遷移

| ---------------------------- | :-----:| :-------------:| :--------------:|

| グローバル・ステートを追加する。

| グローバル・ステートの変異**｜ -｜ +｜ **グローバル・ステートの変異**｜ -｜ +｜ **グローバル・ステートの変異

| 所有する州を追加する



| **バレンシーを追加する** | + | + | + + | |

**`+`** : 契約のスキーマが許可していれば可能なアクション。

**`-`**: その操作は、その後の状態遷移によって確認されなければなりません（状態遷移だけではシングルユースシールは閉じられません）。

また、各データの時間的範囲と更新権は以下の表で区別できる：

| メタデータ｜グローバル状態｜所有状態

| ------------------------------- | ---------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |

| 単一の契約操作に対して定義される｜契約に対してグローバルに定義される｜各印鑑に対して定義される（*割り当て*）｜単一の契約操作に対して定義される｜契約に対してグローバルに定義される｜各印鑑に対して定義される（*割り当て*）｜各契約に対して定義される

| 非実現可能なデータ（エフェメラルデータ）｜行為者（発行者等）が発行する取引｜印鑑の権利者（その後の取引で使用できる者）に依存する。

| 状態｜操作の前に（前の操作の*Seal Definition*によって）状態が定義される｜操作の終わりに状態が確立される｜操作の前に（前の操作の*Seal Definition*によって）状態が定義される｜操作の終わりに状態が確立される｜操作の前に（前の操作の*Seal Definition*によって）状態が定義される

### グローバル国家

グローバル・ステートは、しばしば「誰も所有していないが、誰もが知っている」と表現される。グローバル・ステートには、コントラクトに関する一般的な情報が含まれる。例えば、トークン発行のコントラクトでは、：


- ティッカー（トークンの記号的略称）：ticker` ；
- トークンのフルネーム： `name` ；
- 精度（小数点以下の桁数）：精度` ；
- 最初のオファー（および/またはトークンの上限）：issuedSupply`；
- 発行日： `created` ；
- 法的データまたはその他の公開情報： `data`.

このグローバル・ステートは、パブリック・リソース（ウェブサイト、IPFS、Nostr、Torrentなど）に配置し、コミュニティに配布することができる。また、経済的インセンティブ（これらのトークンを保持し、転送する必要性など）により、契約ユーザーは自然にこのデータを自分自身で維持し、伝播するようになる。

### 課題

アサインメント*は、.NET Frameworkを定義するための基本構造である：


- 特定のUTXOを指すシール（*シール定義*）；
- 所有状態*、すなわち、このシールに関連するプロパティまたはデータ。

Assignment*はBitcoinの取引出力のアナログとみなすことができるが、より柔軟性がある。ここに財産移転のロジックがある： *Assignment*は特定のタイプの資産または権利（`AssignmentType`）を印鑑に関連付ける。この印鑑にリンクされたUTXOの秘密鍵を持っている人（またはこのUTXOを使うことができる人）は誰でも、この*所有状態*の所有者とみなされる。

RGBの大きな強みの1つは、*Seal Definition*フィールドと*Owned State*フィールドを任意に公開(*reveal*)または非表示(*conceal*)にできる点にある。これは、機密性と選択性の強力な組み合わせを提供する。例えば、トランジションを検証しなければならない人には公開されたバージョンを提供し、第三者は隠されたバージョン（ハッシュ）だけを見ることで、すべてのデータを公開することなくトランジションが有効であることを証明することができる。実際には、トランジションの `OpId` は常に *隠された* データから計算されます。

![RGB-Bitcoin](assets/fr/067.webp)

#### シールの定義

シール定義*は、明らかにされた形で、4つの基本的なフィールドを持っている：txptr`、`vout`、`blinding`、`method`である：


- txptr**: これはビットコイン上のUTXOへの参照である：
    - ジェネシスシール**の場合は、既存のUTXO（ジェネシスに関連するもの）を直接指す；
    - グラフシール**の場合、：
        - 特定のUTXOを指している場合は、単純な`txid`、
        - または、自己参照を指定する `WitnessTx`：シールはトランザクション自体を指す。これは、例えばライトニングチャネルオープニングトランザクションのように、外部の UTXOが利用できない場合や、受信者がUTXOを持っていない場合に特に有用である。
- vout** : `txptr` が示すトランザクションの出力番号。標準のグラフシールにのみ存在する（`WitnessTx`には存在しない）；
- blinding**：8バイトの乱数。機密性を強化し、UTXOのIDに対する総当たり攻撃を防ぐ；
- method** : 使用されるアンカー方法 (`Tapret` または `Opret`) を示す。

シール定義の*隠蔽*形式は、これら4つのフィールドを連結したSHA256ハッシュ（タグ付き）で、RGBに固有のタグが付いている。

![RGB-Bitcoin](assets/fr/068.webp)

#### 所有国

アサインメント*の2つ目の構成要素は、オーナーシップ・ステートである。グローバル・ステートとは異なり、これはパブリックな形でもプライベートな形でも存在することができる：


- 公有状態**：印鑑に関連するデータは誰もが知っている。例えば、公共のイメージ；
- 非公開状態**: データは非公開であり、所有者(および必要に応じてバリデータも)だけが知っている。たとえば、保有するトークンの数などである。

RGBは、「所有ステート（Owned State）」に対して4つの可能なステート・タイプ（*StateTypes*）を定義している：


- 宣言的**：数値データを含まず、宣言的な権利（投票権など）だけを含む。隠された形と明らかにされた形は同じである；
- Fungible**：(トークンのような)可食量を表す。公開形式では `金額` と `目隠し` がある。隠された形式では、量と目隠しを隠す単一の*Pedersenコミットメント*があります；
- Structured**：構造化データ（最大64KB）を格納する。公開形式では、これはデータブロブである。非表示形式では、このブロブのタグ付きハッシュである：

```txt
SHA-256(SHA-256(tag_data) || SHA-256(tag_data) || blob)
```

例えば：

```txt
tag_data = urn:lnp-bp:rgb:state-data#2024-02-12
```


- ファイルハッシュ `file_hash`、MIMEタイプ `media type`、暗号化ソルト `salt` を格納する。ファイル自体は別の場所にホストされる。非表示の形式では、ハッシュは前の3つのデータ項目でタグ付けされたものである：

```txt
SHA-256(SHA-256(tag_attachment) || SHA-256(tag_attachment) || file_hash || media_type || salt)
```

例えば：

```txt
tag_attachment = urn:rgb:state-attach#2024-02-12
```

要約すると、以下は、公開された状態と隠された状態の4つのタイプである：

```txt
State                      Concealed form                              Revealed form
+---------------------------------------------------------------------------------------------------------
+--------------------------------------------------------------------------------+
|                                                                                |
Declarative        |                              < void >                                          |
|                                                                                |
+--------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             |         +--------+ +----------+       |
Fungible           | | Pedersen Commitement | | <========== |         | Amount | | Blinding |       |
| +----------------------+ |             |         +--------+ +----------+       |
+--------------------------+             +---------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             |         +--------------------+        |
Structured         | |     Tagged Hash      | | <========== |         |     Data Blob      |        |
| +----------------------+ |             |         +--------------------+        |
+--------------------------+             +---------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             | +-----------+ +------------+ +------+ |
Attachments        | |     Tagged Hash      | | <========== | | File Hash | | Media Type | | Salt | |
| +----------------------+ |             | +-----------+ +------------+ +------+ |
+--------------------------+             +---------------------------------------+
```



| --------------------- | -------------- | ------------------------------------ | ----------------------------- | ---------------------------- |

| なし｜64ビット符号付き整数または符号なし整数｜任意の厳密なデータ型｜任意のファイル｜を指定します。

| 情報タイプ**｜なし｜符号付きまたは符号なし｜厳格なタイプ｜MIMEタイプ

| ペデルセンのコミットメント｜目隠し付きハッシュ｜ハッシュされたファイルID



### インプット

契約オペレーション*のインプットは、この新しいオペレーションに費やされる*割り当て*を意味する。Inputは：


- prevOpId` : *割り当て* が配置されていた前の操作の識別子 (`OpId`) ；
- assignmentType` : *割り当て* のタイプ（例えば、トークンの場合は `assetOwner` ） ；
- Index`：前の `OpId` に関連付けられたリストにおける *割り当て* のインデックスで、隠しシールの辞書式ソートの後に決定される。

インプットはジェネシスに現れることはない。また、State Extensionsにも登場しない（State Extensionsは封印を閉じるのではなく、Valenciesに基づいて新しい封印を再定義するため）。

Fungible`型のOwned Statesがある場合、検証ロジックは（スキーマで提供されるAluVMスクリプトを介して）合計の一貫性をチェックします：入力トークン（*Inputs*）の合計は、（新しい*Assignments*内の）出力トークンの合計と等しくなければなりません。

### メタデータ

Metadata**フィールドは最大64KiBで、検証に役立つが、契約の恒久的な状態には統合されない一時的なデータを含めるために使用される。たとえば、複雑なスクリプトの中間計算変数をここに格納することができる。この領域はグローバル履歴に保存されることを意図していないため、Owned States や Global State の範囲外である。

### バレンシーズ

バレンシア**はRGBプロトコルのオリジナルメカニズムである。これはGenesis、State Transitions、またはState Extensionsにある。それらは、ステート拡張によって(*Redeems*を介して)アクティブにすることができ、その後のトランジションによって確定することができる数値的な権利を表している。各Valencyは`ValencyType`（16ビット）で識別される。そのセマンティクス（再発行権、トークンスワップ、バーン権など）はスキーマで定義される。

具体的には、ジェネシスが「再発行する権利」という価 値を定義していると考えることができる。特定の条件が満たされた場合、新しいトークン量を導入するために、ステート・エクステンションがそれを消費する（*Redeem*）。そして、こうして作成されたシールの保有者から発せられる状態遷移が、これらの新しいトークンを移転することができる。

### 償還

RedeemはAssignmentsのInputに相当するValencyである。これは以前に定義されたヴァレンシーが有効化されるからである。Redeemは2つのフィールドで構成される：


- PrevOpId` : Valency が指定された操作の `OpId` ；
- ValencyType`：有効にしたいValencyのタイプ（各`ValencyType`はState Extensionで一度しか使用できません）。

例：Valencyに何がコード化されているかによって、RedeemはCoinSwapの実行に対応することができる。

### RGBステータス特性

これから、RGBにおけるいくつかの基本的な状態特性を見ていく。特に、：


- 厳密な型システム**は、データの正確な型付けを要求する；
- 検証**と**所有権**を分けることの重要性；
- RGBの**コンセンサス進化**システムは、*ファストフォワード*と*プッシュバック*の概念を含む。

いつものように、契約ステータスに関連するすべてのものは、プロトコルで設定されたコンセンサスルールに従ってクライアント側で検証され、その最終的な暗号参照はビットコイン取引に固定されていることを心に留めておいてください。

#### 厳格な型システム

RGBは、*厳密型システム*と決定論的シリアライゼーション・モード（*厳密エンコーディング*）を使用しています。この組織は、契約データの定義、取り扱い、検証において、完全な再現性と精度を保証するために設計されています。

多くのプログラミング環境（JSON、YAML...）では、データ構造は柔軟で、寛容すぎることさえあります。一方、RGBでは、各フィールドの構造と型は明示的な制約で定義されます。例えば：


- 各変数は特定の型（例えば、8ビットの符号なし整数 `u8` や16ビットの符号付き整数など）を持つ；
- 型は合成することができる（入れ子型）。つまり、他の型に基づいて型を定義することができます（例えば、`u8`フィールドや`bool`フィールドを含む集約型など）；
- コレクションは、リスト（*list*）、セット（*set*）、辞書（*map*）を指定することもでき、決定論的な順序で進行する；
- 各フィールドは境界を持つ（*下限* / *上限*）。また、コレクションの要素数にも制限を課している（containment）；
- データはバイト整列され、シリアライゼーションは厳密に定義され明確である。

この厳密なエンコーディング・プロトコルのおかげだ：


- フィールドの順序は、使用される実装やプログラミング言語に関係なく、常に同じである；
- したがって、同じデータセットで計算されたハッシュは再現可能で同一である（厳密に決定論的な*コミットメント*）；
- バウンダリーは、データサイズが無秩序に大きくなるのを防ぐ（フィールドが多すぎるなど）；
- この形式のエンコーディングは、各参加者がデータのシリアライズとハッシュ化の方法を正確に知っているため、暗号検証を容易にする。

実際には、構造（*スキーマ*）と結果のコード（*インターフェース*と関連するロジック）がコンパイルされる。記述言語を使って契約（型、フィールド、ルール）を定義し、厳密なバイナリ形式を生成する。コンパイルされた結果は：


- 各フィールドの*メモリーレイアウト*；
- セマンティック識別子（メモリ構造が変わらなくても、変数名の変更がロジックに影響を与えるかどうかを示す）。

厳密な型システムは、変更の正確な監視も可能にする。構造へのいかなる変更も（フィールド名の変更でさえも）検出可能であり、フットプリント全体の変更につながる可能性がある。

最後に、各コンパイルはフィンガープリント、つまりコード（データ、ルール、検証）の正確なバージョンを証明する暗号化識別子を生成する。例えば、：

```txt
BEiLYE-am9WhTW1-oK8cpvw4-FEMtzMrf-mKocuGZn-qWK6YF#ginger-parking-nirvana
```

これにより、ネットワークで使用されているバージョンの詳細なトレーサビリティを確保しながら、コンセンサスや実装の更新を管理することが可能になる。

RGBコントラクトの状態をクライアント側で検証するのが面倒になるのを防ぐために、コンセンサス・ルールでは、検証計算に関わるデータの最大サイズを「2^16`バイト（64キオ）」と定めている。これは各変数や構造体にも適用される。65536バイト、あるいはそれに相当する数値（32768個の16ビット整数など）を超えてはならない。これはコレクション（リスト、セット、マップ）にも適用され、 `2^16` 要素を超えてはならない。

このリミットは、：


- 状態遷移中に操作されるデータの最大サイズを制御する；
- 検証スクリプトの実行に使用される仮想マシン（*AluVM*）との互換性。

#### 検証＝所有のパラダイム

RGBの大きな革新のひとつは、2つのコンセプトを厳密に分けていることだ：


- バリデーション**：状態遷移が契約のルール（ビジネスロジック、履歴など）を尊重しているかどうかをチェックすること；
- 所有権**（オーナーシップ、またはコントロール）：ビットコインUTXOを所有するという事実が、シングルユーズシールを使用する（またはクローズする）ことを可能にし、したがって状態遷移が行われる。

検証**はRGBソフトウェアスタック（ライブラリ、*コミットメント*プロトコルなど）のレベルで行われる。その役割は、契約の内部ルール（金額、権限など）が尊重されていることを確認することです。オブザーバーや他の参加者もデータ履歴を検証することができる。

一方、所有権**はビットコインのセキュリティに全面的に依存している。UTXOの秘密鍵を所有することは、新しいトランジションを開始する（シングルユースシールを閉じる）能力をコントロールすることを意味する。そのため、誰かがデータを見たり検証したりできたとしても、当該UTXOを所有していなければ状態を変更することはできない。

![RGB-Bitcoin](assets/fr/069.webp)

このアプローチは、より複雑なブロックチェーンで遭遇する古典的な脆弱性（スマートコントラクトのすべてのコードが公開され、誰でも変更可能であるため、ハッキングにつながることがある）を制限する。RGBでは、攻撃者は単純にオンチェーンの状態と対話することはできない。なぜなら、状態に対して行動する権利（*所有権*）はビットコインレイヤーによって保護されているからだ。

さらに、このデカップリングにより、RGBはライトニング・ネットワークと自然に統合することができる。Lightningチャネルは、毎回オンチェーン*コミットメント*に関与することなく、RGBアセットに関与し、移動するために使用することができます。このコースの後の章で、Lightning上でのRGBの統合について詳しく見ていきます。

#### RGBのコンセンサス開発

セマンティック・コードのバージョニングに加えて、RGBには、時間の経過とともに契約のコンセンサス・ルールを進化させたり更新したりするシステムが含まれている。進化には主に2つの形式がある：


- 早送り
- プッシュバック**（フランス語）

早送りは、以前は無効であったルールが有効になったときに発生する。例えば、契約が進化して新しいタイプの `AssignmentType` や新しいフィールド ：


- これは古典的なブロックチェーンのハードフォークと比較することはできませんが、RGBはクライアント側の検証で動作し、ブロックチェーンの全体的な互換性に影響を与えないからです；
- 現実的には、この種の変更は契約操作の`Ffv`（*ファストフォワードバージョン*）フィールドで示される；
- 現所有者に損害はない；
- 一方、新しい受益者（または新しいユーザー）は、新しいルールを認識するためにソフトウェア（財布）をアップデートする必要がある。

プッシュバックとは、それまで有効だったルールが無効になることを意味する。したがって、これはルールの "硬化 "であり、厳密にはソフトフォークではない：


- 既存の保有者にも影響が及ぶ可能性がある（新バージョンでは資産が時代遅れになったり、無効になったりする可能性がある）；
- 新しいルールを採用する者は、古いルールから離脱する；
- 発行者はこの新しいプロトコルでアセットを再発行することを決定する可能性があり、ユーザーは両方のバージョンを管理したい場合、2つの別々のウォレット（1つは古いプロトコル用、もう1つは新しいプロトコル用）を維持することを余儀なくされる。

このRGBコントラクト操作の章では、このプロトコルの基礎となる基本原則を探った。お気づきのように、RGBプロトコルは本質的に複雑であるため、多くの専門用語を使用する必要があります。そこで、次の章では、RGBに関連するすべての専門用語の定義とともに、この最初の理論的な部分で扱ったすべての概念を要約する用語集を提供します。そして次のセクションでは、RGBコントラクトの定義と実装について実践的に見ていきます。

## RGB用語集

<chapterId>545e16a4-3cca-44a3-9fd5-dbc5868abf97</chapterId>

RGBの世界で使われる重要な専門用語（アルファベット順）を集めたこの短い用語集に戻る必要があれば、きっと役に立つでしょう。この章は、最初のセクションで説明したことをすでにすべて理解している場合には、不可欠ではありません。

#### AluVM

AluVMという略語は「_Algorithmic logic unit Virtual Machine_」の略で、スマート・コントラクトの検証と分散コンピューティングのために設計されたレジスタベースの仮想マシンです。これは、RGBコントラクトの検証のために使用されます（ただし、排他的に予約されているわけではありません）。したがって、RGBコントラクトに含まれるスクリプトや操作は、AluVM環境で実行することができます。

詳細はこちら[AluVM公式サイト](https://www.aluvm.org/)

#### アンカー

アンカーは、トランザクションに一意な_commitment_が含まれていることを証明するために使用される、クライアント側のデータのセットを表す。RGBプロトコルでは、アンカーは以下の要素で構成される：


- 立会人取引**のビットコイン取引識別子（TXID）；
- マルチ・プロトコル・コミットメント（MPC）** ；
- 決定論的ビットコインコミットメント（DBC）**；
- Tapret**コミットメントメカニズムが使用されている場合、**Extra Transaction Proof (ETP)** (このモデル専用のセクションを参照)。

したがってアンカーは、特定のビットコイン取引とRGBプロトコルによって検証されたプライベートデータとの間に検証可能なリンクを確立する役割を果たします。これは、これらのデータがブロックチェーンに実際に含まれていることを保証するものであり、その正確な内容が公開されることはありません。

#### 割り当て

RGBのロジックでは、アサインメントは、コントラクトの状態内の特定のプロパティを変更、更新、または作成するトランザクション出力に相当します。アサインメントは2つの要素から構成されます：


- A **シール定義**（特定のUTXOへの参照） ；
- Owned State**（この新しいオーナーに関連する状態を示すデータ）。

したがって、譲渡は、状態の一部（例えば資産）が、UTXOにリンクされたシング ルユースシールによって識別される特定の保有者に割り当てられたことを示す。

#### ビジネス・ロジック

ビジネスロジックは、**スキーマ**（すなわち、契約自体の構造）によって記述される、契約のすべてのルールと内部操作をグループ化したものです。これは、契約の状態がどのように変化するか、また、どのような条件下で変化するかを規定するものである。

#### クライアント側の検証

クライアント側の検証とは、各当事者（クライアント）がプロトコルの規則に従って、個人的に交換されたデータセットを検証するプロセスを指す。RGBの場合、この交換されたデータは**委託**として知られているものにまとめられている。すべてのトランザクションがオンチェーンで公開されることを要求するビットコインプロトコルとは異なり、RGBは（ビットコインで固定された）_コミットメントのみが公開で保存されることを許可し、一方で本質的な契約情報（トランジション、認証、証明）はオフチェーンのままで、関係するユーザー間でのみ共有されます。

#### コミットメント

暗号的な意味での）コミットメントとは、構造化されたデータ `m` （メッセージ）に対する操作と、ランダムな値 `r` から決定論的に導かれる数学的なオブジェクトのことで、`C` と表記する。と書く：

$$
C = \text{commit}(m, r)
$$

このメカニズムは、主に2つのオペレーションから構成されている：


- Commit**: 暗号関数をメッセージ `m` と乱数 `r` に適用して `C` を生成する；
- Verify**: `C`、`m` メッセージ、`r` 値を使って、このコミットメントが正しいかどうかをチェックする。この関数は `True` または `False` を返す。

コミットメントは2つの特性を尊重しなければならない：


- バインディング**：同じ `C` を生成する2つの異なるメッセージを見つけることは不可能に違いない：

$$
m' : \, | \, : m' \neq m \quad \text{and} \quad r' : \, | \, : r' \neq r \quad
$$

など：

$$
\text{verify}(m, r, C) = \text{verify}(m', r', C) \rightarrow \text{True}
$$


- Hiding**：`C`の知識によって`m`の内容が明らかになってはならない。

RGBプロトコルでは、ビットコイン取引にコミットメントが含まれ、情報そのものを明らかにすることなく、ある時点における特定の情報の存在を証明する。

#### 委託

委託**は、当事者間で交換されるデータをグループ化したものであり、RGBにおけるクライアント側の検証の対象となる。委託には主に2つのカテゴリーがあります：


- 契約委託**：発行者*（契約発行者）から提供され、スキーマ、ジェネシス、インターフェイス、インターフェイス実装などの初期化情報が含まれる。
- 譲渡委託**：支払い側(*payer*)から提供される。最終委託に至るまでの状態遷移の全履歴が含まれる(つまり、支払い側が受け取る最終状態)。

これらの委託はブロックチェーン上に公開記録されることはなく、当事者が選択した通信チャネルを通じて当事者間で直接やり取りされる。

#### 契約

コントラクトは、RGBプロトコルを介して複数のアクター間でデジタル的に実行される権利のセットです。契約には有効な状態と、スキーマによって定義されたビジネスロジックがあり、どの操作（譲渡、延長など）が許可されるかを指定します。コントラクトの状態とその有効性ルールは、スキーマで表現される。いつでも、コントラクトは、このスキーマと検証スクリプト（例えばAluVMで実行される）によって許可された内容に従ってのみ進化する。

#### 契約業務

契約オペレーションとは、スキーマ・ルールに従って実行される契約ステータスの更新である。RGBには以下のオペレーションが存在する：


- 状態遷移** ；
- ジェネシス** ；
- 州のエクステンション**。

各操作は、特定のデータ（グローバル状態、所有状態...）を追加または置き換えることによって状態を変更する。

#### 契約参加者

契約参加者とは、契約に関する業務に参加する行為者のことである。RGBでは、：


- ジェネシスを生み出す契約の発行者（契約の起源）；
- 契約当事者、すなわち契約の状態に対する権利の保有者；
- 公共機関は、一般市民がアクセス可能なバレンシアを提供する契約を結べば、州内拡張工事を行うことができる。

#### 契約権

契約上の権利とは、RGB契約に関与する者が行使できる様々な権利を指す。いくつかのカテゴリーに分類される：


- 所有権**、特定のUTXOの所有権に関連する（_Seal Definition_を介して）；
- すなわち、スキーマに従って1つ以上のトランジション（状態遷移）を構築する能力である；
- パブリック・ライツ**：スキーマが特定のパブリックな使用を許可している場合。例えば、ヴァレンシーの償還によるステート・エクステンションの創設など。

#### 契約国

コントラクトステートは、ある時点におけるコントラクトの現在の状態に対応する。パブリックデータとプライベートデータの両方で構成され、コントラクトの状態を反映します。RGBは.NETと.NETを区別する：


- グローバルステート**は、コントラクトのパブリックプロパティ（ジェネシスで設定されたもの、または認可されたアップデートによって追加されたもの）を含む；
- 所有国**は、UTXOによって特定される特定の所有者に属する。

#### 決定論的ビットコインコミットメント - DBC

決定論的ビットコインコミットメント（DBC）とは、ビットコイン取引におけるコミットメントを証明可能かつ一意に登録するために使用されるルールのセットです。RGBプロトコルでは、DBCには主に2つの形式があります：


- オプレト**（オプレト
- タプレット

これらのメカニズムは、コミットメントが決定論的に追跡可能で検証可能であることを保証するために、ビットコイントランザクションの出力または構造において_コミットメント_がどのようにエンコードされるかを正確に定義します。

#### 有向非循環グラフ - DAG

DAG（または*Acyclic Guided Graph*）はサイクルのないグラフであり、トポロジカルなスケジューリングを可能にする。ブロックチェーンは、RGBコントラクトのシャードのように、DAGで表現することができる。

詳細はこちら：[有向非循環グラフ](https://en.wikipedia.org/wiki/Directed_acyclic_graph)

#### 彫刻

エングレーヴィングは、契約の連続所有者が契約履歴に入力できるオプションのデータ文字列である。この機能は、例えば**RGB21**インターフェイスに存在し、契約履歴に記念情報や説明情報を追加することができます。

#### エクストラ・トランザクション・プルーフ（ETP

ETP（*Extra Transaction Proof*）は、**Tapret** *コミットメント*（_taproot_のコンテキスト）を検証するために必要な追加データを含むアンカーの一部です。これには、特に、タップルート・スクリプトの内部公開鍵（_internal PubKey_）と、_Script Path Spend_に固有の情報が含まれる。

#### ジェネシス

ジェネシスとは、RGBのあらゆるコントラクトの初期状態を形成する、スキーマによって管理されるデータのセットを指します。これはビットコインの_Genesis Block_コンセプトやCoinbaseのトランザクションコンセプトと比較することができますが、ここでは_クライアントサイド_とRGBトークンのレベルです。

#### グローバル国家

グローバル・ステートは、コントラクト・ステートに含まれるパブリック・プロパティのセットである。これはジェネシスで定義され、コントラクトのルールによっては、許可されたトランジションによって更新することができる。Owned Stateとは異なり、Global Stateは特定のエンティティに属するものではなく、コントラクト内のパブリックレジストリに近い。

#### インターフェース

インターフェイスは、スキーマやコントラクト・オペレーションでコンパイルされたバイナリ・データとそのステートを、ユーザーやそのウォレットが読めるようにデコードするために使用される命令のセットである。解釈レイヤーとして機能します。

#### インターフェイスの実装

インターフェイス実装は、**インターフェイス**を**スキーマ**にリンクする宣言のセットです。インターフェイスの実装は、インターフェイス自身によって行われるセマンティック変換を可能にし、コントラクトの生データをユーザーや関係するソフトウェア（ウォレット）が理解できるようにします。

#### 請求書

インボイスは[base58](https://en.wikipedia.org/wiki/Binary-to-text_encoding#Base58)でエンコードされたURLの形をとる。このURLには、(支払者が)**状態遷移**を構築するために必要なデータが埋め込まれる。言い換えれば、取引相手(*payer*)が資産を移転したり、契約の状態を更新したりするために、対応するトランジションを作成できるようにする請求書である。

#### ライトニング・ネットワーク

ライトニングネットワークは、2/2マルチシグネチャウォレットで構成されるビットコイン上の決済チャネル（または_ステートチャネル_）の分散型ネットワークです。高速で低コストのオフチェーン取引を可能にする一方で、必要な場合にはビットコインのレイヤー1に仲裁（または閉鎖）を依存する。

ライトニングがどのように機能するかについては、この他のコースを受講されることをお勧めする：

https://planb.network/courses/lnp201
#### マルチ・プロトコル・コミットメント - MPC

マルチプロトコルコミットメント（MPC）とは、1つのビットコイン取引に異なる契約からの複数の**トランジションバンドル**を含めるためにRGBで使用されるメルクルツリー構造を指します。このアイデアは、ブロックスペースの占有を最適化するために、複数のコミットメント（異なる契約または異なるアセットに対応する可能性がある）を単一のアンカーポイントにまとめることである。

#### 所有国

所有状態（Owned State）とは、譲渡（Assignment）に包含され、（UTXOを指すシングルユースシールを介して）特定の保有者に関連付けられる契約状態の一部である。これは例えば、デジタル資産やその人に割り当てられた特定の契約上の権利を表す。

#### 所有権

所有（Ownership）とは、シール定義（Seal Definition）によって参照されるUTXOを管理し、使用する能力のことである。所有国家がUTXOにリンクされている場合、このUTXOの所有者は、契約の規則に従って、関連する国家を譲渡または進化させる権利を潜在的に有する。

#### 部分的に署名されたビットコイン取引 - PSBT

PSBT（_Partially Signed Bitcoin Transaction_）は、まだ完全に署名されていないビットコイン取引である。このトランザクションは複数のエンティティ間で共有することができ、各エンティティはトランザクションがオンチェーン配布の準備が整ったと判断されるまで、特定の要素（署名、スクリプト...）を追加または検証することができます。

詳細はこちら：[BIP-0174](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)

#### ペデルセンのコミットメント

Pedersenコミットメントとは、暗号コミットメントの一種で、加算演算に関して**同型**であるという特性を持つ。つまり、個々の値を明らかにすることなく、2つのコミットメントの和を検証することが可能である。

形式的には、もし：

$$
C1=\text{commit}(m1,r1) \quad C2=\text{commit}(m2,r2)
$$

その時

$$
C3=C1⋅C2=\text{commit}(m1+m2, r1+r2)
$$

この特性は、例えば、交換されたトークンの量を隠しつつ、合計を検証するのに便利である。

さらに詳しい情報[Pedersen commitment](https://link.springer.com/chapter/10.1007/3-540-46766-1_9)

#### 償還

ステートエクステンションにおいてRedeemとは、以前に宣言された**Valency**を取り戻す（または利用する）行為を指す。ヴァレンシーは公的な権利であるため、Redeemによって、権限を与えられた参加者は特定の契約状態の延長を主張することができる。

#### スキーマ

RGBにおけるスキーマとは、契約の運用を管理する変数、ルール、ビジネスロジック（*ビジネスロジック*）のセットを記述する宣言的なコードの一部です。スキーマは、状態構造、許可される遷移のタイプ、および検証条件を定義します。

#### シールの定義

シールの定義（Seal Definition）とは、譲渡（Assignment）の一部で、コミットメント（_commitment）と新所有者が所有するUTXOとを関連付けるものです。言い換えれば、その条件がどこにあるのか（どのUTXOにあるのか）を示し、資産または権利の所有権を確立します。

#### シャード

シャードは、RGB 契約の状態遷移履歴の DAG における分岐を表す。言い換えると、契約全体の履歴の首尾一貫したサブセットであり、たとえば、_Genesis_以降、与えられたアセットの有効性を証明するために必要な遷移のシーケンスに対応する。

#### シングルユース・シール

Single-useシールとは、まだ未知のメッセージに対する暗号的な約束のことで、 将来一度だけ公開され、特定の利用者全員が知っていなければならない。その目的は、同じシールに対して複数の競合するコミットメントが作成されるのを防ぐことである。

#### 隠し場所

Stashは、1つまたは複数のRGBコントラクトについて、ユーザーが検証（*クライアントサイド検証*）のために保存するクライアントサイドデータのセットです。これには、移行履歴、委託、有効性の証明などが含まれます。各保有者は、必要な履歴の部分のみを保持します（*シャード*）。

#### ステート・エクステンション

状態拡張は、以前に宣言された**バレンシー**を償還することによって、状態の更新を再トリガーするために使用されるコントラクト操作である。ステート延長を有効にするには、ステート遷移（コントラクトの最終ステートを更新する）によってステート延長を閉じなければならない。

#### 状態遷移

状態遷移は、RGBコントラクトの状態を新しい状態に変更する操作である。これは、グローバルステートおよび/または所有ステートデータを変更することができます。実際には、各トランジションはスキーマルールによって検証され、_commitment_によってビットコインのブロックチェーンに固定されます。

#### タップルート

BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)および[BIP342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki)によって導入されたビットコインのSegwit v1トランザクションフォーマットを指す。Taprootはスクリプトの機密性と柔軟性を向上させ、特にトランザクションをよりコンパクトにし、互いに区別しにくくする。

#### ターミナル委託 - 委託終点

Terminal Consignment（または _Consignment Endpoint_）は、受取人（*payee*）のInvoiceから作成されたState Transitionを含む、契約の最終状態を含む*Transfer Consignment*である。したがって、所有権や状態が移転されたことを証明するために必要なデータを含む、移転のエンドポイントである。

#### トランジション・バンドル

トランジション・バンドルとは、同じ***ウィットネス・トランザクション*** Bitcoinに従事する（同じコントラクトに属する）RGBステート・トランジションのセットである。これにより、複数の更新または転送を単一のオンチェーンアンカーにバンドルすることが可能になります。

#### UTXO

ビットコインのUTXO（*Unspent Transaction Output*）は、トランザクションのハッシュと出力インデックス（*vout*）によって定義されます。また、_outpoint_と呼ばれることもある。RGBプロトコルでは、(**Seal Definition**を介して)UTXOを参照することで、**Owned State**の場所、つまりブロックチェーン上に保持されている財産を知ることができます。

#### バレンシー

ヴァレンシーは公的な権利であり、国家の保管を必要としないが、**国家延長**によって償還することができる。したがって、後日特定の延長を実行するために、契約のロジックで宣言された、すべての（または特定の）プレーヤーに開かれた可能性の一形態である。

#### 立会人取引

Witness Transaction は、Multi Protocol Commitment (MPC) を含むメッセージの周りの Single-use Seal を閉じるビットコイントランザクションである。このトランザクションは、RGB プロトコルにリンクされたコミットメントを封印するために、UTXO を消費するか、UTXO を作成します。このトランザクションは、特定の時点で状態が設定されたことをオンチェーンで証明する役割を果たす。

# RGBプログラミング

<partId>148a7436-d079-56d9-be08-aaa4c14c6b3a</partId>

## RGBコントラクトの実装

<chapterId>8333ea5f-51c7-5dd5-b1d7-47d491e58e51</chapterId>

![video](https://youtu.be/Uo1UoxiImsI)

この章では、RGBコントラクトがどのように定義され、実装されるかを詳しく見ていきます。RGBコントラクトの構成要素は何か、それらの役割は何か、どのように構成されるかを見ていきます。

### RGB契約の構成要素

これまでのところ、コントラクトの開始点を表す**ジェネシス**についてすでに説明し、それが**コントラクト・オペレーション**のロジックやプロトコルの状態とどのように適合するかを見てきた。しかし、RGBコントラクトの完全な定義は、ジェネシスだけに限定されるものではない。

最初のコンポーネントは**スキーマ**と呼ばれる。これは契約の基本的な構造とビジネスロジック（*ビジネスロジック*）を記述したファイルである。これは、使用されるデータ型、検証ルール、許可される操作（最初のトークン発行、転送、特別条件など）、要するに、コントラクトがどのように機能するかを規定する一般的なフレームワークを指定します。

2つ目の構成要素は、**インターフェース**です。これは、ユーザー（ひいてはポートフォリオ・ソフトウェア）がこのコントラクトとどのように相互作用するかに焦点を当てたものである。これはセマンティクス、つまり様々なフィールドとアクションの読みやすい表現を記述します。つまり、スキーマはコントラクトが技術的にどのように機能するかを定義しますが、インターフェイスは、メソッド名、データ表示など、これらの機能をどのように提示し、公開するかを定義します。

第3のコンポーネントは**インターフェイス実装**で、スキーマとインターフェイスの橋渡しのような役割を果たし、前の2つを補完する。言い換えれば、インターフェイスによって表現されたセマンティクスを、スキーマで定義された基本的なルールと関連付ける。例えば、ウォレットに入力されたパラメータとプロトコルが課すバイナリ構造との変換や、機械語による検証ルールのコンパイルなどを管理するのは、この実装である。

このモジュール性はRGBの興味深い特徴であり、プロトコルのコンセンサスルールに従う限り、異なる開発者グループがこれらの側面（*スキーマ*、*インターフェース*、*実装*）を別々に作業することを可能にする。

要約すると、各契約は以下の内容で構成されている：


- Genesis**は、契約の初期状態である（資産、権利、またはその他のパラメータ化可能なデータの最初の所有権を定義する特別なトランザクションに例えることができる）；
- 契約書のビジネスロジック（データ型、検証ルールなど）を記述するスキーマ**；
- インターフェイス**は、ウォレットと人間のユーザーの両方にセマンティック・レイヤーを提供し、取引の読み取りと実行を明確にする；
- インプリメンテーション**インターフェイスは、ビジネスロジックとプレゼンテーションのギャップを埋めるもので、契約定義とユーザーエクスペリエンスの一貫性を保証する。

![RGB-Bitcoin](assets/fr/070.webp)

ウォレットがRGBアセット（それがカンジブルトークンであれ、あらゆる種類の権利であれ）を管理するためには、これらの要素がすべてコンパイルされていなければならないことに注意することが重要です： *スキーマ*、*インターフェース*、*インターフェースの実装*、そして*ジェネシス*です。これは、***契約委託***、すなわちクライアント側の契約を検証するために必要なすべてを含むデータパッケージを通じて送信されます。

これらの概念を明確にするために、オブジェクト指向プログラミング（OOP）またはイーサリアムのエコシステムで既に知られている概念とRGBコントラクトの構成要素を比較した要約表を示します：

| RGBコントラクト・コンポーネント｜意味｜OOP等価｜イーサリアム等価｜Ethereum等価

| ---------------------------- | --------------------------------------- | -------------------------------------------------- | ---------------------------------- |

| クラス・コンストラクタ｜契約コンストラクタ｜契約の初期状態

| クラス｜契約ビジネスロジック

| コントラクト・セマンティクス｜インターフェイス（Java）｜トレイト（Rust）｜プロトコル（Swift）｜ERCスタンダード｜ERC Standard

| アプリケーション・バイナリ・インターフェース（ABI）｜インプリメント（Rust）／インプリメント（Java）｜セマンティクスとロジックのマッピング

左側の列はRGBプロトコルに特有の要素を示している。真ん中の列は、各コンポーネントの具体的な機能を示している。そして、「OOP equivalent」の欄には、オブジェクト指向プログラミングにおける等価な用語を示している：


- ジェネシス**は、*クラス・コンストラクタ*のような役割を果たす；
- スキーマ**はクラスの記述であり、プロパティ、メソッド、基本ロジックの定義である；
- インターフェイス**は、*インターフェイス*（Java）、*トレイト*（Rust）、または*プロトコル*（Swift）に対応する；
- インターフェイスの実装**は、Rustの*Impl*やJavaの*Implements*に相当し、インターフェイスでアナウンスされたメソッドをコードが実際にどのように実行するかを指定する。

Ethereumの文脈では、Genesisは*契約コンストラクタ*に近く、Schemaは契約定義に、InterfaceはERC-20やERC-721のような標準に、そしてInterface ImplementationはABI（*Application Binary Interface*）に近い。

RGBのモジュール性の利点は、*スキーマ*のロジックと*インターフェイス*のセマンティクスを尊重する限り、異なるステークホルダーが例えば独自のインターフェイス実装を書くことができるという事実にもある。したがって、発行者は、契約のロジックに変更を加えることなく、より使いやすいフロントエンド（インターフェイス）を新たに開発することができる。また逆に、スキーマを拡張して機能を追加し、適合したインターフェイス実装の新バージョンを提供することもできる。

新しいコントラクトをコンパイルすると、Genesis（アセットを発行または配布するための最初のステップ）とそのコンポーネント（スキーマ、インターフェイス、インターフェイス実装）が生成されます。この後、コントラクトは完全に運用可能となり、ウォレットやユーザーに伝搬することができます。ジェネシスがこれら3つのコンポーネントと組み合わされるこの方法は、高度なカスタマイズ性（各コントラクトは独自のロジックを持つことができる）、非中央集権性（誰もが与えられたコンポーネントに貢献することができる）、セキュリティ（他のブロックチェーンでしばしば見られるような任意のオンチェーンコードに依存することなく、検証はプロトコルによって厳密に定義されたままである）を保証する。

スキーマ**、インターフェイス**、そしてインターフェイスの実装**である。

### スキーマ

前のセクションでは、RGBエコシステムにおいて、コントラクトはいくつかの要素から構成されることを見た。スキーマの目的は、コントラクトのすべてのビジネスロジック、つまりデータ構造、使用される型、許可される操作とその条件を宣言的に記述することです。したがって、クライアント側でコントラクトを運用する上で、スキーマは非常に重要な要素です。なぜなら、各参加者（たとえばウォレット）は、受け取った状態遷移がスキーマで定義されたロジックに適合しているかどうかをチェックしなければならないからです。

スキーマは、オブジェクト指向プログラミング（OOP）における「クラス」に例えることができる。一般的には、.NET Frameworkのようなコントラクトのコンポーネントを定義するモデルとして機能します：


- 所有ステートとアサインメントの種類 ；
- バレンシー、つまり特定の操作に対して発動（*償還*）できる特別な権利；
- グローバル・ステート・フィールドは、コントラクトのグローバル、パブリック、共有のプロパティを記述します；
- ジェネシスの構造（契約を有効にする一番最初の操作）；
- ステート・トランジションとステート・エクステンションの許容される形と、これらの操作がどのように；
- 各オペレーションに関連するメタデータで、一時的な情報や追加情報を保存する；
- 内部契約データがどのように進化するかを決定するルール（例えば、フィールドが変更可能か累積可能か）；
- 例えば、遵守すべき遷移の順序や、満たすべき論理条件のセットなどである。

![RGB-Bitcoin](assets/fr/071.webp)

RGB上のアセットの*発行者*がコントラクトを発行する際、それに関連するジェネシスとスキーマを提供します。アセットとやり取りしたいユーザーやウォレットは、コントラクトの背後にあるロジックを理解し、参加するトランジションが正当なものであることを後で検証できるように、このスキーマを取得します。

RGBアセットに関する情報（トークン譲渡など）を受け取る人にとっての最初のステップは、この情報をスキーマに照らして検証することです。これには、スキーマのコンパイルを：


- Ownedステート、アサインメント、その他の要素が正しく定義されているか、また、それらが課された型（いわゆる*厳格な型システム*）を尊重しているかをチェックする；
- トランジション・ルール（検証スクリプト）が満たされていることをチェックする。これらのスクリプトは、クライアント側に存在するAluVMを介して実行することができ、ビジネスロジック（転送量、特殊条件など）の整合性を検証する役割を担っている。

実際には、オンチェーンコードを保存するブロックチェーン（イーサリアムのEVM）で見られるように、スキーマは実行可能コードではない。それどころか、RGBはビジネスロジック（宣言的）とブロックチェーン上の実行可能コード（暗号アンカーに限定される）を分離している。したがって、スキーマはルールを決定するが、これらのルールの適用は、クライアント側検証原則に従って、ブロックチェーンの外側、各参加者のサイトで行われる。

スキーマはRGBアプリケーションで使用する前にコンパイルする必要があります。このコンパイルはバイナリファイル(例: `.rgb`)または暗号化されたバイナリファイル(`.rgba`)を生成します。ウォレットがこのファイルをインポートすると、：


- 厳密な型システムのおかげで、各データ型（整数、構造体、配列...）がどのように見えるか；
- ジェネシスはどのように構成されるべきか（資産の初期化を理解するため）；
- さまざまな種類の操作（状態遷移、状態拡張）と、それらがどのように状態を変更するか；
- AluVMエンジンが操作の妥当性をチェックするために適用するスクリプト・ルール（スキーマで紹介）。

前の章で説明したように、*厳密型システム*は、安定した決定論的な符号化形式を与えてくれる。所有ステート、グローバル・ステート、バレンシーを問わず、すべての変数は正確に記述される（サイズ、必要に応じて下限値と上限値、符号あり型か符号なし型かなど）。また、例えば複雑なユースケースをサポートするために、入れ子構造を定義することも可能です。

オプションとして、スキーマはルート `SchemaId` を参照することができ、既存の基本構造（テンプレート）の再利用を容易にする。これにより、既存の基本構造（テンプレート）の再利用が容易になります。このようにして、コントラクトを進化させたり、すでに実績のあるテンプレートからバリエーション（新しいタイプのトークンなど）を作成したりすることができます。このモジュール性により、コントラクト全体を作り直す必要がなくなり、ベストプラクティスの標準化が促進される。

もう一つの重要な点は、状態進化（転送、更新など）のロジックが、スクリプト、ルール、条件の形でスキーマに記述されていることである。そのため、コントラクト設計者が再発行を承認したり、バーン・メカニズム（トークンの破棄）を課したりしたい場合、スキーマのバリデーション部分でAluVMに対応するスクリプトを指定することができる。

#### プログラム可能なオンチェーンブロックチェーンとの違い

スマート・コントラクトのコード（実行可能ファイル）がブロックチェーン自体に書き込まれるイーサリアムのようなシステムとは異なり、RGBはコントラクト（そのロジック）をオフチェーンに、コンパイルされた宣言的文書の形で保存する。これは、：


- ビットコインネットワークの各ノードでチューリング完全なVMが実行されることはない。RGB契約のルールはブロックチェーン上で実行されるのではなく、状態を検証したい各ユーザーの中で実行される；
- 契約データはブロックチェーンを汚染しない：暗号化された証拠（*コミットメント*）のみが（`Tapret`または`Opret`を介して）ビットコインのトランザクションに埋め込まれる；
- スキーマは、ビットコインのブロックチェーン上でフォークを必要とすることなく、更新または拒否（*fast-forward*、*push-back*など）することができます。ウォレットは新しいスキーマをインポートし、コンセンサスの変更に適応するだけでよい。

#### 発行者と利用者による利用

発行者*が資産（例えば、インフレのないカンジタブルトークン）を作成する場合、その資産は：


- 放出、移籍などのルールを記述したスキーマ；
- このスキーマに適合したジェネシス（発行されたトークンの総数、最初の所有者の身元、再発行のための特別なバレンシーなど）。

そして、コンパイルされたスキーマ（`.rgb`ファイル）をユーザーが利用できるようにし、このトークンの転送を受けた誰もが、操作の一貫性をローカルでチェックできるようにする。このスキーマがなければ、ユーザーはステータスデータを解釈することも、それが契約ルールに準拠しているかどうかをチェックすることもできない。

そのため、新しいウォレットがアセットをサポートしたい場合、単に関連するスキーマを統合する必要があります。この仕組みにより、ウォレットのソフトウェアベースを変更することなく、新しいRGBアセットタイプとの互換性を追加することが可能になります。必要なのは、スキーマのバイナリをインポートし、その構造を理解することだけです。

スキーマはRGBのビジネスロジックを定義します。コントラクトの進化ルール、データ構造（所有ステート、グローバルステート、バレンシー）、関連する検証スクリプト（AluVMで実行可能）をリストアップします。この宣言的なドキュメントのおかげで、コントラクトの定義（コンパイルされたファイル）は、実際のルールの実行（クライアントサイド）から明確に分離されています。この分離によりRGBは大きな柔軟性を持ち、プログラム可能なオンチェーンブロックチェーンにありがちな複雑さや欠陥を回避しながら、幅広いユースケース（カジブルトークン、NFT、より洗練されたコントラクト）を可能にします。

#### スキーマの例

RGB契約のスキーマの具体例を見てみよう。これはファイル`nia.rs`（「*Non-Inflatable Assets*」の頭文字）からRustで抜粋したもので、最初の供給量を超えて再発行することができない可換トークン（非インフレ資産）のモデルを定義しています。このタイプのトークンは、RGBの世界ではイーサリアムのERC20に相当すると見なすことができる。

コードに入る前に、RGBスキーマの一般的な構造を思い出しておこう。.NETをフレーミングする一連の宣言がある：


- 別の基本スキーマをテンプレートとして使用することを示す `SchemaId` の可能性；
- グローバル国家**と**所有国家**（厳密なタイプを持つ）；
- バレンシー**（もしあれば）；
- これらの状態と価数を参照できる**操作**（ジェネシス、状態遷移、状態拡張）；
- データの記述と検証に使用される**厳密型システム**；
- 検証スクリプト**（AluVM経由で実行）。

![RGB-Bitcoin](assets/fr/072.webp)

以下のコードは、Rust Schemaの完全な定義を示しています。以下の注釈(1)から(9)に従って、部分ごとにコメントします：

```rust
// ===== PART 1: Function Header and SubSchema =====
fn nia_schema() -> SubSchema {
// definitions of libraries and variables
// ===== PART 2: General Properties (ffv, subset_of, type_system) =====
Schema {
ffv: zero!(),
subset_of: None,
type_system: types.type_system(),
// ===== PART 3: Global States =====
global_types: tiny_bmap! {
GS_NOMINAL => GlobalStateSchema::once(types.get("RGBContract.DivisibleAssetSpec")),
GS_DATA => GlobalStateSchema::once(types.get("RGBContract.ContractData")),
GS_TIMESTAMP => GlobalStateSchema::once(types.get("RGBContract.Timestamp")),
GS_ISSUED_SUPPLY => GlobalStateSchema::once(types.get("RGBContract.Amount")),
},
// ===== PART 4: Owned Types =====
owned_types: tiny_bmap! {
OS_ASSET => StateSchema::Fungible(FungibleType::Unsigned64Bit),
},
// ===== PART 5: Valencies =====
valency_types: none!(),
// ===== PART 6: Genesis: Initial Operations =====
genesis: GenesisSchema {
metadata: Ty::<SemId>::UNIT.id(None),
globals: tiny_bmap! {
GS_NOMINAL => Occurrences::Once,
GS_DATA => Occurrences::Once,
GS_TIMESTAMP => Occurrences::Once,
GS_ISSUED_SUPPLY => Occurrences::Once,
},
assignments: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
valencies: none!(),
},
// ===== PART 7: Extensions =====
extensions: none!(),
// ===== PART 8: Transitions: TS_TRANSFER =====
transitions: tiny_bmap! {
TS_TRANSFER => TransitionSchema {
metadata: Ty::<SemId>::UNIT.id(None),
globals: none!(),
inputs: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
assignments: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
valencies: none!(),
}
},
// ===== PART 9: Script AluVM and Entry Points =====
script: Script::AluVM(AluScript {
libs: confined_bmap! { alu_id => alu_lib },
entry_points: confined_bmap! {
EntryPoint::ValidateGenesis => LibSite::with(FN_GENESIS_OFFSET, alu_id),
EntryPoint::ValidateTransition(TS_TRANSFER) => LibSite::with(FN_TRANSFER_OFFSET, alu_id),
},
}),
}
}
```


- (1) - 関数のヘッダとサブスキーマ**。

nia_schema()`関数は`SubSchema`を返し、このスキーマがより汎用的なスキーマを部分的に継承できることを示す。RGBのエコシステムでは、この柔軟性により、マスタースキーマの特定の標準要素を再利用し、その後、問題の契約に固有のルールを定義することが可能になります。ここでは、`subset_of` が `None` になるため、継承を有効にしないことにする。


- (2) - 一般的なプロパティ：ffv、subset_of、type_system**。

ffv`プロパティはコントラクトの*fast-forward*バージョンに対応する。ここで`zero!()`という値は、バージョン0またはこのスキーマの初期バージョンであることを示す。後に新しい機能（新しい操作タイプなど）を追加したい場合は、このバージョンをインクリメントしてコンセンサスの変更を示すことができます。

subset_of：None` プロパティは継承がないことを示す。type_system` フィールドは `types` ライブラリで定義されている厳格な型システムを参照する。この行は、コントラクトが使用するすべてのデータが、当該ライブラリが提供する厳密なシリアライズの実装を使用することを示す。


- (3) - 世界の国々

global_types`ブロックでは、4つの要素を宣言している。GS_NOMINAL`や`GS_ISSUED_SUPPLY`のようなキーは後で参照するために使います：


- GS_NOMINAL`は`DivisibleAssetSpec`型を指し、作成されたトークンの様々なフィールド（フルネーム、ティッカー、精度...）を記述する；
- GS_DATA`は、免責事項、メタデータ、その他のテキストなどの一般的なデータを表す；
- GS_TIMESTAMP`は発行日を指す；
- GS_ISSUED_SUPPLY` は総供給量、つまり作成可能なトークンの最大数を設定する。

キーワード`once(...)`は、これらのフィールドがそれぞれ一度しか出現しないことを意味する。


- (4) - 所有タイプ

owned_types`では、`OS_ASSET`を宣言している。StateSchema::Fungible(FungibleType::Unsigned64Bit)`を使用し、資産（トークン）の数量が64ビットの符号なし整数として格納されることを示す。したがって、どのようなトランザクションもこのトークンの一定量のユニットを送ることになり、この厳密に型付けされた数値構造に従って検証される。


- (5) - バレンシア**選手

これは、このスキーマにバレンシーが存在しないこと、言い換えれば、特別な、あるいは余分な権利（再発行、条件付きバーンなど）が存在しないことを意味する。もしスキーマにバレンシーがあれば、このセクションで宣言される。


- (6) - 創世記：最初の作戦

ここで、契約オペレーションを宣言する部分に入る。ジェネシスは：


- メタデータ`（フィールド `metadata：Ty::<SemId>::UNIT.id(None)`) ；
- それぞれ一度ずつ（`Once`）存在しなければならないグローバルステート；
- OS_ASSET` が `OnceOrMore` と表示されなければならない割り当てリスト。つまり、Genesisは少なくとも1つの`OS_ASSET`の割り当て（最初のホルダー）を必要とします；
- バレンシーなし : `valencies: none!()`.

発行されたトークン（`GS_ISSUED_SUPPLY`）と、少なくとも1つの保有者（`OS_ASSET`型のOwned State）を宣言する必要があります。


- (7) - エクステンション

extensions: none!()` フィールドは、このコントラクトで状態拡張が予期されていないことを示す。つまり、デジタル権利（Valency）を償還する操作や、トランジションの前に状態拡張を実行する操作は存在しない。すべてはジェネシスまたはステート・トランジションによって行われる。


- (8) - トランジション：TS_TRANSFER

トランジション`では `TS_TRANSFER` タイプの操作を定義している。我々は：


- メタデータはない；
- グローバル・ステートを変更することはない（これはすでにジェネシスで定義されている）；
- これは1つ以上の `OS_ASSET` を入力として受け取る。つまり、既存の Owned State を使わなければならない；
- それは少なくとも1つの新しい `OS_ASSET` を作成（`割り当て`）します（言い換えれば、受信者または受信者はトークンを受け取ります）；
- 新たなヴァレンシーは生まれない。

これは、UTXO上でトークンを消費し、その後、受信者に有利な新しい所有状態を作成し、したがって、入力と出力の間の総量の平等を維持する基本的な転送の動作をモデル化します。


- (9) - AluVMスクリプトとエントリーポイント** (フランス語)

最後に、AluVMスクリプト（`Script::AluVM(AluScript { ... })`）を宣言する。このスクリプトには：


- 検証時に使用する外部ライブラリ (`libs`) を1つ以上指定する；
- Genesisの検証（`ValidateGenesis`）と、宣言された各Transitionの検証（`ValidateTransition(TS_TRANSFER)`）に対応する、AluVMコード内の関数オフセットを指すエントリポイント。

このバリデーションコードは、ビジネスロジックの適用を担当します。例えば、：


- GS_ISSUED_SUPPLY`がジェネシスの間に超過しないこと；
- TS_TRANSFER`では、`inputs` (消費したトークン) の合計が `assignments` (受け取ったトークン) の合計と等しい。

これらのルールが尊重されない場合、移籍は無効とみなされる。

この "*Non Inflatable Fungible Asset*"スキーマの例から、シンプルなRGBファンジブル・トークン・コントラクトの構造をよりよく理解することができます。データ記述（GlobalとOwned States）、オペレーション宣言（Genesis、Transitions、Extensions）、バリデーション実装（AluVMスクリプト）が明確に分離されていることがわかります。このモデルのおかげで、トークンは古典的なカンジブルトークンのように振る舞いますが、クライアント側で検証されたままであり、コードを実行するためにオンチェーンインフラストラクチャに依存しません。暗号化されたコミットメントのみがビットコインのブロックチェーンに固定されます。

### インターフェース

インターフェイスは、利用者（人間が読む）およびポートフォリオ（ソフトウェアが読む）の両方が、コントラクトを読みやすく、操作しやすくするために設計された層である。したがって、インターフェイスは、オブジェクト指向プログラミング言語（Java、Rust traitなど）におけるインターフェイスに匹敵する役割を果たします。インターフェイスは、必ずしもビジネスロジックの内部詳細を明らかにすることなく、コントラクトの機能的構造を公開し、明確にするという点です。

純粋に宣言的で、そのままでは使いにくいバイナリ・ファイルにコンパイルされるSchemaとは異なり、Interfaceは.NET Frameworkに必要な読み取りキーを提供する：


- 契約に含まれるグローバルステイトとオウンステイトをリストアップし、説明すること；
- 各フィールドの名前と値にアクセスし、それらを表示できるようにする（例えば、トークンの場合、そのティッカー、最大金額などを調べる）；
- データを理解しやすい名前に関連付けることで、コントラクト・オペレーション（ジェネシス、ステート・トランジション、ステート・エクステンション）を解釈し、構築する（例えば、バイナリ識別子ではなく「金額」を明確に指定して譲渡を実行する）。

![RGB-Bitcoin](assets/fr/073.webp)

インターフェイスのおかげで、例えば、フィールドを操作する代わりに、「トークン数」や「アセット名」などのラベルを直接操作するコードをウォレットに書くことができます。こうすることで、コントラクトの管理がより直感的になります。こうすることで、コントラクトの管理がより直感的になる。

#### 一般的な操作

この方法には多くの利点がある：


- 標準化

同じ種類のコントラクトは、複数のウォレット実装間で共有される標準インターフェイスでサポートすることができます。これにより、互換性とコードの再利用が容易になります。


- スキーマとインターフェイスの明確な分離:**。

RGBデザインでは、スキーマ（ビジネスロジック）とインターフェース（プレゼンテーションと操作）は2つの独立したエンティティである。コントラクトロジックを書く開発者は、人間工学やデータ表現を気にすることなくスキーマに集中することができ、その間に別のチーム（または同じチームだがタイムラインは異なる）がインターフェイスを開発することができる。


- 柔軟な進化:**

インターフェイスは、アセットが発行された後でも、コントラクト自体を変更することなく、変更や追加が可能です。これは、インターフェイス（多くの場合、実行コードと混在している）がブロックチェーンに凍結される一部のオンチェーン・スマートコントラクトシステムとの大きな違いである。


- マルチインターフェース機能

エンドユーザー向けのシンプルなインターフェイス、複雑な設定操作を管理する必要がある発行者向けの高度なインターフェイスなどです。ウォレットはその用途に応じて、どのInterfaceをインポートするかを選択できる。

![RGB-Bitcoin](assets/fr/074.webp)

実際には、ウォレットがRGBコントラクトを取得するとき（`.rgb`または `.rgba`ファイルを介して）、関連するインターフェイスもインポートします。実行時に、ウォレットは例えば：


- 国家リストをブラウズし、その名前を読み取ることで、読めない数字の識別子ではなく、ティッカー、初回金額、発行日などをユーザー・インターフェースに表示する；
- 明示的なパラメータ名を使って（移籍などの）オペレーションを構築する：`assignments { OS_ASSET => 1 }`と書く代わりに、フォームの「金額」フィールドをユーザーに提供し、この情報をコントラクトが期待する厳密な型付けのフィールドに変換することができる。

#### イーサリアムや他のシステムとの違い

イーサリアムでは、インターフェイス（ABI、*アプリケーション・バイナリ・インターフェイス*を介して記述される）は、一般的にオンチェーンストアドコード（スマートコントラクト）から派生します。コントラクト自体に触れることなくインターフェースの特定の部分を変更するには、コストがかかったり複雑になったりします。しかし、RGBは完全にオフチェーンのロジックに基づいており、データはビットコイン上の*コミットメント*に固定されている。この設計により、ビジネスルールの検証がスキーマと参照されるAluVMコードに残るため、コントラクトの基本的なセキュリティに影響を与えることなく、インターフェイス（またはその実装）を変更することが可能になります。

#### インターフェイスのコンパイル

スキーマと同様に、インターフェイスはソースコード（多くの場合Rust）で定義され、`.rgb`または`.rgba`ファイルにコンパイルされます。このバイナリファイルには、ウォレットが.NET Frameworkを使うために必要なすべての情報が含まれています：


- 名前でフィールドを特定する ；
- 各フィールド（およびその値）を、契約で定義された厳密なシステム型にリンクする；
- 許可されているさまざまなオペレーションとその構築方法を知る。

インターフェイスがインポートされると、ウォレットはコントラクトを正しく表示し、ユーザーにインタラクションを提案することができます。

### LNP/BP協会によって標準化されたインターフェイス

RGBエコシステムでは、インターフェイスはコントラクトのデータとオペレーションに読みやすく操作しやすい意味を与えるために使用される。インターフェイスはこのように、ビジネスロジックを内部的に記述するスキーマを補完します（厳密な型、検証スクリプトなど）。このセクションでは、LNP/BPアソシエーションが開発した、一般的なコントラクトタイプ（カンジブルトークン、NFTなど）の標準インターフェイスを紹介する。

覚えておいてほしいのは、各インターフェイスはウォレット側でコントラクトを表示・操作する方法を記述し、フィールド（`spec`、`ticker`、`issuedSupply`...など）を明確に命名し、可能な操作（`Transfer`、`Burn`、`Rename`...など）を定義するということである。いくつかのインターフェイスはすでに動作可能であるが、今後さらに増えていくだろう。

#### すぐに使えるインターフェース

**RGB20**は、イーサリアムのERC20標準と比較することができるカンジブル・アセットのためのインターフェースである。しかし、さらに一歩進んでおり、より広範な機能を提供している：


- 例えば、発行後のアセット名の変更（*ティッカー*やフルネームの変更）や、精度の調整（*株式分割*）が可能です；
- また、二次的な再発行（限定的または無制限）や、一定の条件下で資産を破棄し再作成することを発行者に許可するための、焼却と交換のメカニズムも記述することができる；

例えば、RGB20インターフェイスは、無膨張の初期供給を課す**Non-Inflatable Asset（NIA）スキーム**や、必要に応じて他のより高度なスキームとリンクさせることができる。

**RGB21**は、NFTタイプの契約、より広義にはデジタルメディア（画像、音楽など）の表現など、あらゆる固有のデジタルコンテンツに関するものです。単一の資産の発行と譲渡に関する記述に加え、以下のような特徴も含まれます：


- 契約にファイル（最大16MB）を直接含めるための統合サポート（クライアント側の検索用）；
- 所有者がNFTの過去の所有権を証明するために、履歴に「*刻印*」を記入する可能性がある。

**RGB25**は、カンジブルな側面とカンジブルでない側面を組み合わせたハイブリッドな標準である。これは、不動産のトークン化など、部分的にカンジブルな資産のために設計されており、1つのルート資産へのリンクを保持しながら資産を分割したい場合（言い換えれば、カンジブルでない家にリンクされた、カンジブルな家の断片がある場合）に使用します。技術的には、このインターフェイスは **Collectible Fungible Asset* (CFA)** スキーマにリンクすることができます。

#### 開発中のインターフェイス

その他のインターフェイスは、より専門的な用途のために計画されているが、まだ利用できない：


- RGB22**はデジタル・アイデンティティに特化し、RGBエコシステムにおける識別子とオンチェーン・プロファイルを管理する；
- RGB23**は、*Opentimestamps*のアイデアの一部を使用した高度なタイムスタンプで、トレーサビリティ機能を備えています；
- RGB24**は、*Ethereum Name Service*に似た分散型ドメイン名システム（DNS）に相当するものを目指している；
- RGB26**は、より複雑な形式（ガバナンス、投票など）でDAO（*分散型自律組織*）を管理するために設計された；
- RGB30**は、RGB20に非常に類似しているが、当初発行の分散化を考慮に入れ、状態拡張を使用するという特殊性がある。これは、再発行が複数の主体によって管理される資産や、より細かい条件の対象となる資産に使用される。

もちろん、このコースを受講された日によっては、これらのインターフェイスはすでに使用可能で、アクセスできるようになっているかもしれません。

#### インターフェース例

このRustコード・スニペットは、[RGB20](https://github.com/RGB-WG/rgb-std/blob/master/src/interface/rgb20.rs) インターフェース（ファンジブル・アセット）を示しています。このコードは標準RGBライブラリの`rgb20.rs`ファイルから抜粋したものです。インターフェイスの構造を理解し、それがどのように一方では（スキーマで定義された）ビジネスロジック、他方ではウォレットやユーザーに公開される機能性の橋渡しをするのかを理解するために、このコードを見てみましょう。

```rust
// ...
fn rgb20() -> Iface {
let types = StandardTypes::with(rgb20_stl());
Iface {
version: VerNo::V1,
name: tn!("RGB20"),
global_state: tiny_bmap! {
fname!("spec") => GlobalIface::required(types.get("RGBContract.DivisibleAssetSpec")),
fname!("data") => GlobalIface::required(types.get("RGBContract.ContractData")),
fname!("created") => GlobalIface::required(types.get("RGBContract.Timestamp")),
fname!("issuedSupply") => GlobalIface::one_or_many(types.get("RGBContract.Amount")),
fname!("burnedSupply") => GlobalIface::none_or_many(types.get("RGBContract.Amount")),
fname!("replacedSupply") => GlobalIface::none_or_many(types.get("RGBContract.Amount")),
},
assignments: tiny_bmap! {
fname!("inflationAllowance") => AssignIface::public(OwnedIface::Amount, Req::NoneOrMore),
fname!("updateRight") => AssignIface::public(OwnedIface::Rights, Req::Optional),
fname!("burnEpoch") => AssignIface::public(OwnedIface::Rights, Req::Optional),
fname!("burnRight") => AssignIface::public(OwnedIface::Rights, Req::NoneOrMore),
fname!("assetOwner") => AssignIface::private(OwnedIface::Amount, Req::NoneOrMore),
},
valencies: none!(),
genesis: GenesisIface {
metadata: Some(types.get("RGBContract.IssueMeta")),
global: tiny_bmap! {
fname!("spec") => ArgSpec::required(),
fname!("data") => ArgSpec::required(),
fname!("created") => ArgSpec::required(),
fname!("issuedSupply") => ArgSpec::required(),
},
assignments: tiny_bmap! {
fname!("assetOwner") => ArgSpec::many(),
fname!("inflationAllowance") => ArgSpec::many(),
fname!("updateRight") => ArgSpec::optional(),
fname!("burnEpoch") => ArgSpec::optional(),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_RESERVES
},
},
transitions: tiny_bmap! {
tn!("Transfer") => TransitionIface {
optional: false,
metadata: None,
globals: none!(),
inputs: tiny_bmap! {
fname!("previous") => ArgSpec::from_non_empty("assetOwner"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_non_empty("assetOwner"),
},
valencies: none!(),
errors: tiny_bset! {
NON_EQUAL_AMOUNTS
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("Issue") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.IssueMeta")),
globals: tiny_bmap! {
fname!("issuedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_non_empty("inflationAllowance"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_many("assetOwner"),
fname!("future") => ArgSpec::from_many("inflationAllowance"),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
ISSUE_EXCEEDS_ALLOWANCE,
INSUFFICIENT_RESERVES
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("OpenEpoch") => TransitionIface {
optional: true,
metadata: None,
globals: none!(),
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnEpoch"),
},
assignments: tiny_bmap! {
fname!("next") => ArgSpec::from_optional("burnEpoch"),
fname!("burnRight") => ArgSpec::required()
},
valencies: none!(),
errors: none!(),
default_assignment: Some(fname!("burnRight")),
},
tn!("Burn") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.BurnMeta")),
globals: tiny_bmap! {
fname!("burnedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnRight"),
},
assignments: tiny_bmap! {
fname!("future") => ArgSpec::from_optional("burnRight"),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_COVERAGE
},
default_assignment: None,
},
tn!("Replace") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.BurnMeta")),
globals: tiny_bmap! {
fname!("replacedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnRight"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_many("assetOwner"),
fname!("future") => ArgSpec::from_optional("burnRight"),
},
valencies: none!(),
errors: tiny_bset! {
NON_EQUAL_AMOUNTS,
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_COVERAGE
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("Rename") => TransitionIface {
optional: true,
metadata: None,
globals: tiny_bmap! {
fname!("new") => ArgSpec::from_required("spec"),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("updateRight"),
},
assignments: tiny_bmap! {
fname!("future") => ArgSpec::from_optional("updateRight"),
},
valencies: none!(),
errors: none!(),
default_assignment: Some(fname!("future")),
},
},
extensions: none!(),
error_type: types.get("RGB20.Error"),
default_operation: Some(tn!("Transfer")),
type_system: types.type_system(),
}
}
```

このインターフェイスでは、スキーマ構造と類似していることに気づきます。グローバル・ステート、所有ステート、コントラクト・オペレーション（ジェネシスとトランジション）、エラー処理の宣言があります。しかし、インターフェイスは、ウォレットやその他のアプリケーションのために、これらの要素のプレゼンテーションと操作に焦点を当てています。

Schemaとの違いは型の性質にある。Schema は厳密な型 (`FungibleType::Unsigned64Bit` など) とより技術的な識別子を使います。インターフェイスでは、フィールド名、マクロ（`fname!()`、`tn!()`）、引数クラスへの参照（`ArgSpec`、`OwnedIface::Rights`...）が使われる。ここでの目的は、ウォレットの要素の機能的な理解と整理を容易にすることである。

さらに、最終的に検証されたクライアントサイドのロジックと整合性が保たれている限り、インターフェイスは基本的なスキーマに追加機能を導入することができます（例えば、`burnEpoch`権の管理）。スキーマのAluVM "スクリプト "セクションは暗号の有効性を保証し、インターフェースはユーザー（またはウォレット）がこれらのステートとトランジションをどのようにやり取りするかを記述する。

#### グローバルな状態と割り当て

global_state`セクションには、`spec`（アセットの説明）、`data`、`created`、`issuedSupply`、`burnedSupply`、`replacedSupply`といったフィールドがある。これらはウォレットが読み込んで表示できるフィールドです。例えば


- spec`はトークンの設定を表示する；
- issuedSupply`や`burnedSupply`は、発行されたトークンや燃やされたトークンの総数などを示している。

assignments`セクションでは、様々な役割や権利を定義します。例えば


- assetOwner`はトークンの保有に対応する（カンジ可能な*所有状態*である）；
- burnRight`はトークンを燃やす能力に相当する；
- updateRight` はアセット名を変更する権利に相当します。

public`または `private` キーワード (例えば `AssignIface::public(...)`) は、これらの状態が可視 (`public`) か機密 (`private`) かを示す。Req::NoneOrMore`、`Req::Optional`については、予想される発生を示す。

#### 創世記と変遷

genesis`の部分は、アセットがどのように初期化されるかを記述します：


- spec`、`data`、`created`、`issuedSupply` フィールドは必須である (`ArgSpec::required()`)；
- assetOwner`のような代入は複数のコピー（`ArgSpec::many()`）で存在することができ、トークンを複数の初期保有者に配布することができる；
- inflationAllowance`や`burnEpoch`のようなフィールドはジェネシスに含まれるかもしれない（含まれないかもしれない）。

次に、各トランジション（`Transfer`、`Issue`、`Burn`...）について、その操作が入力として期待するフィールド、その操作が出力として生成するフィールド、発生する可能性のあるエラーを定義します。例えば

**トランジション


- 入力 : `previous` → `assetOwner` でなければならない；
- 割り当て : `beneficiary` →新しい `assetOwner` となる；
- エラー: `NON_EQUAL_AMOUNTS` (ウォレットは入力の合計が出力の合計と一致しないケースを扱うことができます)。

**トランジション `問題` :**。


- オプション（`optional: true`）、追加発光は必ずしも有効ではない；
- 入力：used` → `inflationAllowance` 、つまりトークンを追加する許可；
- 割り当て：beneficiary`（新しく受け取ったトークン）と `future`（残りの `inflationAllowance` ）；
- 考えられるエラーSUPPLY_MISMATCH`、`ISSUE_EXCEEDS_ALLOWANCE`など。

**バーン・トランジション


- 入力 : `used` → a `burnRight` ；
- グローバル : `burnedSupply` 必須 ；
- 割り当て：future`→まだすべてを燃やしていない場合、`burnRight`を継続する可能性がある；
- エラー：supply_mismatch`, `invalid_proof`, `insufficient_coverage`.

そのため、各操作はウォレットにとって読みやすい方法で記述されている。これによって、ユーザーがはっきりとわかるようなグラフィカル・インターフェースを表示することが可能になる：「あなたには燃やす権利があります。ある量を燃やしたいですか？このコードは`burnedSupply`フィールドを埋めることと、`burnRight`が有効であることをチェックすることを知っています。

要約すると、インターフェイスがどんなに完全なものであっても、それ自体がコントラクトの内部ロジックを定義するものではないということを心に留めておくことが重要である。仕事の中心は、厳密な型、創世記の構造、トランジションなどを含む**スキーマ**によって行われる。インターフェイスは、アプリケーションで使用するために、これらの要素をより直感的な方法で、名前を付けて公開するだけです。

RGBのモジュール性のおかげで、契約全体を書き直すことなく、インターフェイスをアップグレードすることができます（例えば、`Rename`トランジションを追加したり、フィールドの表示を修正したりなど）。このインターフェースのユーザーは、`.rgb`または`.rgba`ファイルを更新するとすぐに、これらの改良の恩恵を受けることができます。

しかし、インターフェイスを宣言したら、対応するスキーマにリンクする必要があります。これは ***Interface Implementation*** によって行われ、名前付きフィールド（`fname!("assetOwner")`など）をスキーマで定義された厳密なID（`OS_ASSET`など）にマッピングする方法を指定します。これにより、例えばウォレットが`burnRight`フィールドを操作する場合、スキーマではトークンを燃やす能力を表す状態であることが保証されます。

### インターフェイスの実装

RGBアーキテクチャでは、各コンポーネント（スキーマ、インターフェイスなど）は独立して開発、コンパイルできることがわかりました。しかし、これらの異なるビルディング・ブロックを結びつける欠かすことのできない要素があります。これは、スキーマ（ビジネスロジック側）で定義された識別子やフィールドを、インターフェイス（プレゼンテーションとユーザーインタラクション側）で宣言された名前に明示的にマッピングするものです。そのため、ウォレットがコントラクトをロードするとき、どのフィールドが何に対応し、インターフェイスで命名された操作がどのようにスキーマのロジックに関係するかを正確に理解することができます。

重要な点は、インターフェイス実装は必ずしも全てのスキーマ機能や全てのインターフェイスフィールドを公開することを意図しているわけではないということである。実際には、これによってスキーマの特定の側面を制限したり、フィルタリングしたりすることが可能になります。例えば、4種類のオペレーションを持つスキーマがあったとしても、あるコンテキストではそのうちの2つだけをマッピングする実装インターフェイスがあるとします。逆に、Interfaceが追加のエンドポイントを提案している場合、ここではそれを実装しないこともできます。

これはインターフェイス実装の典型的な例で、*Non-Inflatable Asset*（NIA）スキーマをRGB20インターフェイスに関連付ける：

```rust
fn nia_rgb20() -> IfaceImpl {
let schema = nia_schema();
let iface = Rgb20::iface();
IfaceImpl {
version: VerNo::V1,
schema_id: schema.schema_id(),
iface_id: iface.iface_id(),
script: none!(),
global_state: tiny_bset! {
NamedField::with(GS_NOMINAL, fname!("spec")),
NamedField::with(GS_DATA, fname!("data")),
NamedField::with(GS_TIMESTAMP, fname!("created")),
NamedField::with(GS_ISSUED_SUPPLY, fname!("issuedSupply")),
},
assignments: tiny_bset! {
NamedField::with(OS_ASSET, fname!("assetOwner")),
},
valencies: none!(),
transitions: tiny_bset! {
NamedType::with(TS_TRANSFER, tn!("Transfer")),
},
extensions: none!(),
}
}
```

この実装インターフェイスでは：


- スキーマは `nia_schema()` から、インターフェースは `Rgb20::iface()` から明示的に参照する。schema.schema_id()`と `iface.iface_id()`の呼び出しは、コンパイル側でインターフェースの実装をアンカーするために使用される（これはこれら2つのコンポーネントの暗号識別子を関連付ける）；
- スキーマの要素とインターフェースの要素の間にはマッピングが確立されている。例えば、スキーマの `GS_NOMINAL` フィールドはインターフェースの `"spec"` という文字列にリンクされます（`NamedField::with(GS_NOMINAL, fname!("spec"))`）。TS_TRANSFER`のような操作についても同様で、インターフェイスの`"Transfer"`にリンクします；
- バレンシー（`valencies: none!()`）やエクステンション（`extensions: none!()`）がないことがわかるが、これはこのNIAコントラクトがこれらの機能を使用していないことを反映している。

コンパイル後の結果は、スキーマとインターフェイスに加えてウォレットにインポートされる、別個の`.rgb`または`.rgba`ファイルである。このように、ソフトウェアはこのNIAコントラクト（そのロジックはスキーマによって記述される）を "RGB20 "インターフェイス（これは人間の名前とカジブルトークンのインタラクションモードを提供する）に具体的に接続する方法を知っており、このインターフェイス実装を2つの間のゲートウェイとして適用する。

#### なぜインターフェイスの実装を分けるのか？

分離は柔軟性を高める。一つのスキーマに複数の異なるインターフェイス実装を持つことができ、それぞれが異なる機能セットをマッピングする。さらに、スキーマやインターフェイスを変更することなく、インターフェイス実装自体を進化させたり書き換えたりすることができます。これはRGBのモジュール性の原則を維持するもので、プロトコルによって課された互換性ルール（同じ識別子、型の一貫性など）が尊重される限り、各コンポーネント（スキーマ、インターフェース、インターフェース実装）は独立してバージョンアップや更新が可能です。

具体的な使用方法としては、ウォレットがコントラクトをロードする際、：


- コンパイルされた**スキーマ**をロードする（ビジネスロジックの構造を知るため）；
- コンパイルされた**インターフェイス**をロードする（名前とユーザー側の操作を理解するため）；
- コンパイルされた**Interface Implementation**をロードする（SchemaロジックをInterface名に、オペレーションごとに、フィールドごとにリンクする）。

このモジュラー・アーキテクチャーにより、.NETや.NET Frameworkのような使用シナリオが可能になる：


- 特定のユーザーに対して特定の操作を制限する：例えば、書き込みや更新機能を提供せず、基本的な転送のみにアクセスできる部分的な実装インターフェースを提供する；
- 変更プレゼンテーション：契約の基本を変更することなく、Interfaceのフィールド名を変更したり、マッピングを変更したりするInterface Implementationを設計する；
- 複数のスキームをサポート：ウォレットは、異なるスキーム（異なるトークンロジック）を扱うために、同じインターフェイスタイプに対して複数のインターフェイス実装をロードすることができます。

次の章では、契約譲渡の仕組みと、RGBの請求書がどのように作成されるかについて見ていく。

## 契約移籍

<chapterId>f043a307-d420-5752-b0d7-ebfd845802c0</chapterId>

![video](https://youtu.be/sVoKIi-1XbY)

この章では、RGBエコシステムにおける契約譲渡のプロセスを分析する。これを説明するために、RGB資産を交換したいアリスとボブを例にとって説明します。また、`rgb`コマンドラインツールのコマンドをいくつか抜粋して、実際にどのように動作するかを見てみましょう。

### RGB契約移行を理解する

アリスとボブ間の送金の例を見てみよう。この例では、BobはRGBを使い始めたばかりで、Aliceは既にウォレットにRGB資産を保有していると仮定します。ボブがどのように環境をセットアップし、関連する契約をインポートし、アリスに送金を要求し、最後にアリスがどのようにビットコインブロックチェーン上で実際の取引を実行するかを見ていきます。

#### 1) RGBウォレットの取り付け

まず最初に、BobはRGBウォレット、つまりプロトコルと互換性のあるソフトウェアをインストールする必要がある。これには当初コントラクトは含まれていない。ボブはまた、：


- UTXOを管理するビットコイン・ウォレット；
- ビットコインノード（またはElectrumサーバー）への接続により、UTXOを識別し、ネットワーク上でトランザクションを伝播することができます。

注意点として、RGBの**所有状態**はBitcoin UTXOを指す。したがって、RGBデータを指す暗号コミットメント（`Tapret`または`Opret`）を組み込んだBitcoinトランザクションにおいて、UTXOを常に管理し、使用できるようにしなければならない。

#### 2) 契約情報の取得

ボブは次に、興味のある契約データを取得する必要がある。このデータは、ウェブサイト、電子メール、メッセージング・アプリケーション...など、どのような経路でも流通することができる。実際には、これらのデータは***委託***、つまり.NET Frameworkを含む小さなデータパケットにまとめられる：


- 契約の初期状態を定義する**ジェネシス**；
- ビジネス・ロジック（厳格な型、検証スクリプトなど）を記述する**スキーマ**；
- プレゼンテーション層（フィールド名、アクセス可能な操作）を定義する**インターフェース**；
- スキーマとインターフェイスを具体的に結びつける**インターフェイス実装**。

![RGB-Bitcoin](assets/fr/075.webp)

各コンポーネントの重さは一般的に200バイト未満なので、総サイズは数キロバイト程度になることが多い。また、この委託品をBase58で、検閲に強いチャンネル（例えばNostrやLightning Network経由）で、あるいはQRコードとして放送することも可能かもしれない。

#### 3) 契約書のインポートと検証

ボブは委託品を受け取ると、それをRGBウォレットにインポートする。そうすると：


- ジェネシスとスキーマが有効であることを確認する；
- ロードインターフェイスとインターフェイスの実装 ；
- クライアント側のデータを更新する。

ボブは自分の財布の中の資産を見ることができ（まだ所有していなくても）、どのフィールドが利用可能か、どのような操作が可能か...を理解することができる。そして、譲渡する資産を実際に所有している人に連絡する必要があります。この例ではアリスです。

特定のRGBアセットを誰が保有しているかを発見するプロセスは、ビットコインの支払者を見つけるのと似ている。この接続の詳細は、用途（マーケットプレイス、プライベートチャットチャンネル、請求書発行、商品やサービスの販売、給与...）によって異なります。

#### 4) インボイスの発行

RGB資産の譲渡を開始するには、ボブはまずインボイスを発行しなければならない。このインボイスは：


- 実行する操作のタイプをAliceに伝えてください(例えば、RGB20インターフェースからの`Transfer`など)；
- アリスにボブの*シール定義*(つまり、彼が資産を受け取りたいUTXO)を提供する；
- 必要な有効成分の量を指定する（例：100単位）。

ボブはコマンドラインで `rgb` ツールを使用する。彼は `ContractId` がわかっているトークンを100ユニット欲しがっており、 `Tapret` に依存し、UTXO (`456e3..dfe1:0`) を指定しているとする：

```bash
bob$ rgb invoice RGB20 100 <ContractId> tapret1st:456e3..dfe1:0
```

この章の最後で、RGB請求書の構造について詳しく見ていこう。

#### 5) インボイスの送信

生成された送り状（例：URL: `rgb:2WBcas9.../RGB20/100+utxob:...`）には、アリスが送金を準備するために必要なすべての情報が含まれています。委託書と同じように、コンパクトにエンコードして（Base58や他のフォーマット）、メッセージングアプリケーション、Eメール、Nostr...などで送ることができる。

![RGB-Bitcoin](assets/fr/076.webp)

#### 6）アリス側での取引準備

アリスはボブの請求書を受け取る。彼女のRGBウォレットには、送金される資産を含む隠し場所があります。資産を含むUTXOを使うために、彼女はまずPSBT（*Partially Signed Bitcoin Transaction*）、つまり不完全なビットコイン取引を、彼女が持っているUTXOを使って生成しなければならない：

```bash
alice$ wallet construct tx.psbt
```

この基本トランザクション(現時点では署名なし)は、Bobへの送 金にリンクされた暗号コミットメントのアンカーとして使用される。AliceのUTXOはこのようにして使用され、出力にはBobのための `Tapret`または`Opret`コミットメントが置かれる。

#### 7) 譲渡委託の発生

次に、アリスは****端末委託***（"転送委託 "と呼ばれることもある）を ：

```bash
alice$ rgb transfer tx.psbt <invoice> consignment.rgb
```

この新しい`consignment.rgb`ファイルには：


- 現在に至るまで（創世記以降）、その資産を検証するために必要な状態遷移の全履歴；
- ボブが発行した請求書に従って、アリスからボブに資産を移転する新しい状態遷移；
- 不完全なビットコイン取引（*ウィットネス取引*）（`tx.psbt`）はアリスのシングルユーズシールを使い、ボブへの暗号コミットメントを含むように修正された。

この段階では、取引はまだビットコインネットワーク上でブロードキャストされていません。資産の正当性を証明するための全履歴（*プルーフチェーン*）が含まれるため、基本的な委託よりも規模が大きくなります。

#### 8) ボブは委託品をチェックし、受け入れる。

アリスはこの**端末委託**をボブに送信する。ボブはその後：


- 状態遷移の妥当性をチェックする（履歴が一貫しているか、契約ルールが尊重されているかなどを確認する）；
- 地元の隠し場所に加えよう；
- 審査され、承認されたことを証明するために、荷物に署名(`sig:...`)を入れることもできる（"*payslip*"と呼ばれることもある）。

```bash
bob$ rgb accept consignment.rgb
sig:DbwzvSu4BZU81jEpE9FVZ3xjcyuTKWWy2gmdnaxtACrS
```

![RGB-Bitcoin](assets/fr/077.webp)

#### 9)オプション：ボブはアリスに確認を送り返す (*payslip*)

ボブが望むなら、この署名をアリスに送り返すことができる。これは


- その移行が有効であると認めるということだ；
- ビットコイン取引がブロードキャストされることに同意していること。

これは強制的なものではないが、アリスに譲渡をめぐる紛争が起こらないという保証を与えることができる。

#### 10) アリスはトランザクションに署名し、公開する。

アリスはそのとき


- ボブの署名をチェックする (`rgb check <sig>`) ；
- PSBTである*立会取引*に署名する（`wallet sign`）；
- 証人トランザクションをビットコインネットワークに公開する（`-publish`）。

```bash
alice$ rgb check <sig>
alice$ wallet sign —publish tx.psbt
```

![RGB-Bitcoin](assets/fr/078.webp)

確認されると、この取引は譲渡の完了を意味する。ボブは資産の新しい所有者となる。彼は今、自分がコントロールするUTXOを指すOwned Stateを持ち、取引におけるコミットメントの存在によって証明される。

要約すると、これが完全な移籍のプロセスである：

![RGB-Bitcoin](assets/fr/079.webp)

### RGB転送の利点


- 守秘義務** ：

アリスとボブだけがすべての状態遷移データにアクセスできる。彼らはこの情報をブロックチェーンの外で、委託を通じて交換する。ビットコイン取引における暗号コミットメントは資産の種類や金額を明らかにしないため、他のオンチェーントークンシステムよりもはるかに高い機密性が保証される。


- 顧客側の検証** ：

ボブは、ビットコインブロックチェーンの*委託*と*アンカー*を比較することで、送金の一貫性をチェックできる。彼は第三者の検証を必要としない。アリスはブロックチェーン上で完全な履歴を公開する必要がないため、基本プロトコルの負荷が軽減され、機密性が向上する。


- 簡略化された原子性** ：

複雑な交換（例えば、BTCとRGB資産間のアトミックスワップ）は、HTLCやPTLCスクリプトの必要性を回避し、単一のトランザクション内で実行することができます。合意がブロードキャストされない場合、誰もがUTXOを別の方法で再利用できる。

### 移籍概要図

インボイスを詳しく見る前に、RGB移籍の全体的な流れを図にまとめてみた：


- ボブはRGBウォレットを取り付け、最初の契約委託を受ける；
- ボブは、UTXOが資産を受け取る場所を明記した請求書を発行する；
- アリスはインボイスを受け取り、PSBTを構築し、端末委託を生成する；
- ボブはそれを受け取り、チェックし、データを隠し場所に追加し、必要であればサインする（*payslip*）；
- アリスはビットコインネットワーク上でトランザクションを公開する；
- 取引が確認されれば、正式に移籍が成立する。

![RGB-Bitcoin](assets/fr/080.webp)

この送金は、RGBプロトコルのすべてのパワーと柔軟性を示している：クライアント側で検証され、ビットコインブロックチェーン上に最小かつ目立たないように固定されたプライベートな交換であり、プロトコルの最高のセキュリティ（二重支出のリスクなし）を保持している。これによりRGBは、オンチェーンプログラマブルブロックチェーンよりも機密性が高くスケーラブルな価値移転のための有望なエコシステムとなる。

### 請求書 RGB

このセクションでは、**インボイス**がRGBエコシステムでどのように機能し、どのようにコントラクトでの操作（特に送金）を可能にするかを詳しく説明します。最初に、使用される識別子を見て、次にそれらがどのようにエンコードされるかを見て、最後にURL（ウォレットで使用するのに十分便利なフォーマット）として表現される請求書の構造を見ていきます。

#### 識別子とエンコーディング

以下の各要素には一意な識別子が定義されている：


- RGB契約；
- そのスキーマ（ビジネス・ロジック） ；
- そのインターフェイスとインターフェイスの実装 ；
- その資産（トークン、NFTなど）、

システムの各コンポーネントは区別できなければならないので、この一意性は非常に重要である。たとえば、ある契約Xが別の契約Yと混同されることがあってはならないし、2つの異なるインターフェース（たとえばRGB20とRGB21）には、明確な識別子がなければならない。

これらの識別子を効率的（小さいサイズ）で読みやすくするために、：


- Base58エンコーディングは、紛らわしい文字（例えば`0`と文字`O`）の使用を避け、比較的短い文字列を提供する；
- 識別子の性質を示す接頭辞で、通常は `rgb:` または同様の URN の形式をとる。

例えば、`ContractId` は ：

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX
```

rgb:`プレフィックスは、これがHTTPリンクや他のプロトコルではなく、RGB識別子であることを確認します。この接頭辞のおかげで、ウォレットは文字列を正しく解釈することができます。

#### 識別子セグメンテーション

RGBの識別子は、しばしば非常に長くなります。これは、基礎となる（暗号）セキュリティが256ビット以上のフィールドを必要とする場合があるためです。人間による読み取りと検証を容易にするため、私たちはこれらの文字列をハイフン（`-`）で区切られたいくつかのブロックに分割*しています。つまり、長い文字列が途切れることなく続く代わりに、短いブロックに分割するのです。この方法はクレジットカード番号や電話番号では一般的ですが、ここでも検証を容易にするために適用されます。例えば、ユーザーやパートナーにこう伝えることができる：「例えば、ユーザーやパートナーに「3番目のブロックが`9GEgnyMj7`*であることを確認してください。最後のブロックはしばしば**チェックサム**として使用される。

例として、`ContractId`をbase58でエンコードし、セグメンテーションしたものは：

```txt
2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX
```

それぞれのダッシュは文字列をセクションに分割する。これはコードのセマンティクスには影響せず、表示のみに影響する。

#### 請求書にURLを使用する

RGBインボイスはURLとして提示される。つまり、クリックまたはスキャン（QRコードとして）することで、ウォレットはそれを直接解釈して取引を行うことができる。このインタラクションのシンプルさは、ソフトウェアのさまざまなフィールドにさまざまなデータをコピー＆ペーストしなければならない他のシステムとは異なる。

カンジブルトークン（たとえばRGB20トークン）の請求書は次のようになる：

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/100+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

このURLを分析してみよう：


- rgb:`** (接頭辞): RGBプロトコルを呼び出すリンクを示す (他の文脈では `http:` や `bitcoin:` に相当する)；
- 2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX`**: 操作したいトークンの `ContractId` を表す；
- RGB20/100`**: `RGB20` インターフェースが使用され、100 単位のアセットが要求されたことを示します。構文は以下の通りです：構文は次のとおりです： `/Interface/amount` ；
- `+utxob:`**: 受け手のUTXOに関する情報(より正確には、Single-use Sealの定義)が追加されることを指定する；
- egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb`**：これは*blinded* UTXO(またはシールの定義)である。言い換えると、ボブは正確なUTXOを隠しているので、送信者(アリス) は正確なアドレスを知らない。彼女が知っているのは、ボブがコントロールするUTXOを参照する有効なシールがあるということだけです。

すべてが1つのURLに収まることで、ユーザーにとって生活がより簡単になる。ウォレットをクリックするかスキャンするだけで、操作の準備が整う。

ContractId`の代わりに単純なティッカー(例えば `USDT`)を使用するシステムも考えられる。ティッカーは一意の参照ではない（複数のコントラクトが `USDT` と名乗る可能性がある）。RGBでは、一意で、曖昧さのない暗号識別子が必要である。そのため、base58でエンコードされ、セグメント化された256ビットの文字列が採用された。ユーザーは、IDが`2WBcas9-yjz...`であるコントラクトを操作しているのであって、他のコントラクトを操作しているのではないことがわかる。

#### 追加URLパラメータ

また、HTTPの場合と同じように、.NET FrameworkのようなパラメータをURLに追加することもできる：

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/100+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb?sig=6kzbKKffP6xftkxn9UP8gWqiC41W16wYKE5CYaVhmEve
```


- sig=...`: 例えば請求書に関連付けられた署名を表し、ウォレットによってはこれを検証することができる；
- ウォレットがこの署名を管理しない場合、単にこのパラメータを無視する。

RGB21インターフェースを介したNFTの場合を考えてみよう。例えば、：

```txt
rgb:7BKsac8-beMNMWA8r-3GEprtFh7-bjzEvGufY-aNLuU4nSN-MRsLOIK/RGB21/DbwzvSu-4BZU81jEp-E9FVZ3xj-cyuTKWWy-2gmdnaxt-ACrS+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

ここで我々は見た：


- rgb:`**：URLプレフィックス ；
- 7BKsac8-beMNMWA8r-3GEprtFh7-bjzEvGufY-aNLuU4nSN-MRsLOIK`**：契約ID (NFT) ；
- rGB21**：非腐食性資産（NFT）用インターフェース ；
- DbwzvSu-4BZU81jEp-...`**：NFTの一意な部分への明示的な参照、例えばデータブロブ（メディア、メタデータ...）のハッシュなど；
- utxob:egXsFnw-...`**：シールの定義。

考え方は同じで、ウォレットが解釈できるユニークなリンクを送信し、譲渡されるユニークな資産を明確に特定する。

#### URLによるその他の操作

RGB URLは単に転送を要求するために使用されるだけではない。新しいトークンの発行（*issuance*）など、より高度な操作をエンコードすることもできる。例えば

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/issue/100000+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

ここで、我々は見つける：


- rgb:` : プロトコル ；
- 2WBcas9-...`：契約ID ；
- RGB20/issue/100000`：「*Issue*」トランジションを呼び出して、さらに10万トークンを作成したいことを示す；
- utxob:`：シールの定義。

例えば、財布にはこう書かれているかもしれない：「RGB20`インターフェースから、このような契約で、このようなシングルユースのシールのために、100,000ユニット分の`発行`操作を実行するように依頼されました。

さて、RGBプログラミングの主な要素を見てきたので、次の章ではRGB契約書の書き方について説明しよう。

## スマート・コントラクトのドラフト

<chapterId>0e0a645c-0049-588d-8965-b8c536590cc9</chapterId>

![video](https://youtu.be/GRwS-NvWF3I)

この章では、コマンドラインツール `rgb` を使って、コントラクトを書くためのステップバイステップのアプローチを取ります。CLIをインストールし、**スキーマ**をコンパイルし、**インターフェース**と**インターフェースの実装**をインポートし、アセットを発行(*issue*)する方法を紹介します。また、コンパイルや状態の検証など、基礎となるロジックについても見ていきます。この章が終わる頃には、プロセスを再現し、独自のRGBコントラクトを作成できるようになっているはずです。

備考として、RGBの内部ロジックはRustライブラリに基づいており、開発者として、クライアント側の検証部分を管理するためにプロジェクトにインポートすることができます。さらに、LNP/BPアソシエーション・チームは他の言語向けのバインディングに取り組んでいますが、これはまだ確定していません。さらに、Bitfinexのような他の事業体も独自の統合スタックを開発中です（これらについてはコースの最後の2章で説明します）。したがって、当面は `rgb` CLI が公式のリファレンスとなる。

### rgbツールのインストールとプレゼンテーション

メインコマンドは単純に `rgb` と呼ばれる。このコマンドは `git` を彷彿とさせるように設計されており、コントラクトの操作、起動、アセットの発行などを行うサブコマンドのセットを備えている。ビットコイン・ウォレットは現在統合されていないが、近いバージョン（0.11）で統合される予定である。この次のバージョンでは、PSBTの生成、署名のための外部ハードウェア（ハードウェアウォレットなど）との互換性、Sparrowのようなソフトウェアとの相互運用性を含め、`rgb`から直接ウォレットを（記述子を介して）作成・管理できるようになります。これにより、資産の発行と移転のシナリオ全体が簡素化される。

#### カーゴ経由での設置

私たちは.NET Frameworkを使ってRustにツールをインストールする：

```bash
cargo install rgb-contracts --all-features
```

(注意: クレートは `rgb-contracts` という名前で、インストールされるコマンドは `rgb` という名前になる。rgb`という名前のクレートが既に存在していた場合、衝突する可能性があるため、この名前になった)

インストールでは、多数の依存関係（コマンドの解析、Electrumの統合、ゼロ知識証明の管理など）がコンパイルされる。

インストールが完了すると、.NET Frameworkが起動します：

```bash
rgb
```

引数なしで`rgb`を実行すると、`interfaces`, `schema`, `import`, `export`, `issue`, `invoice`, `transfer`などのサブコマンドの一覧が表示されます。ローカルストレージディレクトリ（すべてのログ、回路図、実装を保存するスタッシュ）の変更、ネットワーク（testnet、mainnet）の選択、Electrumサーバーの設定を行うことができます。

![RGB-Bitcoin](assets/fr/081.webp)

#### コントロールの最初の概要

以下のコマンドを実行すると、`RGB20`インターフェースがデフォルトですでに統合されていることがわかる：

```bash
rgb interfaces
```

このインターフェイスが統合されていない場合は、.NET Frameworkをクローンしてください：

```bash
git clone https://github.com/RGB-WG/rgb-interfaces
```

それをコンパイルする：

```bash
cargo run
```

次に、お好みのインターフェイスをインポートする：

```bash
rgb import interfaces/RGB20.rgb
```

![RGB-Bitcoin](assets/fr/082.webp)

一方、スキーマはまだソフトにインポートされていないと聞いている。隠し場所には契約書もない。これを見るには、：

```bash
rgb schemata
```

その後、リポジトリをクローンして特定の回路図を取り出すことができる：

```bash
git clone https://github.com/RGB-WG/rgb-schemata
```

![RGB-Bitcoin](assets/fr/083.webp)

このリポジトリの `src/` ディレクトリには、スキーマ（NIA は "*Non Inflatable Asset*"、UDA は "*Unique Digital Asset*"など）を定義するいくつかの Rust ファイル（`nia.rs` など）が含まれています。コンパイルするには、：

```bash
cd rgb-schemata
cargo run
```

これにより、コンパイルされた回路図に対応するいくつかの `.rgb` ファイルと `.rgba` ファイルが生成されます。例えば、`NonInflatableAsset.rgb`があります。

#### スキーマとインターフェース実装のインポート

これで回路図を `rgb` にインポートできる：

```bash
rgb import schemata/NonInflatableAssets.rgb
```

![RGB-Bitcoin](assets/fr/084.webp)

これでローカル・スタッシュに追加される。以下のコマンドを実行すると、スキーマが表示される：

```bash
rgb schemata
```

### 契約書作成（発行）

新しいアセットを作るには2つのアプローチがある：


- スキーマ・フィールド（グローバル状態、所有状態など）を入力してコントラクトを構築し、`.rgb`または`.rgba`ファイルを生成するスクリプトかRustのコードを使用する；
- または、トークンのプロパティを記述した YAML (または TOML) ファイルを指定して `issue` サブコマンドを直接使用します。

examples`フォルダにRustのサンプルがあり、`ContractBuilder`を構築し、`Global State`（アセット名、ティッカー、供給量、日付など）を記入し、Owned State（どのUTXOに割り当てられるか）を定義し、これらすべてを*契約委託*にまとめ、エクスポート、検証、隠し場所にインポートする方法を説明しています。

もう1つの方法は、手動でYAMLファイルを編集して、`ticker`、`name`、`supply`などをカスタマイズすることである。ファイル名を `RGB20-demo.yaml` とする。ファイル名に ：


- spec`: ティッカー、名前、精度 ；
- terms`：法的通知用のフィールド；
- issuedSupply` : トークンの発行量；
- assignments`：シングルユースシール（*シールの定義*）とロック解除された数量を示す。

以下に作成するYAMLファイルの例を示します：

```yaml
interface: RGB20Fixed
globals:
spec:
ticker: PBN
name: Plan B Network
details: "Pay attention: the asset has no value"
precision: 2
terms:
text: >
SUBJECT TO, AND WITHOUT IN ANY WAY LIMITING, THE REPRESENTATIONS AND WARRANTIES OF ANY SELLER. PROPERTY IS BEING SOLD “AS IS”...
media: ~
issuedSupply: 100000000
assignments:
assetOwner:
seal: tapret1st:b449f7eaa3f98c145b27ad0eeb7b5679ceb567faef7a52479bc995792b65f804:1
amount: 100000000 # this is 1 million (we have two digits for cents)
```

![RGB-Bitcoin](assets/fr/085.webp)

その後、：

```bash
rgb issue '<SchemaID>' ssi:<Issuer> rgb20-demo.yaml
```

![RGB-Bitcoin](assets/fr/086.webp)

私の場合、一意なスキーマ識別子（一重引用符で囲む）は`RDYhMTR!9gv8Y2GLv9UNBEK1hcrCmdLDFk9Qd5fnO8k`で、発行者は書いていません。だから私の注文は：

```txt
rgb issue 'RDYhMTR!9gv8Y2GLv9UNBEK1hcrCmdLDFk9Qd5fnO8k' ssi:anonymous rgb20-demo.yaml
```

スキーマIDがわからない場合は、 ：

```bash
rgb schemata
```

CLIは、新しいコントラクトが発行され、スタッシュに追加されたと返答する。次のコマンドを入力すると、先ほど発行されたコントラクトに対応するコントラクトが追加されていることがわかる：

```bash
rgb contracts
```

![RGB-Bitcoin](assets/fr/087.webp)

次のコマンドは、グローバルな状態(名前、ティッカー、供給量...)と所有状態のリスト、つまり割り当て(例えば、UTXO `b449f7eaa3f98c145b27ad0eeb7b5679ceb567faef7a52479bc995792b65f804:1` で定義された100万 `PBN` トークン)を表示します。

```bash
rgb state '<ContractId>'
```

![RGB-Bitcoin](assets/fr/088.webp)

### エクスポート、インポート、検証

この契約書を他のユーザーと共有するには、隠し場所から.NETファイルにエクスポートします：

```bash
rgb export '<ContractId>' myContractPBN.rgb
```

![RGB-Bitcoin](assets/fr/089.webp)

myContractPBN.rgb`ファイルは他のユーザーに渡すことができ、そのユーザーは ：

```bash
rgb import myContractPBN.rgb
```

インポート時、それが単純な*契約委託*であれば、"`Importing consignment rgb`"というメッセージが表示される。より大きな*状態遷移委託*であれば、コマンドは異なるものになる（`rgb accept`）。

妥当性を保証するために、ローカル・バリデーション関数を使うこともできる。たとえば、：

```bash
rgb validate myContract.rgb
```

#### スタッシュの使用、検証、表示

注意点として、スタッシュはスキーマ、インターフェース、実装、コントラクト（ジェネシス＋トランジション）のローカルインベントリである。import "を実行するたびに、stashに要素が追加されます。この隠し場所は、：

```bash
rgb dump
```

![RGB-Bitcoin](assets/fr/090.webp)

これで、隠し場所全体の詳細が入ったフォルダが生成される。

### 移籍とPSBT

送金を実行するには、`Tapret`または`Opret`のコミットメントを管理するために、ローカルのビットコインウォレットを操作する必要があります。

#### 請求書の作成

ほとんどの場合、契約の参加者（例えばアリスとボブ）間のやり取りは、インボイスの生成を通じて行われる。アリスがボブに何か（トークンの移動、再発行、DAOのアクションなど）の実行を望む場合、アリスはボブへの指示を詳細に記したインボイスを作成する。つまり、：


- アリス**（請求書の発行者）；
- ボブ**（請求書を受け取り、実行する人）。

他のエコシステムと異なり、RGBインボイスは支払いという概念に限定されない。鍵の失効、投票、NFTへの刻印（*engraving*）の作成など、契約に関連するあらゆる要求を埋め込むことができる。対応する操作は、契約インターフェースに記述することができる。対応する操作は、契約インターフェイスに記述することができる。

次のコマンドはRGBインボイスを生成する：

```bash
$ rgb invoice $CONTRACT -i $INTERFACE $ACTION $STATE $SEAL
```

と：


- 契約識別子 (*ContractId*) ;`$CONTRACT`：契約識別子 (*ContractId*) ；
- INTERFACE`：使用するインターフェース（例：`RGB20`） ；
- ACTION`：インターフェイスで指定された操作の名前（単純なカンジタブルトークンの転送の場合、"Transfer "となる）。インターフェースが既にデフォルトのアクションを提供している場合は、ここで改めて入力する必要はない；
- STATE`: 転送されるステータスデータ (例えば、カンジブルトークンが転送される場合はトークンの量)；
- SEAL`: 受取人(Alice)のSingle-use Seal、すなわちUTXOへの明示的な参照。Bobはこの情報を使って証人のトランザクションを構築し、対応する出力はAliceに帰属する(*blinded UTXO*または暗号化されていない形で)。

例えば、次のようなコマンド

```bash
alice$ CONTRACT='iZgIN9EL-2H21UgQ-x!A3uJc-WwXhCSm-$9Lwcc1-v!mUkKY'
alice$ MY_UTXO=4960acc21c175c551af84114541eace09c14d3a1bb184809f7b80916f57f9ef8:1
alice$ rgb invoice $CONTRACT -i RGB20 --amount 100 $MY_UTXO
```

CLIは以下のような請求書を作成する：

```bash
rgb:iZgIN9EL-2H21UgQ-x!A3uJc-WwXhCSm-$9Lwcc1-v!mUkKY/RGB20/100+utxob:zlVS28Rb-...
```

どのようなチャンネル（テキスト、QRコードなど）でもボブに送信できる。

#### 移籍する

この請求書から移行するには ：


- トークンを隠し持つ）Bobはビットコインウォレットを持っている。彼は、必要なRGBトークンがあるUTXOと通貨（交換）用の1つのUTXOを消費するビットコイン取引（PSBTの形式、例えば`tx.psbt`）を準備する必要がある；
- ボブは次のコマンドを実行する：

```bash
bob$ rgb transfer tx.psbt $INVOICE consignment.rgb
```


- これは.NET Frameworkを含む`consignment.rgb`ファイルを生成する：
 - 移行履歴は、トークンが本物であることをアリスに証明する；
 - アリスのシングル・ユース・シールにトークンを転送する新しいトランジション；
 - 証人トランザクション（符号なし）。
- Bobはこの`consignment.rgb`ファイルをAliceに送る（電子メール、共有サーバー、RGB-RPCプロトコル、Stormなどで）；
- アリスは`consignment.rgb`を受け取り、自分の隠し場所に置く：

```bash
alice$ rgb accept consignment.rgb
```


- CLIはトランジションの有効性をチェックし、アリスの隠し場所に追加します。無効な場合、コマンドは詳細なエラーメッセージとともに失敗する。そうでなければ成功し、サンプル取引がまだビットコインネットワークにブロードキャストされていない（ボブはアリスのグリーンライトを待っている）ことを報告する；
- 確認のために、`accept`コマンドは署名(*payslip*)を返します；
- その後、Bobは自分のBitcoin取引に署名して公開することができる：

```bash
bob$ rgb check <sig> && wallet sign --publish tx.psbt
```


- このトランザクションがオンチェーンで確認されるとすぐに、アセットの所有権はAliceに移ったとみなされます。Aliceのウォレットはトランザクションのマイニングを監視しており、新しいOwned Stateがキャッシュに表示されるのを確認します。

次の章では、ライトニング・ネットワークへのRGBの統合について詳しく見ていく。

## ライトニング・ネットワークのRGB

<chapterId>0962980a-8f94-5d0f-9cd0-43d7f884a01d</chapterId>

![video](https://youtu.be/mqCupTlDbA0)

本章では、ライトニング・ネットワーク内でRGBをどのように利用し、オフチェーン決済チャネルを通じてRGB資産（トークン、NFTなど）を統合・移動できるかを検討する。

基本的な考え方は、RGBの状態遷移（*State Transition*）はビットコイントランザクションにコミットすることができ、そのトランザクションはライトニングチャネルがクローズされるまでオフチェーンに留まることができるというものだ。そのため、チャネルが更新されるたびに、新しいRGB状態遷移を新しいコミットトランザクションに組み込むことができ、古い遷移は無効になる。このように、ライトニングチャネルはRGB資産の移転に使用することができ、従来のライトニングペイメントと同じ方法でルーティングすることができる。

### チャンネルの創設と資金調達

RGBアセットを伝送するライトニング・チャンネルを作成するには、2つの要素が必要だ：


- ビットコインは、チャンネルの2/2マルチシグ（チャンネルの基本的なUTXO）を作成するために資金を提供する；
- 同じマルチシグにアセットを送るRGBファンディング。

ビットコイン用語では、資金取引は、それが少量のサットしか含んでいないとしても、参照UTXOを定義するために存在しなければなりません（それは、将来のコミットメントトランザクションにおける各出力がダストリミットをすべて超えて残っているだけの問題です）。例えば、アリスは10kサットと500USDT（RGBアセットとして発行）を提供することを決定するかもしれない。資金取引において、我々はRGBの状態遷移を固定するコミットメント（`Opret`または`Tapret`）を追加する。

![RGB-Bitcoin](assets/fr/091.webp)

資金調達トランザクションが準備されると（まだブロードキャストされていない）、コミットメントトランザクションが作成され、いずれかの当事者がいつでも一方的にチャネルを閉じることができるようになる。これらのトランザクションはLightningの古典的なコミットメントトランザクションに似ているが、新しい状態遷移にリンクされたRGBアンカー（OP_RETURNまたはTaproot）を含む追加出力を追加する点が異なる。

RGB状態遷移は、資金調達の2/2マルチシグからコミットメントトランザクションのアウトプットに資産を移動させる。このプロセスの利点は、RGB状態のセキュリティがLightningの罰則の仕組みと完全に一致することである。ボブが古いチャネル状態をブロードキャストした場合、アリスは彼を罰し、サットとRGBトークンの両方を回復するために出力を使うことができる。そのため、攻撃者は衛星だけでなくチャネルのRGB資産も失う可能性があるため、RGB資産を持たないLightningチャネルよりもインセンティブはさらに強くなる。

したがって、Aliceが署名してBobに送るコミットメント・トランザクションは次のようになる：

![RGB-Bitcoin](assets/fr/092.webp)

そして、ボブによって署名され、アリスに送られるコミットメント・トランザクショ ンは以下のようになる：

![RGB-Bitcoin](assets/fr/093.webp)

### チャンネル更新

2つのチャネル参加者間で支払いが発生した場合（または資産配分の変更を希望した場合）、参加者は新しいコミットメント・トランザクションのペアを作成する。その主な役割は有効なUTXOの構築を可能にすることであるため、各出力のsatsの金額は、実装によって変更されない場合もある。一方、OP_RETURN（またはTaproot）出力は、チャネル内の資産の新しい配分を表す新しいRGBアンカーを含むように変更されなければならない。

例えば、AliceがチャネルでBobに30 USDTを送金した場合、新しい状態遷移はAliceに400 USDT、Bobに100 USDTの残高を反映する。コミット・トランザクションは、この遷移を含むようにOP_RETURN/Taprootアンカーに追加される（または変更される）。RGBから見ると、トランジションへの入力は最初のマルチシグ（チャネルが閉じるまでオンチェーン資産が実際に割り当てられる）のままであることに注意してください。RGBの出力（割り当て）だけが、決定された再分配に応じて変化する。

アリスによって署名されたコミットメント・トランザクションは、ボブによって配布される準備ができている：

![RGB-Bitcoin](assets/fr/094.webp)

ボブによって署名されたコミットメント・トランザクションは、アリスによって配布される準備ができている：

![RGB-Bitcoin](assets/fr/095.webp)

### HTLC管理

実際には、ライトニング・ネットワークは、HTLC（*Hashed Time-Locked Contracts*）を使用して、複数のチャネルを経由した支払いを可能にします。これはRGBでも同じです。チャネルを経由する支払いごとに、コミットするトランザクションにHTLCの出力が追加され、このHTLCにリンクされたRGBの割り当てが行われます。したがって、（秘密のおかげで、あるいはタイムロックの失効後に）HTLC出力を使用した者は、サットと関連するRGB資産の両方を回収する。一方、衛星とRGB資産の両方について、路上で十分な現金が必要であることは明らかです。

![RGB-Bitcoin](assets/fr/096.webp)

したがって、Lightning上のRGBの動作は、Lightningネットワーク自体の動作と並行して考える必要があります。このテーマをより深く掘り下げたい場合は、この他の包括的なトレーニングコースをご覧になることを強くお勧めする：

https://planb.network/courses/lnp201
### RGBコードマップ

最後に、次のセクションに進む前に、RGBで使われているコードの概要を説明したい。このプロトコルは、一連のRustライブラリーとオープンソースの仕様に基づいている。主なリポジトリとクレートの概要は以下の通りです：

![RGB-Bitcoin](assets/fr/097.webp)

#### クライアント側の検証


- リポジトリ**：[クライアントサイド検証](https://github.com/LNP-BP/client_side_validation)
- クレート** ：[client_side_validation](https://crates.io/crates/client_side_validation)、[single_use_seals](https://crates.io/crates/single_use_seals)

オフチェーン検証およびシングルユースシールロジックの管理。

#### 決定論的ビットコインコミットメント（DBC）


- リポジトリ**：[bp-core](https://github.com/BP-WG/bp-core)
- クレート**：[bp-dbc](https://crates.io/crates/bp-dbc)

ビットコイントランザクションにおける決定論的アンカーリングの管理（Tapret、OP_RETURNなど）。

#### マルチプロトコルコミットメント（MPC）


- リポジトリ**：[クライアントサイド検証](https://github.com/LNP-BP/client_side_validation)
- クレート** ：[commit_verify](https://crates.io/crates/commit_verify)

複数のエンゲージメントの組み合わせと異なるプロトコルとの統合。

#### 厳密な型と厳密なエンコーディング


- 仕様**：[website strict-types.org](https://www.strict-types.org/)
- リポジトリ**：[strict-types](https://github.com/strict-types/strict-types)、[strict-encoding](https://github.com/strict-types/strict-encoding)
- クレート** ：[strict_types](https://crates.io/crates/strict_types)、[strict_encoding](https://crates.io/crates/strict_encoding)

厳密な型付けシステムと決定論的なシリアライゼーションは、クライアント側の検証に使用される。

#### RGBコア


- リポジトリ**：[rgb-core](https://github.com/RGB-WG/rgb-core)
- クレート**：[rgb-core](https://crates.io/crates/rgb-core)

プロトコルの中核で、RGB検証の主要なロジックを包含する。

#### RGB標準ライブラリ＆ウォレット


- リポジトリ**：[rgb-std](https://github.com/RGB-WG/rgb-std)
- クレート** ：[rgb-std](https://crates.io/crates/rgb-std)

標準的な実装、スタッシュとウォレットの管理。

#### RGB CLI


- リポジトリ**：[rgb](https://github.com/RGB-WG/rgb)
- クレート**：[rgb-cli](https://crates.io/crates/rgb-cli)、[rgb-wallet](https://crates.io/crates/rgb-wallet)

コマンドラインでコントラクトを操作するための `rgb` CLI と crate wallet。

#### RGBスキーマ


- リポジトリ**：[rgb-schemata](https://github.com/RGB-WG/rgb-schemata/)

スキーマ（NIA、UDAなど）とその実装例を掲載。

#### ALuVM


- 情報** ：[aluvm.org](https://www.aluvm.org/)
- リポジトリ**：[aluvm-spec](https://github.com/AluVM/aluvm-spec), [alure](https://github.com/AluVM/alure)
- クレート**：[aluvm](https://crates.io/crates/aluvm)、[aluasm](https://crates.io/crates/aluasm)

検証スクリプトの実行に使用されるレジストリベースの仮想マシン。

#### ビットコインプロトコル - BP


- リポジトリ** ：[bp-core](https://github.com/BP-WG/bp-core), [bp-std](https://github.com/BP-WG/bp-std), [bp-wallet](https://github.com/BP-WG/bp-wallet)

ビットコインプロトコルをサポートするアドオン（トランザクション、バイパスなど）。

#### ユビキタス決定論的コンピューティング - UBIDECO


- リポジトリ**：[UBIDECO](https://github.com/UBIDECO)

オープンソースの決定論的開発とリンクしたエコシステム。

# RGBを基礎とする

<partId>3b4b0d66-0c1b-505a-b5ca-4b2e57dd73c2</partId>

## DIBAとビットマスク・プロジェクト

<chapterId>dc92a5e8-ed93-5a3f-bcd0-d433932842f4</chapterId>

![video](https://youtu.be/nbUtV8GOR_U)

コースの最終セクションは、RGBブートキャンプでの様々なスピーカーによるプレゼンテーションに基づいています。RGBとそのエコシステムについての証言や考察、プロトコルに基づいたツールやプロジェクトのプレゼンテーションが含まれている。この最初の章はHunter Beastが、次の2章はFrederico Tengaがモデレーターを務める。

### JavaScriptからRustへ、そしてビットコインのエコシステムへ

当初、ハンター・ビーストは主にJavaScriptを使っていた。その後、彼は**Rust**に出会ったが、その構文は最初は魅力的でなく、フラストレーションがたまるように思えた。しかし、彼はこの言語のパワー、メモリ（*ヒープ*と*スタック*）の制御、それに伴うセキュリティとパフォーマンスを高く評価するようになった。彼は、Rustがコンピュータの仕組みを深く理解するための優れたトレーニングの場であることを強調している。

ハンター・ビーストは、イーサリアム（Solidity、TypeScriptなど）、後のファイルコインなど、*altcoin*エコシステムの様々なプロジェクトでの経歴を語る。彼は当初、いくつかのプロトコルに感銘を受けたが、結局はそのほとんどに幻滅を感じたと説明する。彼は、怪しげな金銭的インセンティブ、投資家を希薄化させるトークンのインフレ的創出、そしてこれらのプロジェクトの潜在的な搾取的側面を非難している。彼は結局、**ビットコイン最大主義者**のスタンスを採用することになったが、その理由は特に、ビットコインの健全な経済メカニズムとこのシステムの堅牢性に目を開かせてくれた人々がいたからである。

### RGBとレイヤーの魅力

彼の言葉を借りれば、ビットコインの関連性を決定的に確信させたのは、RGBの発見とレイヤーの概念だった。彼は、他のブロックチェーンにある既存の機能は、基本プロトコルを変更することなく、ビットコインより上位のレイヤーで再現できると考えている。

2022年2月、彼は特にRGB、特に**Bitmask**ウォレットに取り組むために**DIBA**に加わった。当時、Bitmaskはまだバージョン0.01で、単一トークンの管理のためだけにバージョン0.4でRGBを実行していた。ロジックの一部がサーバーベースであったため、現在よりもセルフ・カストディ指向ではなかったと彼は指摘する。それ以来、アーキテクチャはこのモデルに向かって進化し、ビットコイナーから高く評価されている。

### RGBプロトコルの基礎

RGB**プロトコルは、2012年から2013年頃にすでに検討されていた「カラーコイン」のコンセプトを最も新しく、最も進んだ形で具現化したものである。当時、いくつかのチームがUTXOに異なるビットコインの価値を関連付けようとしていたため、複数の実装が散在することになった。このような標準化の欠如と当時の需要の低さが、これらのソリューションが永続的な足場を築くことを妨げた。

今日、RGBは、LNP/BPアソシエーションによるその概念的な堅牢性と統一された仕様で際立っている。原理はクライアント側の検証に基づいている。Bitcoinブロックチェーンは暗号コミットメント（_commitments_、TaprootまたはOP_RETURN経由）のみを保存し、大部分のデータ（契約定義、送金履歴など）は関係するユーザーによって保存される。こうすることで、ブロックチェーンを重くすることなく、保管負荷が分散され、交換の機密性が強化される。このアプローチにより、モジュール式でスケーラブルなフレームワーク内で、カジブル・アセット（***RGB20**規格）またはユニーク・アセット（***RGB21**規格）の作成が可能になる。

### トークン機能（RGB20）とユニークアセット（RGB21）

RGB20**では、ビットコイン上のカンジブルトークンを定義する。発行者は「供給」と「精度」を選択し、「契約」を作成します。各送金はビットコインのUTXOに参照され、それは*シングルユースシール*として機能する。このロジックは、UTXOを支出できる人だけがクライアント側のコントラクトの状態を更新するキーを実際に保持しているため、ユーザーが同じアセットを2回使用できないことを保証します。

**RGB21**は一意のアセット（または「NFT」）を対象とする。アセットには1のサプライがあり、特定のフィールドを介して記述されたメタデータ（画像ファイル、オーディオなど）と関連付けることができる。パブリック・ブロックチェーン上のNFTとは異なり、データとそのMIME識別子はプライベートのまま、所有者の裁量でピアツーピアで分散することができる。

### ビットマスク・ソリューション：RGB用の財布

RGBの機能を実際に利用するために、**DIBA**プロジェクトは[Bitmask](https://bitmask.app/)と呼ばれるウォレットを設計した。このアイデアは、Webアプリケーションまたはブラウザ拡張機能としてアクセス可能な、非保護のTaprootベースのツールを提供することである。BitmaskはRGB20とRGB21の両方のアセットを管理し、様々なセキュリティ・メカニズムを統合している：


- コアコードはRustで書かれ、JavaScript環境（React）で実行するためにWebAssemblyでコンパイルされる；
- 鍵はローカルで生成され、ローカルで暗号化されて保存される；
- 状態データ（スタッシュ）はメモリに保持され、シリアライズされ、**Carbonado**ライブラリーを介して暗号化される。Carbonado**ライブラリーは、Blake3を使って圧縮、エラー訂正、暗号化、ストリーム検証を行う。

このアーキテクチャのおかげで、すべての資産取引はクライアント側で行われる。外部から見れば、ビットコインの取引は古典的なTaprootの支出取引に過ぎず、換金可能なトークンやNFTの送金であることを疑う人はいない。オンチェーンでのオーバーロードがない（公に保存されたメタデータがない）ため、一定の慎重さが保証され、検閲の試みにも抵抗しやすくなる。

### セキュリティと分散アーキテクチャ

RGBプロトコルが各参加者の取引履歴を保持することを要求している以上（受け取った送金の正当性を証明するため）、ストレージの問題が生じる。Bitmaskは、この隠し場所をローカルでシリアライズし、それを複数のサーバーまたはクラウド（オプション）に送信することを提案している。データは**Carbonado**を介してユーザーによって暗号化されたままなので、サーバーはそれを読むことができない。部分的な破損が発生した場合、エラー訂正レイヤーがコンテンツを再構成することができる。

CRDT（_Conflict-free replicated data type_）を使用することで、異なるバージョンの隠し場所が異なっても、それらをマージすることができる。アセットにリンクされたすべての情報を単一の完全なノードが保持することはないため、誰もが自由に好きな場所でこのデータをホストすることができます。これはまさに*Client-side Validation*の哲学を反映したもので、各所有者は自分のRGBアセットの有効性の証拠を保存する責任があります。

### より広範なエコシステムへ：マーケットプレイス、相互運用性、新機能

Bitmaskの背後にある会社は、単純な財布の開発に自分自身を制限していません。DIBAは.NETを開発するつもりだ：


- 特に**RGB21**形式のトークンを交換するための**マーケットプレイス**；
- 他のウォレット（*Iris Wallet*など）との互換性；
- 転送バッチ**技術、すなわち、1つのトランザクションに複数の連続したRGB転送を含める可能性。

同時に、我々は**WebBTC**または**WebLN**（ウェブサイトがウォレットにビットコインまたはライトニングトランザクションの署名を依頼することを可能にする標準規格）、およびOrdinalsエントリを「テレバーン」する機能（Ordinalsをより控えめで柔軟なRGBフォーマットに戻したい場合）に取り組んでいます。

### 結論

このプロセス全体は、RGBエコシステムがどのように展開され、強固な技術的ソリューションを通じてエンドユーザーがアクセスできるようになるかを示している。アルトコインの視点からよりビットコイン中心のビジョンへの移行は、*Client-side Validation*の発見と相まって、かなり論理的な道筋を示しています。ブロックチェーンをフォークすることなく、TaprootトランザクションまたはOP_RETURNの暗号化コミットメントを利用するだけで、様々な機能性（funggibleトークン、NFT、スマートコントラクト...）を実装することが可能であることを理解しています。

Bitmask**ウォレットは、このアプローチの一部である。ブロックチェーン側では、通常のビットコイン取引しか見ることができず、ユーザー側では、あらゆる種類のオフチェーン資産を作成、交換、保管するウェブ・インターフェースを操作する。このモデルは、通貨インフラ（ビットコイン）と発行・送金ロジック（RGB）を明確に切り離し、高い機密性と優れたスケーラビリティを保証する。

## ビットフィネックスのRGBに関する取り組み

<chapterId>d4d80e07-5eac-5b29-a93a-123180e97047</chapterId>

![vidéo](https://youtu.be/5iAhsgCSL3U)

この章では、Frederico Tenga氏のプレゼンテーションに基づき、このプロトコルを中心とした豊かで多様なエコシステムの出現を促進することを目的として、RGBに特化したBitfinexチームによって作成された一連のツールとプロジェクトを見ていきます。チームの最初の目的は、特定の商業製品をリリースすることではなく、むしろソフトウェアビルディングブロックを提供し、RGBプロトコル自体に貢献し、モバイルウォレット（*Iris Wallet*）やRGB互換のLightningノードなどの具体的な実装リファレンスを提案することです。

### 背景と目的

2022 年頃から、Bitfinex RGB チームは、RGB を効率的に悪用しテストすることを可能にする技術スタックの開発に集中してきました。いくつかの貢献がなされています：


- ソースコードやプロトコル仕様への参加（機能強化提案書の作成、バグ修正などを含む
- アプリケーションへのRGBの統合を簡素化する開発者向けツール；
- Iris](https://iriswallet.com/)と名付けられたモバイル・ウォレットのデザインは、RGBを使用するためのベストプラクティスを実験し、説明するためのものである；
- RGBアセットでチャンネルを管理できる、カスタマイズされたLightningノードの作成；
- RGBでソリューションを構築する他のチームをサポートし、多様性と強力なエコシステムを促進する。

このアプローチは、ウォレットの実装を可能にする低レベルのライブラリ（*[RGBlib](https://github.com/RGB-Tools/rgb-lib)*）から、製造面（ライトニング・ノード、アンドロイド用ウォレットなど）まで、ニーズの連鎖全体をカバーすることを目的としている。

### RGBlibライブラリ：RGBアプリケーションの開発を簡素化する

RGBウォレットとアプリケーションの作成を民主化する上で重要な点は、開発者がプロトコルの内部ロジックについてすべてを学ぶ必要がないように、十分にシンプルな抽象化を利用できるようにすることです。これこそが、Rustで書かれた**RGBlib**の目的である。

RGBlibは、これまでの章で研究してきたRGBの非常に柔軟な（しかし時には複雑な）要件と、アプリケーション開発者の具体的なニーズとの橋渡しの役割を果たします。言い換えれば、トークンの転送、資産の発行、検証などを管理したいウォレット（またはサービス）は、暗号の詳細やカスタマイズ可能なRGBパラメータのすべてを知らなくても、RGBlibに依存することができます。

この書店では：


- 発行（_issuance）資産（カンジブルかどうかは問わない）を発行するターンキー機能；
- 単純なオブジェクト（アドレス、金額、UTXOなど）を操作することで、アセットを転送（送受信）する機能；
- Client-side Validationに必要なステータス情報(*consignments*)を保存し、ロードするためのメカニズム。

そのため、RGBlibはRGB特有の複雑な概念（クライアントサイドの検証、Tapret/Opretアンカー）に依存していますが、最終的なアプリケーションがすべてをプログラムし直したり、危険な決断をする必要がないように、それらをカプセル化しています。さらに、RGBlibはすでにいくつかの言語（KotlinとPython）でバインドされており、単純なRustの世界を超えた用途への扉を開いています。

### Iris Wallet: AndroidでのRGBウォレットの例

RGBlib の有効性を証明するため、Bitfinex チームは **Iris Wallet** を開発しました。これは、通常のビットコイン・ウォレットと同様のユーザー・エクスペリエンスを示すモバイル・ウォレットで、アセットの発行、送信、受信、履歴の閲覧が可能で、セルフ・カストディ・モデルのままです。

アイリスには興味深い特徴がいくつもある：

**エレクトラムのサーバーを使用する。

他のウォレットと同様、Irisもブロックチェーン上の取引確認を知る必要がある。Irisは、完全なノードを組み込むのではなく、デフォルトでBitfinexチームが管理するElectrumサーバーを使用する。しかし、ユーザーは自分のサーバーや他のサードパーティーのサービスを設定することができる。こうすることで、ビットコイン取引をモジュール方式で検証し、情報を検索（インデックス化）することができる。

**RGBプロキシサーバー

ビットコインとは異なり、RGBは送り手と受け手の間でオフチェーンのメタデータ（*委託*）を交換する必要がある。このプロセスを簡略化するために、Irisはプロキシサーバー経由で通信が行われるソリューションを提供しています。受信側のウォレットは、送信者が*クライアント側*のデータをどこに送るべきかを記した*インボイス*を生成します。デフォルトでは、URLはBitfinexチームがホストするプロキシを指しますが、このプロキシを変更することもできます（または自分でホストすることもできます）。このアイデアは、複雑な追加操作なしに、受信者がQRコードを表示し、送信者が取引のためにこのコードをスキャンするという、馴染みのあるユーザーエクスペリエンスに戻ることです。

**連続バックアップ

厳密にはビットコインのコンテキストでは、シードをバックアップすれば一般的に十分です（最近では代わりにシードとディスクリプタをバックアップすることを推奨していますが）。RGBでは、これだけでは十分ではありません。あなたが本当にRGB資産を所有していることを証明するローカル履歴（*領収書*）も保管する必要があります。レシートを受け取るたびに、デバイスは新しいデータを保存し、それはその後の支出に不可欠です。アイリスは、ユーザーのグーグル・ドライブに暗号化されたバックアップを自動的に管理する。バックアップが暗号化されているため、グーグルに対する特別な信頼は必要なく、第三者事業者による検閲や削除のリスクを回避するため、将来的にはより強固なオプション（個人サーバーなど）が計画されている。

**その他の特徴


- 実験やプロモーションのために、素早くテストしたりトークンを配布したりするための蛇口を作る；
- 有名なティッカーをコピーした正規のトークンと偽のトークンを見分けるための認証システム（現在は中央集権型）。将来的には、この認証は（DNSやその他のメカニズムによって）より分散化されるかもしれない。

全体として、Irisは古典的なビットコイン・ウォレットに近いユーザー体験を提供し、RGBlibとプロキシサーバーの使用により、追加の複雑さ（隠し場所管理、*委託*履歴など）を隠している。

### プロキシサーバーとユーザー体験

上で紹介したプロキシサーバーは、スムーズなユーザーエクスペリエンスの鍵であるため、詳しく説明する価値がある。送信者が受信者に*割り当て*を手動で送信する代わりに、RGBトランザクションは.NET Frameworkを介してバックグラウンドで行われます：


- 受信者は（特にプロキシのアドレスを含む）*請求書を作成する；
- 送信者は（HTTPリクエストで）トランジション・プロジェクト（*委託*）をプロキシに送信する；
- 受信者はこのプロジェクトを取得し、*クライアント側*の検証をローカルで実行する；
- その後、受信者はプロキシを介して、状態遷移の受諾(または場合によっては拒否)を発行する；
- 送信者は検証ステータスを見ることができ、受け入れられた場合、送金を確定するビットコイントランザクションをブロードキャストする。

このようにして、ウォレットはほとんど通常のウォレットのように動作する。ユーザーはすべての中間ステップを意識することはない。確かに、現在のプロキシは暗号化も認証もされていないが（これは機密性と完全性についての懸念を残す）、これらの改善は後のバージョンで可能である。プロキシのコンセプトは、「私がQRコードを送信し、あなたがスキャンして支払う」という体験を再現するのに非常に有用であることに変わりはない。

### ライトニング・ネットワークでのRGB統合

Bitfinexチームの作業のもう一つの重要な焦点は、ライトニングネットワークをRGB資産と互換性を持たせることである。その目的は、USDT（または他のトークン）でライトニングチャンネルを可能にし、ライトニング上でビットコインと同じ利点（ほぼ瞬時の取引、ルーティングなど）の恩恵を受けることです。具体的には、.Lightningに変更されたLightningノードを作成することです：


- サトシだけでなく、1つ以上のRGBアセットをファンディングUTXOマルチシグに配置してチャンネルを開きます；
- 対応するRGB状態遷移を伴うLightningコミットメントトランザクション（Bitcoin側）を生成する。チャネルが更新されるたびに、RGB遷移がLightning出力の資産分布を再定義する；
- ライトニングネットワークのルール（HTLC、タイムロック、罰など）に従い、アセットが排他的UTXOで回収される一方的な閉鎖を可能にする。

このソリューションは "**RGB Lightning Node**"と名付けられ、ベースとしてLDK (*Lightning Dev Kit*)を使用し、チャンネルにRGBトークンを注入するために必要なメカニズムを追加する。Lightningコミットメントは古典的な構造（パンクチャブル出力、タイムロック...）を保持し、さらに（`Opret`または`Tapret`を介して）RGBの状態遷移をアンカーします。ユーザーにとっては、安定コインやRGB経由で発行されるその他のアセットにLightningチャネルへの道を開くことになる。

### DEXの可能性とビットコインへの影響

複数のアセットがLightning経由で管理されるようになると、シークレットとタイムロックの同じロジックを使用して、単一のLightningルーティングパス上の**アトミック取引所**を想像することが可能になる。例えば、ユーザーAはあるLightningチャネルでビットコインを保有し、ユーザーBは別のLightningチャネルでUSDT RGBを保有している。彼らは2つのチャネルをリンクするパスを構築し、同時にBTCをUSDTに交換することができます。これは数ホップで行われる**アトミックスワップ**に過ぎず、外部参加者は単なるルーティングではなく、取引を行っているという事実にほとんど気づかない。このアプローチは、：


- Lightningではすべてがオフチェーンのままなので、レイテンシーは非常に低い。
- 優れた**プライバシー**：通常のルーティングではなく、トレードであることを誰も知らない；
- オンチェーンDEXで繰り返し問題となるフロントランニングを回避する；
- コスト削減（ブロックスペースの支払いはなく、ライトニングのルーティング料のみ）。

そして、Lightningノードが（流動性を提供することで）スワップ価格を提供するエコシステムを想像することができる。各ノードが望めば、Lightning上で様々な資産を売買する「マーケットメーカー」の役割を果たすことができる。このようなレイヤー2DEXの展望は、分散型資産取引所を手に入れるためにサードパーティのブロックチェーンをフォークしたり利用したりする必要はないという考えを補強するものである。

ビットコインへの影響はプラスに働く可能性がある：Lightningのインフラ（ノード、チャネル、サービス）は、これらの*ステーブルコイン*、デリバティブ、その他のトークンによって生成されたボリュームのおかげで、よりフルに活用されるだろう。LightningでのUSDT決済に関心のある加盟店は、（同じスタックによって管理される）LightningでのBTC決済を機械的に発見するだろう。ライトニングネットワークインフラのメンテナンスと資金調達も、これらの非BTCフローの増加から利益を得ることができ、間接的にビットコインユーザーに利益をもたらすだろう。

### 結論とリソース

RGBを専門とするBitfinexチームは、その仕事を通じて、プロトコルの上で何ができるかの多様性を示している。一方では、ウォレットやアプリケーションの設計を容易にするライブラリであるRGBlibがある。もう一方には、Iris Walletがあり、これはAndroid上で端正なエンドユーザーインターフェースの実用的なデモンストレーションである。最後に、RGBとLightningの統合は、stablecoinチャネルが可能であることを示し、Lightning上の分散型DEXの可能性への道を開いている。

RGBlibライブラリは改良されつつあり、Iris Walletは定期的な機能強化を受けていますし、専用のLightningノードはまだ主流のLightningクライアントではありません。

さらに詳しく知りたい方、貢献したい方のために、以下のリソースが用意されている：


- [GitHub RGB Toolsリポジトリ](https://github.com/RGB-Tools)；
- [Iris Wallet専用の情報サイト](https://iriswallet.com/)で、アンドロイドのウォレットをテストする。

次の章では、RGBライトニング・ノードの起動方法について詳しく見ていこう。

## RLN - RGBライトニングノード

<chapterId>ecaabe32-20ba-5f8c-8ca1-a3f095792958</chapterId>

![vidéo](https://youtu.be/piQQH4Q2nr0)

この最終章では、Frederico Tenga氏が、Regtest環境上でLightning RGBノードをセットアップし、その上でRGBトークンを作成する方法を順を追って説明します。2つの別々のノードを起動することで、それらの間でLightningチャネルを開き、RGBアセットを交換する方法も紹介します。

このビデオは、前の章で取り上げたのと同じようなチュートリアルになっているが、今回は特にライトニングに焦点を当てている！

このビデオの主なリソースはGithubリポジトリ[RGB Lightning Node](https://github.com/RGB-Tools/rgb-lightning-node)です。このリポジトリを使えば、Regtestでこの設定を簡単に起動できます。

### RGB対応Lightningノードの導入

このプロセスでは、前の章で扱ったすべての概念を取り上げ、実践する：


- ライトニングチャネルの2/2マルチシグでブロックされた**UTXO**は、ビットコインだけでなく、RGB資産のシングルユースシール（カンジブルかどうか）も受け取ることができるというアイデア；
- 各ライトニング・エンゲージメント・トランザクションにおいて、RGBの状態遷移を固定するための出力（`Tapret`または`Opret`）が追加される；
- ビットコインのトランザクションを検証し、*クライアント側*のデータを交換するための関連インフラ（bitcoind/indexer/proxy）。

### rgb-lightning-nodeの紹介

rgb-lightning-node`**プロジェクトは `rust-lightning` (LDK) フォークをベースに、チャンネル内のRGBアセットの存在を考慮するように修正したRustデーモンです。チャネルがオープンされると、アセットの存在を指定することができ、チャネルの状態が更新されるたびに、Lightning 出力におけるアセットの分布を反映した RGB トランジションが作成されます。これにより、：


- 例えばUSDTのライトニング・チャネルを開く；
- ルーティング経路に十分な流動性があれば、これらのトークンをネットワークを通じてルーティングする；
- コミットメントトランザクションの追加出力にRGBトランジションをアンカーするだけです。

コードはまだアルファの段階です：**regtest**または**testnet**でのみ使用することをお勧めします。

### ノードのインストール

rgb-lightning-node`バイナリをコンパイルしてインストールするには、まずリポジトリとそのサブモジュールをクローンし、：

```bash
git clone https://github.com/RGB-Tools/rgb-lightning-node --recurse-submodules --shallow-submodules
```

![RGB-Bitcoin](assets/fr/098.webp)


- recurse-submodules`オプションは、必要なサブデバイス（修正版の`rust-lightning`を含む）のクローンも作成する；
- shallow-submodules`オプションは、クローンの深さを制限してダウンロードを高速化しつつ、重要なコミットへのアクセスを提供する。

プロジェクト・ルートから以下のコマンドを実行し、バイナリ.NET Frameworkをコンパイルしてインストールする：

```bash
cargo install --locked --debug --path .
```

![RGB-Bitcoin](assets/fr/099.webp)


- locked`は、依存関係のバージョンが厳密に尊重されることを保証する；
- debug`は必須ではありませんが、集中するのに役立ちます（お好みで`--release`を使うこともできます）；
- -path .` はカレントディレクトリからインストールするように `cargo install` に指示する。

このコマンドを実行すると、`$CARGO_HOME/bin/` に `rgb-lightning-node` の実行ファイルが作成されます。このパスが `$PATH` に含まれていることを確認してください。

### パフォーマンス要件

rgb-lightning-node`デーモンが機能するには、.NET Frameworkの存在と設定が必要である：


- bitcoind`**ノード

各 RLN インスタンスは、オンチェーン取引をブロードキャストし監視するために `bitcoind` と通信する必要がある。認証（ログイン/パスワード）とURL（ホスト/ポート）をデーモンに提供する必要がある。


- インデクサー**（エレクトラムまたはエスプローラ）

デーモンは、チェーン上のトランザクションをリストアップし、探索することができなければなりません。特に、アセットがアンカーされたUTXOを見つけることができなければなりません。ElectrumサーバーまたはEsploraのURLを指定する必要があります。


- RGB**プロキシ

前の章で見たように、**プロキシサーバー** は、Lightning ピアの間で**委託**の交換を簡素化するためのコンポーネントです（オプションですが、強く推奨します）。ここでも URL を指定する必要があります。

IDおよびURLは、デーモンがAPIを介してロック解除されたときに入力される。これについては後で詳しく説明します。

### レグテスト開始

簡単な使い方としては、Docker経由で一連のサービスを自動的に起動する `regtest.sh` スクリプトがある：bitcoind`、`electrs`（インデクサ）、`rgb-proxy-server`である。

![RGB-Bitcoin](assets/fr/100.webp)

これにより、ローカルで隔離された、設定済みの環境を起動できる。再起動するたびにコンテナとデータ・ディレクトリを作成・破棄する。まずは.NET Frameworkを起動する：

```bash
./regtest.sh start
```

このスクリプトは：


- .NET Frameworkを格納する`docker/`ディレクトリを作成する；
- regtest で `bitcoind` を実行し、インデクサ `electrs` と `rgb-proxy-server` も実行する；
- すべての準備が整うまで待つ。

![RGB-Bitcoin](assets/fr/101.webp)

次に、複数のRLNノードを起動する。別々のシェルで、例えば（3つのRLNノードを起動するために）：

```bash
# 1st shell
rgb-lightning-node dataldk0/ --daemon-listening-port 3001 \
--ldk-peer-listening-port 9735 --network regtest
# 2nd shell
rgb-lightning-node dataldk1/ --daemon-listening-port 3002 \
--ldk-peer-listening-port 9736 --network regtest
# 3rd shell
rgb-lightning-node dataldk2/ --daemon-listening-port 3003 \
--ldk-peer-listening-port 9737 --network regtest
```

![RGB-Bitcoin](assets/fr/102.webp)


- network regtest` パラメーターは、regtestコンフィギュレーションの使用を示す；
- --daemon-listening-port`は、LightningノードがAPIコール（JSON）をリッスンするRESTポートを示す；
- --ldk-peer-listening-port`は、リッスンするLightning p2pポートを指定する；
- dataldk0/`、`dataldk1/`はストレージ・ディレクトリへのパスである（各ノードは別々に情報を保存する）。

また、ブラウザからRLNノード上でコマンドを実行することもできます：

```url
https://rgb-tools.github.io/rgb-lightning-node/
```

ノードがチャネルを開くには、まず以下のコマンドで生成されたアドレスにビットコインがなければなりません（例えばノードn°1の場合）：

```bash
curl -X POST http://localhost:3001/address
```

答えは住所を教えてくれる。

![RGB-Bitcoin](assets/fr/103.webp)

bitcoind` Regtestで、ビットコインを少し採掘してみよう。実行する：

```bash
./regtest.sh mine 101
```

![RGB-Bitcoin](assets/fr/104.webp)

上記のノード・アドレスに送金する：

```bash
./regtest.sh sendtoaddress <address> <amount>
```

![RGB-Bitcoin](assets/fr/105.webp)

その後、取引を確認するためにブロックを採掘する：

```bash
./regtest.sh mine 1
```

![RGB-Bitcoin](assets/fr/106.webp)

### テストネットの立ち上げ（Dockerなし）

より現実的なシナリオをテストしたい場合は、RegtestではなくTestnet上で3つのRLNノードを立ち上げ、パブリックサービスを指すようにします：

```bash
rgb-lightning-node dataldk0/ --daemon-listening-port 3001 \
--ldk-peer-listening-port 9735 --network testnet
rgb-lightning-node dataldk1/ --daemon-listening-port 3002 \
--ldk-peer-listening-port 9736 --network testnet
rgb-lightning-node dataldk2/ --daemon-listening-port 3003 \
--ldk-peer-listening-port 9737 --network testnet
```

デフォルトでは、コンフィギュレーションが見つからない場合、デーモンは：


- `bitcoind_rpc_host`: `electrum.iriswallet.com`
- bitcoind_rpc_port`: `18332`
- indexer_url`: `ssl://electrum.iriswallet.com:50013`
- `proxy_endpoint`: `rpcs://proxy.iriswallet.com/0.2/json-rpc`

ログインが必要です：


- bitcoind_rpc_ユーザー名`: `user`
- bitcoind_rpc_username`: `password`

これらの要素は `init`/`unlock` API を使ってカスタマイズすることもできる。

### RGBトークンの発行

トークンを発行するには、まず "colorable "なUTXOを作ることから始める：

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"up_to": false,
"num": 4,
"size": 2000000,
"fee_rate": 4.2,
"skip_sync": false
}' \
http://localhost:3001/createutxos
```

![RGB-Bitcoin](assets/fr/107.webp)

もちろん、注文を変更することもできます。取引を確認するために、.NET Frameworkを採掘します：

```bash
./regtest.sh mine 1
```

これで RGB アセットを作成できます。コマンドは作成したいアセットの種類とパラメータによって異なります。ここでは、"PBN" という名前の NIA (*Non Inflatable Asset*) トークンを 1000 ユニットで作成しています。precision`でユニットの分割率を指定します。

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"amounts": [
1000
],
"ticker": "PBN",
"name": "Plan B Network",
"precision": 0
}' \
http://localhost:3001/issueassetnia
```

![RGB-Bitcoin](assets/fr/108.webp)

レスポンスには、新しく作成されたアセットのIDが含まれます。この識別子を覚えておいてください。私の場合は、：

```txt
rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10
```

![RGB-Bitcoin](assets/fr/109.webp)

その後、オンチェーンで転送したり、Lightningチャネルに割り当てたりすることができます。次のセクションで行うのはまさにこれだ。

### チャンネルを開き、RGBアセットを転送する

まず、`/connectpeer`コマンドを使用して、自分のノードをLightningネットワーク上のピアに接続する必要がある。この例では、私は両方のノードをコントロールしている。そこで、2つ目のLightningノードの公開鍵をこのコマンドで取得する：

```bash
curl -X 'GET' \
'http://localhost:3002/nodeinfo' \
-H 'accept: application/json'
```

コマンドは私のノードn°2の公開鍵を返す：

```txt
031e81e4c5c6b6a50cbf5d85b15dad720fec92c62e84bafb34088f0488e00a8e94
```

![RGB-Bitcoin](assets/fr/110.webp)

次に、関連するアセット（`PBN`）を指定してチャンネルを開きます。openchannel` コマンドでは、チャンネルのサイズを satoshis で定義し、RGB アセットを含めるかどうかを選択できます。何を作成したいかによりますが、私の場合、コマンドは ：

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"peer_pubkey_and_opt_addr": "031e81e4c5c6b6a50cbf5d85b15dad720fec92c62e84bafb34088f0488e00a8e94@localhost:9736",
"capacity_sat": 1000000,
"push_msat": 10000000,
"asset_amount": 500,
"asset_id": "rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10",
"public": true,
"with_anchors": true,
"fee_base_msat": 1000,
"fee_proportional_millionths": 0,
"temporary_channel_id": "a8b60c8ce3067b5fc881d4831323e24751daec3b64353c8df3205ec5d838f1c5"
}' \
http://localhost:3001/openchannel
```

詳細はこちら：


- peer_pubkey_and_opt_addr`：接続したいピア (先ほど見つけた公開鍵) の識別子；
- capacity_sat`：総チャンネル容量 (satoshis) ；
- push_msat`：チャンネルがオープンされたときに、最初にピアに転送されるミリサット単位の量 (ここでは、ピアに後で RGB 転送ができるように、すぐに 10,000 サット転送します) ；
- asset_amount`：チャンネルにコミットされるRGBアセットの量；
- Asset_id` : チャンネルに参加しているRGBアセットの一意な識別子；
- public`：チャンネルをネットワーク上でルーティングするために公開するかどうかを示す。

![RGB-Bitcoin](assets/fr/111.webp)

取引を確認するために、6ブロックが採掘される：

```bash
./regtest.sh mine 6
```

![RGB-Bitcoin](assets/fr/112.webp)

Lightning チャネルはオープンされ、ノード n°1 側には 500 の `PBN` トークンがある。ノード n°2 が `PBN` トークンを受け取りたい場合は、インボイスを生成しなければならない。その方法は以下の通りです：

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"amt_msat": 3000000,
"expiry_sec": 420,
"asset_id": "rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10",
"asset_amount": 100
}' \
http://localhost:3002/lninvoice
```

と：


- amt_msat`：インボイスの金額 (最低3000sat)；
- expiry_sec` : インボイスの有効期限（秒） ；
- Asset_id` : 請求書に関連付けられたRGB資産の識別子；
- Asset_amount`：この請求書と共に譲渡されるRGB資産の金額。

これに対して、（前の章で説明したように）RGBの請求書が発行されます：

```txt
lnbcrt30u1pncgd4rdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4qv0grex9c6m22r9ltkzmzhddwg87eykx96zt47e5pz8sfz8qp28fgpp5jksvqtleryhvwr299qdz96qxzm24augy5agkdhltudk463lt9dassp5d6n0sqgl0c4gx52fdmutrdtqamt0y4xuz2rcgel4hpjwne08gmls9qyysgqcqpcxqzdylz5wfnkywnxvvmkvnt2x4fj6wre0gshvjtv95ervvzzg4592t2gdgchx6mkf5k45jrrdfn8j73d2f2xx4mrxycq7qzry4v4jan6uxhhacyqa4gn6plggwpq9j74tu74f2zsamtz6ymt600p8su4c4ap9g9d8ku2x3wdh6fuc8fd8pff2yzpjrf24ys3cltca9fgqut6gzj
```

![RGB-Bitcoin](assets/fr/113.webp)

PBN`トークンで必要な現金を保持している最初のノードから、この請求書を支払うことにする：

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"invoice": "lnbcrt30u1pncgd4rdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4qv0grex9c6m22r9ltkzmzhddwg87eykx96zt47e5pz8sfz8qp28fgpp5jksvqtleryhvwr299qdz96qxzm24augy5agkdhltudk463lt9dassp5d6n0sqgl0c4gx52fdmutrdtqamt0y4xuz2rcgel4hpjwne08gmls9qyysgqcqpcxqzdylz5wfnkywnxvvmkvnt2x4fj6wre0gshvjtv95ervvzzg4592t2gdgchx6mkf5k45jrrdfn8j73d2f2xx4mrxycq7qzry4v4jan6uxhhacyqa4gn6plggwpq9j74tu74f2zsamtz6ymt600p8su4c4ap9g9d8ku2x3wdh6fuc8fd8pff2yzpjrf24ys3cltca9fgqut6gzj"
}' \
http://localhost:3001/sendpayment
```

![RGB-Bitcoin](assets/fr/114.webp)

支払いが行われました。これは.NETコマンドを実行することで確認できる：

```bash
curl -X 'GET' \
'http://localhost:3001/listpayments' \
-H 'accept: application/json'
```

![RGB-Bitcoin](assets/fr/115.webp)

ここでは、RGBアセットを伝送するように変更されたLightningノードのデプロイ方法を説明します。このデモは.NET Frameworkをベースにしています：


- regtest 環境 (`./regtest.sh` 経由) または testnet ；
- Lightning ノード (`rgb-lightning-node`) は `bitcoind`、インデクサ、`rgb-proxy-server` をベースにしている；
- チャネルのオープン/クローズ、トークンの発行、Lightning経由でのアセット転送などを行うための一連のJSON REST API。

このプロセスのおかげだ：


- ライトニング・エンゲージメント・トランザクションには、RGBトランジションのアンカーを伴う追加出力（OP_RETURNまたはTaproot）が含まれる；
- 送金は従来のライトニング決済とまったく同じ方法で行われるが、RGBトークンが追加される；
- 複数のRLNノードは、経路上のビットコインと資産RGBの両方に十分な流動性があれば、複数のノードをまたいで支払いをルーティングし、実験するためにリンクすることができます。

このプロジェクトはまだアルファ段階です。そのため、テスト環境（regtest、testnet）に限定することを強くお勧めします。

このLN-RGBの互換性によってもたらされる可能性は、Lightning上の安定したコイン、DEXのレイヤー2、非常に低コストでのカジキブルトークンやNFTの送金など、非常に大きい。これまでの章では、概念的なアーキテクチャと検証ロジックの概要を説明してきた。これで、将来の開発やテストのために、このようなノードを立ち上げて稼働させる方法について実践的な見解が得られたことになる。

# まとめ

<partId>b0baebfc-d146-5938-849a-f835fafb386f</partId>


## レビュー＆評価

<chapterId>0217e8b0-942a-5fee-bd91-9a866551eff3</chapterId>

<isCourseReview>true</isCourseReview>。

## まとめ

<chapterId>0309536d-c336-56a0-869e-a8395ed8d9ae</chapterId>

<isCourseConclusion>真</isCourseConclusion>。
